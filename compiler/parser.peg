# This code is hereby placed in the public domain.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# %prefix "parser"

%value "ast_p_t"
%auxil "struct ParseProgress *"

%header {
        #include "util.h"
        #include "ast.h"
        typedef struct AST * ast_p_t;
}

%source {
#define PCC_ERROR(auxil){ErrorAndExit(ERROR_INTERNAL, "SYNTAX_ERROR_UNKNOWN: %d:%d\n", auxil->curLine, auxil->curCol);}
#define PCC_GETCHAR(auxil) ({int inChar = fgetc(auxil->f); if(inChar == '\n'){auxil->curLine++; auxil->curCol = 0;}else{auxil->curCol++;}; inChar;})
char *dbgEventNames[3] = {" eval", "MATCH", "nomatc"};
# define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) {\
    for(size_t i = 0; i < level ;i++){printf("-   ");}\
    printf("PCC @ %d:%2d - %s:%s", auxil->curLine, auxil->curCol, dbgEventNames[event], rule);\
    printf("[");\
    for(size_t i = 0; i < length; i++){if(buffer[i] == '\n'){printf("\\n");}else{printf("%c", buffer[i]);}}\
    printf("]\n");\
}
//#define AST_S(original, newrightmost) AST_ConstructAddSibling(original, newrightmost)
//#define AST_C(parent, child) AST_ConstructAddChild(parent, child)
//#define AST_N(token, value) AST_New(token, Dictionary_LookupOrInsert(auxil->dict, value))

#ifndef AST_S
#define AST_S(original, newrightmost) ({struct AST *constructed = AST_ConstructAddSibling(original, newrightmost); printf("AST_S %p, %p: %p\n", original, newrightmost, constructed); constructed;})
#endif
#ifndef AST_C
#define AST_C(parent, child) ({struct AST *constructed = AST_ConstructAddChild(parent, child); printf("AST_C %p, %p: %p\n", parent, child, constructed); constructed;})
#endif
#ifndef AST_N
#define AST_N(token, value) ({struct AST *created = AST_New(token, Dictionary_LookupOrInsert(auxil->dict, value)); printf("AST_N %s, %s: %p\n", getTokenName(token), value, created); created;})
#endif
}

program
   <- t:translation_unit_list _ eof           { $$ = t; }

translation_unit_list
   <- t:translation_unit _                           { $$ = t; }
    / tl:translation_unit_list _ tu:translation_unit { $$ = AST_S(tl, tu); }

translation_unit
   <- _ f:function_declaration _ ';'    { $$ = f; }
    / _ f:function_definition           { $$ = f; }
    / _ sl: statement_list              { $$ = sl; }
    / _ eof                             { $$ = AST_N(t_EOF, ""); }

variable_declaration
   <- t:type_name _ i:identifier { $$ = AST_C(t, i); }
    / t:type_name _ i:identifier _ '=' _ e:expression { $$ = AST_C(AST_N(t_assign, "="), AST_S(AST_C(t, i), e)); }

parameter_declaration
   <- t:type_name _ i:identifier { $$ = AST_C(t, i); }

parameter_list
   <- p:parameter_declaration _                         { $$ = p; }
    / pl:parameter_list _ ',' _ p:parameter_declaration { $$ = AST_S(pl, p); }

function_declaration
   <- f:fun _ i:identifier _ '(' _ ')'                    { $$ = AST_C(f, i); }
    / f:fun _ i:identifier _ '(' _ p:parameter_list _ ')' { $$ = AST_C(f, AST_S(i, p)); }

function_definition
   <- d:function_declaration _ '{' _ sl:statement_list _ '}' { $$ = AST_C(d, sl); }
    / d:function_declaration _ '{' _ '}'                     { $$ = d; }

primary_expression
   <- i:identifier _            { $$ = i; }
    / c:constant _              { $$ = c; }
    / s:string_literal _        { $$ = s; }
    / '(' _ e:expression _ ')'  { $$ = e; }

postfix_expression
   <- p:primary_expression _                              { $$ = p; }
    / p:postfix_expression _ '[' _ i:expression _ ']'     { $$ = AST_C(AST_N(t_array_index, "["), AST_S(p, i)); }
    / i:identifier _ '(' _ ')'                            { $$ = AST_C(AST_N(t_function_call, "("), i); }
    / i:identifier _ '(' _ a:argument_expression_list ')' { $$ = AST_C(AST_N(t_function_call, "("), i); }
    / p:postfix_expression _ '.' _ i:identifier           { $$ = AST_C(AST_N(t_dot, "."), AST_S(p, i)); }
    / p:postfix_expression _ a:arrow _ i:identifier    { $$ = AST_C(a, AST_S(p, i)); }

argument_expression_list
   <- a:assignment_expression _                                    { $$ = a; }
    / el:argument_expression_list _ ',' _ ae:assignment_expression { $$ = AST_S(el, ae); }

unary_expression
   <- p:postfix_expression _             { $$ = p; }
    / u:unary_operator c:cast_expression { $$ = AST_C(u, c); }

unary_operator
   <- '&' !('&')  { $$ = AST_N(t_address_of, "&"); }
    / '*'         { $$ = AST_N(t_dereference, "*"); }
    / '~'         { $$ = AST_N(t_bitwise_not, "~"); }
    / '!' !('=')  { $$ = AST_N(t_logical_not, "!"); }

cast_expression
   <- u:unary_expression _                        { $$ = u; }
    / '(' _ t:type_name _ ')' _ c:cast_expression { $$ = AST_C(AST_N(t_cast, ")"), AST_S(t, c)); }

multiplicative_expression
   <- c:cast_expression _                                   { $$ = c; }
	/ m:multiplicative_expression _ '*' _ c:cast_expression { $$ = AST_C(AST_N(t_multiply, "*"), AST_S(m, c)); }
	/ m:multiplicative_expression _ '/' _ c:cast_expression { $$ = AST_C(AST_N(t_divide, "/"), AST_S(m, c)); }
	/ m:multiplicative_expression _ '%' _ c:cast_expression { $$ = AST_C(AST_N(t_modulo, "%"), AST_S(m, c)); }

additive_expression
   <- m:multiplicative_expression _                             { $$ = m; }
	/ a:additive_expression _ '+' _ m:multiplicative_expression { $$ = AST_C(AST_N(t_add, "+"), AST_S(a, m)); }
	/ a:additive_expression _ '-' _ m:multiplicative_expression { $$ = AST_C(AST_N(t_subtract, "-"), AST_S(a, m)); }

shift_expression
   <- a:additive_expression _                                 { $$ = a; }
	/ s:shift_expression _ l:left_op _ a:additive_expression  { $$ = AST_C(l, AST_S(s, a)); }
	/ s:shift_expression _ r:right_op _ a:additive_expression { $$ = AST_C(r, AST_S(s, a)); }

relational_expression
   <- s:shift_expression _                                     { $$ = s; }
	/ r:relational_expression _ '<' _ s:shift_expression       { $$ = AST_C(AST_N(t_greater_than, ">"), AST_S(r, s)); }
	/ r:relational_expression _ '>' _ s:shift_expression       { $$ = AST_C(AST_N(t_less_than, ">"), AST_S(r, s)); }
	/ r:relational_expression _ lte:le_op _ s:shift_expression { $$ = AST_C(lte, AST_S(r, s)); }
	/ r:relational_expression _ gte:ge_op _ s:shift_expression { $$ = AST_C(gte, AST_S(r, s)); }

equality_expression
   <- r:relational_expression _                                  { $$ = r; }
	/ e:equality_expression _ eq:eq_op _ r:relational_expression { $$ = AST_C(eq, AST_S(e, r)); }
	/ e:equality_expression _ ne:ne_op _ r:relational_expression { $$ = AST_C(ne, AST_S(e, r)); }

and_expression
   <- e:equality_expression _                        { $$ = e; }
	/ a:and_expression _ '&' _ e:equality_expression { $$ = AST_C(AST_N(t_bitwise_and, "&"), AST_S(a, e)); }

exclusive_or_expression
   <- a:and_expression _                                 { $$ = a; }
	/ e:exclusive_or_expression _ '^' _ a:and_expression { $$ = AST_C(AST_N(t_bitwise_xor, "^"), AST_S(e, a)); }

inclusive_or_expression
   <- e:exclusive_or_expression _                                 { $$ = e; }
	/ i:inclusive_or_expression _ '|' _ e:exclusive_or_expression { $$ = AST_C(AST_N(t_bitwise_or, "|"), AST_S(i, e)); }

logical_and_expression
   <- i:inclusive_or_expression _                                     { $$ = i; }
	/ l:logical_and_expression _ a:and_op _ i:inclusive_or_expression { $$ = AST_C(a, AST_S(l, i)); }

logical_or_expression
   <- la:logical_and_expression _                                     { $$ = la; }
	/ lo:logical_or_expression _ oo:or_op _ la:logical_and_expression { $$ = AST_C(oo, AST_S(lo, la)); }

conditional_expression
   <- logical_or_expression

assignment_expression
   <- c:conditional_expression _                                             { $$ = c; }
    / u:unary_expression _ ao:assignment_operator _ ae:assignment_expression { $$ = AST_C(ao, AST_S(u, ae)); }

assignment_operator
   <- '='   { $$ = AST_N(t_assign, $0); }
    / '+='  { $$ = AST_N(t_plus_equals, $0); }
    / '-='  { $$ = AST_N(t_minus_equals, $0); }
    / '*='  { $$ = AST_N(t_times_equals, $0); }
    / '/='  { $$ = AST_N(t_divide_equals, $0); }
    / '%='  { $$ = AST_N(t_modulo_equals, $0); }
    / '&='  { $$ = AST_N(t_bitwise_and_equals, $0); }
    / '|='  { $$ = AST_N(t_bitwise_or_equals, $0); }
    / '^='  { $$ = AST_N(t_bitwise_xor_equals, $0); }
    / '<<=' { $$ = AST_N(t_lshift_equals, $0); }
    / '>>=' { $$ = AST_N(t_rshift_equals, $0); }

expression
   <- a:assignment_expression _ { $$ = a; }

statement
   <- '{' _ '}'                                                                            { $$ = NULL; }
    / '{' _ sl:statement_list _ '}'                                                        { $$ = AST_C(AST_N(t_compound_statement, "{"), sl); }
    / ';'                                                                                  { $$ = NULL; }
    / v:variable_declaration ';'                                                           { $$ = v; }
    / e:expression _ ';'                                                                   { $$ = e; }
    / if:if _ '(' _ e:expression _ ')' _ s:statement                                    { $$ = AST_C(if, AST_S(e, s)); }
    / if:if _ '(' _ e:expression _ ')' _ ifs:statement _ else:else _ elses:statement { $$ = AST_C(if, AST_S(e, AST_S(ifs, elses))); }
    / w:while _ '(' _ e:expression _ ')' _ s:statement                                  { $$ = AST_C(w, AST_S(e, s)); }

statement_list
   <- s:statement                     { $$ = s; }
    / sl:statement_list _ s:statement { $$ = AST_S(sl, s); }

type_name
   <- n:non_pointer_typename _ { $$ = n; }
    / t:non_pointer_typename _ '*'      { $$ = AST_S(t, AST_N(t_dereference, "*")); }
    / t:type_name _ '*'      { $$ = AST_S(t, AST_N(t_dereference, "*")); }

non_pointer_typename
   <- t:u8                     { $$ = t; }
    / t:u16                    { $$ = t; }
    / t:u32                    { $$ = t; }
    / c:class _ i:identifier { $$ = AST_C(c, i); }

identifier
   <- !keyword LETTER(LETTER/DIGIT)* { $$ = AST_N(t_identifier, $0); }

# integer
#		<- '0'[xX]X+
#		 {
#				 $$ = match(t_constant)
#		 }
#		 / !'0' D+
#		 {
#				 $$ = match(t_constant)
#		 }

keyword
   <- kw_fun
    / kw_void
    / kw_u8
    / kw_u16
    / kw_u32
    / kw_if
    / kw_else
    / kw_semicolon

kw_fun		  <- 'fun'   !(LETTER/DIGIT)
kw_class      <- 'class' !(LETTER/DIGIT)
kw_void		  <- 'void'  !(LETTER/DIGIT)
kw_u8		  <- 'u8'	 !(LETTER/DIGIT)
kw_u16		  <- 'u16'   !(LETTER/DIGIT)
kw_u32		  <- 'u32'   !(LETTER/DIGIT)
kw_if		  <- 'if'	 !(LETTER/DIGIT)
kw_else		  <- 'else'  !(LETTER/DIGIT)
kw_while      <- 'while' !(LETTER/DIGIT)
kw_semicolon  <- ';'
kw_arrow      <- '->'
kw_left_op       <- '<<'
kw_right_op      <- '>>'
kw_le_op         <- '<='
kw_ge_op         <- '>='
kw_eq_op         <- '=='
kw_ne_op         <- '!='
kw_and_op        <- '&&'
kw_or_op         <- '||'

fun   <- kw_fun      { $$ = AST_N(t_fun, ""); }
class <- kw_class  { $$ = AST_N(t_class, ""); }
# void  <- kw_void    { $$ = AST_N(t_void, ""); }
u8    <- kw_u8        { $$ = AST_N(t_u8, ""); }
u16   <- kw_u16      { $$ = AST_N(t_u16, ""); }
u32   <- kw_u32      { $$ = AST_N(t_u32, ""); }
if    <- kw_if        { $$ = AST_N(t_if, ""); }
else  <- kw_else    { $$ = AST_N(t_else, ""); }
while <- kw_while  { $$ = AST_N(t_while, ""); }

arrow         <- kw_arrow        { $$ = AST_N(t_arrow, ""); }
left_op       <- kw_left_op   { $$ = AST_N(t_lshift, ""); }
right_op      <- kw_right_op  { $$ = AST_N(t_rshift, ""); }
le_op         <- kw_le_op     { $$ = AST_N(t_less_than_equals, ""); }
ge_op         <- kw_ge_op     { $$ = AST_N(t_greater_than_equals, ""); }
eq_op         <- kw_eq_op     { $$ = AST_N(t_equals, ""); }
ne_op         <- kw_ne_op     { $$ = AST_N(t_not_equals, ""); }
and_op        <- kw_and_op    { $$ = AST_N(t_logical_and, ""); }
or_op         <- kw_or_op     { $$ = AST_N(t_logical_or, ""); }


# O <- [0-7]
DIGIT <- [0-9]
# X <- [0-9a-fA-F]
LETTER <- [a-zA-Z_]

constant
   <- !(LETTER) DIGIT+ { $$ = AST_N(t_constant, $0); }

string_literal
   <- '"' 'abcd' '"'

_ <- ( space / comment )*
comment
   <- '/*' ( !'*/' . )* '*/'
    ## error handling ##
    / '/*' ( !'*/' . )*
    {
        ErrorAndExit(ERROR_CODE, "Unclosed comment block!");
    }
space <- blank / eol
blank <- [ \t\v\f]
eol <- '\r\n' / '\n' / '\r'
eof <- !.