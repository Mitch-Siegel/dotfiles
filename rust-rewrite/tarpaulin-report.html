<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc","block_depths.rs"],"content":"use std::{\n    collections::{BTreeMap, VecDeque},\n    usize,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\nstruct BlockDepthMetadata\u003c'a\u003e {\n    depths: BTreeMap\u003cusize, usize\u003e,\n    control_flow: \u0026'a ir::ControlFlow,\n    unknown_predecessors_worklist: VecDeque\u003cusize\u003e,\n}\nimpl\u003c'a\u003e BlockDepthMetadata\u003c'a\u003e {\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            depths: BTreeMap::new(),\n            control_flow,\n            unknown_predecessors_worklist: VecDeque::new(),\n        }\n    }\n\n    fn set_block_depth(\u0026mut self, block_label: usize, depth: usize) {\n        self.depths.insert(block_label, depth);\n    }\n\n    fn max_of_predecessors(\u0026mut self, block_label: usize) -\u003e usize {\n        let mut max = usize::MIN;\n\n        for predecessor_label in \u0026self.control_flow.block_for_label(\u0026block_label).predecessors {\n            let predecessor_depth = match self.depths.get(predecessor_label) {\n                Some(depth) =\u003e *depth,\n                None =\u003e {\n                    self.unknown_predecessors_worklist\n                        .push_back(*predecessor_label);\n                    usize::MIN\n                }\n            };\n\n            max = usize::max(predecessor_depth, max);\n        }\n\n        max\n    }\n\n    fn visit(\u0026mut self, block_label: usize) {\n        let max_predecessor_depth = self.max_of_predecessors(block_label);\n        self.set_block_depth(block_label, max_predecessor_depth + 1);\n    }\n}\n\npub fn find_block_depths(control_flow: \u0026ir::ControlFlow) -\u003e BTreeMap\u003cusize, usize\u003e {\n    let mut metadata = BlockDepthMetadata::new(control_flow);\n\n    for (label, _) in control_flow.blocks_postorder() {\n        metadata.visit(label);\n    }\n\n    while let Some(unvisited) = metadata.unknown_predecessors_worklist.pop_front() {\n        metadata.visit(unvisited);\n    }\n\n    metadata.depths\n}\n","traces":[{"line":15,"address":[248766,248608],"length":1,"stats":{"Line":0}},{"line":17,"address":[248636],"length":1,"stats":{"Line":0}},{"line":19,"address":[248646],"length":1,"stats":{"Line":0}},{"line":23,"address":[248800],"length":1,"stats":{"Line":0}},{"line":24,"address":[248818],"length":1,"stats":{"Line":0}},{"line":27,"address":[248832],"length":1,"stats":{"Line":0}},{"line":28,"address":[248857],"length":1,"stats":{"Line":0}},{"line":30,"address":[248866,249145],"length":1,"stats":{"Line":0}},{"line":31,"address":[248992],"length":1,"stats":{"Line":0}},{"line":32,"address":[249055],"length":1,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[249097],"length":1,"stats":{"Line":0}},{"line":35,"address":[249094],"length":1,"stats":{"Line":0}},{"line":36,"address":[249109],"length":1,"stats":{"Line":0}},{"line":40,"address":[249121],"length":1,"stats":{"Line":0}},{"line":43,"address":[249042],"length":1,"stats":{"Line":0}},{"line":46,"address":[249152],"length":1,"stats":{"Line":0}},{"line":47,"address":[249176],"length":1,"stats":{"Line":0}},{"line":48,"address":[249186,249225],"length":1,"stats":{"Line":0}},{"line":52,"address":[249248,249730],"length":1,"stats":{"Line":0}},{"line":53,"address":[249283],"length":1,"stats":{"Line":0}},{"line":55,"address":[249358,249301,249485],"length":1,"stats":{"Line":0}},{"line":56,"address":[249553,249725],"length":1,"stats":{"Line":0}},{"line":59,"address":[249583],"length":1,"stats":{"Line":0}},{"line":60,"address":[249720,249659],"length":1,"stats":{"Line":0}},{"line":63,"address":[249671],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc","lifetime.rs"],"content":"use std::{collections::HashMap, fmt};\n\nuse crate::midend;\n\n#[derive(Clone, PartialOrd, Ord, PartialEq, Eq, Debug)]\npub struct Lifetime {\n    pub name: midend::ir::OperandName,\n    pub start: usize,\n    pub end: usize,\n    pub n_reads: usize,\n    pub n_writes: usize,\n}\n\nimpl Lifetime {\n    pub fn new(name: midend::ir::OperandName) -\u003e Self {\n        Lifetime {\n            name: name,\n            start: usize::MAX,\n            end: usize::MIN,\n            n_reads: 0,\n            n_writes: 0,\n        }\n    }\n\n    fn update_range(\u0026mut self, potential_range_limit: \u0026usize) {\n        if *potential_range_limit \u003c self.start {\n            self.start = *potential_range_limit;\n        }\n        if self.end \u003c *potential_range_limit {\n            self.end = *potential_range_limit;\n        }\n    }\n\n    pub fn record_read(\u0026mut self, at_index: \u0026usize) {\n        self.n_reads += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn record_write(\u0026mut self, at_index: \u0026usize) {\n        self.n_writes += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn live_at(\u0026self, at_index: \u0026usize) -\u003e bool {\n        (self.start \u003c= *at_index) \u0026\u0026 (self.end \u003e= *at_index)\n    }\n}\n\nimpl std::fmt::Display for Lifetime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{}: {}-{}]\", self.name, self.start, self.end)\n    }\n}\n\npub struct LifetimeSet {\n    pub lifetimes: HashMap\u003cmidend::ir::OperandName, Lifetime\u003e,\n}\n\nimpl LifetimeSet {\n    fn new() -\u003e Self {\n        LifetimeSet {\n            lifetimes: HashMap::\u003cmidend::ir::OperandName, Lifetime\u003e::new(),\n        }\n    }\n\n    pub fn from_block(block: \u0026midend::ir::BasicBlock) -\u003e Self {\n        let mut lifetimes = Self::new();\n\n        for (index, line) in block.statements.iter().enumerate() {\n            for read_operand in line.read_operand_names() {\n                lifetimes.record_read_at_index(read_operand, \u0026index);\n            }\n\n            for write_operand in line.write_operand_names() {\n                lifetimes.record_write_at_index(write_operand, \u0026index);\n            }\n        }\n\n        lifetimes\n    }\n\n    fn lookup_or_create_lifetime_by_name(\n        \u0026mut self,\n        name: \u0026midend::ir::OperandName,\n    ) -\u003e \u0026mut Lifetime {\n        if !self.lifetimes.contains_key(name) {\n            self.lifetimes\n                .insert(name.clone(), Lifetime::new(name.clone()));\n        }\n\n        self.lifetimes.get_mut(name).unwrap()\n    }\n\n    pub fn record_read_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_read(index);\n    }\n\n    pub fn record_write_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_write(index);\n    }\n\n    pub fn print_numerical(\u0026self) {\n        for lifetime in self.lifetimes.values() {\n            println!(\n                \"{:\u003e20}: [{}-{}]\",\n                lifetime.name, lifetime.start, lifetime.end\n            );\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use crate::midend;\n\n    use super::Lifetime;\n\n    #[test]\n    fn test_lifetime_range() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        dummy_lifetime.record_read(\u00261);\n\n        assert!(dummy_lifetime.start == 1);\n        assert!(dummy_lifetime.start == dummy_lifetime.end);\n\n        dummy_lifetime.record_write(\u00260);\n\n        assert!(dummy_lifetime.start == 0);\n        assert!(dummy_lifetime.end == 1);\n    }\n\n    #[test]\n    fn test_lifetime_format() {\n        let mut dummy_lifetime =\n            Lifetime::new(midend::ir::OperandName::new_basic(\"my_variable\".into()));\n\n        let start_point = 2;\n        let end_point = 4;\n\n        dummy_lifetime.record_write(\u0026start_point);\n        dummy_lifetime.record_write(\u0026end_point);\n\n        assert_eq!(\n            format!(\"{}\", dummy_lifetime),\n            format!(\"[my_variable: {}-{}]\", start_point, end_point)\n        );\n    }\n\n    #[test]\n    fn test_lifetime_live_at() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        assert!(!dummy_lifetime.live_at(\u00260));\n        dummy_lifetime.record_write(\u00260);\n        dummy_lifetime.record_write(\u00265);\n\n        for index in 0..5 {\n            assert!(dummy_lifetime.live_at(\u0026index));\n        }\n    }\n}\n","traces":[{"line":15,"address":[275200],"length":1,"stats":{"Line":3}},{"line":25,"address":[275280],"length":1,"stats":{"Line":3}},{"line":26,"address":[275347,275300],"length":1,"stats":{"Line":6}},{"line":27,"address":[275340],"length":1,"stats":{"Line":3}},{"line":29,"address":[275367,275319],"length":1,"stats":{"Line":6}},{"line":30,"address":[275360],"length":1,"stats":{"Line":3}},{"line":34,"address":[275376],"length":1,"stats":{"Line":1}},{"line":35,"address":[275445,275399],"length":1,"stats":{"Line":1}},{"line":36,"address":[275435],"length":1,"stats":{"Line":1}},{"line":39,"address":[275472],"length":1,"stats":{"Line":1}},{"line":40,"address":[275495,275541],"length":1,"stats":{"Line":1}},{"line":41,"address":[275531],"length":1,"stats":{"Line":2}},{"line":44,"address":[275568],"length":1,"stats":{"Line":1}},{"line":45,"address":[275588],"length":1,"stats":{"Line":1}},{"line":50,"address":[275648],"length":1,"stats":{"Line":1}},{"line":51,"address":[275687],"length":1,"stats":{"Line":1}},{"line":60,"address":[275872],"length":1,"stats":{"Line":0}},{"line":62,"address":[275886],"length":1,"stats":{"Line":0}},{"line":66,"address":[276840,276854,275936],"length":1,"stats":{"Line":0}},{"line":67,"address":[275971],"length":1,"stats":{"Line":0}},{"line":69,"address":[276045,275981],"length":1,"stats":{"Line":0}},{"line":70,"address":[276341,276477,276285],"length":1,"stats":{"Line":0}},{"line":71,"address":[276545,276849],"length":1,"stats":{"Line":0}},{"line":74,"address":[276583,276742],"length":1,"stats":{"Line":0}},{"line":75,"address":[276810,276835],"length":1,"stats":{"Line":0}},{"line":79,"address":[276297],"length":1,"stats":{"Line":0}},{"line":82,"address":[277151,277126,276880],"length":1,"stats":{"Line":0}},{"line":86,"address":[276920],"length":1,"stats":{"Line":0}},{"line":87,"address":[277070],"length":1,"stats":{"Line":0}},{"line":88,"address":[277009,277103,277144,276934],"length":1,"stats":{"Line":0}},{"line":91,"address":[276981,276912],"length":1,"stats":{"Line":0}},{"line":94,"address":[277168],"length":1,"stats":{"Line":0}},{"line":95,"address":[277192],"length":1,"stats":{"Line":0}},{"line":99,"address":[277216],"length":1,"stats":{"Line":0}},{"line":100,"address":[277240],"length":1,"stats":{"Line":0}},{"line":104,"address":[277264],"length":1,"stats":{"Line":0}},{"line":105,"address":[277282],"length":1,"stats":{"Line":0}},{"line":106,"address":[277401],"length":1,"stats":{"Line":0}}],"covered":16,"coverable":38},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc","program_point.rs"],"content":"use core::fmt;\n\nuse serde::Serialize;\n\n#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Serialize, Hash)]\npub struct ProgramPoint {\n    pub depth: usize, // depth in the DFS traversal of control flow\n    pub index: usize, // index within a basic block\n}\n\nimpl ProgramPoint {\n    pub fn default() -\u003e Self {\n        Self::new(0, 0)\n    }\n\n    pub fn new(depth: usize, index: usize) -\u003e Self {\n        ProgramPoint { depth, index }\n    }\n}\n\nimpl std::fmt::Display for ProgramPoint {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:\u003e2x}:{:\u003c2x}\", self.depth, self.index)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::backend::regalloc::program_point::ProgramPoint;\n\n    #[test]\n    fn test_default() {\n        let default_point = ProgramPoint::default();\n\n        assert_eq!(default_point.depth, 0);\n        assert_eq!(default_point.index, 0);\n    }\n\n    #[test]\n    fn test_partial_ord_eq() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.partial_cmp(\u0026point_2), Some(Ordering::Greater));\n        assert_eq!(point_1.partial_cmp(\u0026point_3), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_ord() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.cmp(\u0026point_2), Ordering::Greater);\n        assert_eq!(point_1.cmp(\u0026point_3), Ordering::Equal);\n    }\n}\n","traces":[{"line":12,"address":[864720],"length":1,"stats":{"Line":1}},{"line":13,"address":[864725],"length":1,"stats":{"Line":1}},{"line":16,"address":[864736],"length":1,"stats":{"Line":2}},{"line":22,"address":[864768],"length":1,"stats":{"Line":0}},{"line":23,"address":[864807],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc.rs"],"content":"use std::collections::{BTreeMap, BTreeSet};\n\nuse lifetime::LifetimeSet;\n\nuse crate::midend::{self, ir::ControlFlow, symtab};\n\nmod block_depths;\nmod lifetime;\nmod program_point;\n\nfn record_interference_graph(\n    graph: \u0026mut BTreeMap\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e,\n    lifetime_a: \u0026midend::ir::OperandName,\n    lifetime_b: \u0026midend::ir::OperandName,\n) {\n    graph\n        .entry(lifetime_a.clone())\n        .or_default()\n        .insert(lifetime_b.clone());\n}\n\npub fn allocate_registers(_scope: \u0026symtab::Scope, control_flow: \u0026ControlFlow) {\n    println!(\"Allocate registers for scope\");\n\n    // let depths = find_block_depths(control_flow);\n\n    let mut graph = BTreeMap::\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e::new();\n\n    for (_, block) in \u0026control_flow.blocks {\n        let block_lifetimes = LifetimeSet::from_block(block);\n\n        for index in 0..block.statements.len() {\n            let mut first_iter = block_lifetimes.lifetimes.iter();\n\n            while let Some((first_name, first_lt)) = first_iter.next() {\n                if first_lt.live_at(\u0026index) {\n                    let mut second_iter = first_iter.clone();\n                    while let Some((second_name, second_lt)) = second_iter.next() {\n                        if second_lt.live_at(\u0026index) {\n                            record_interference_graph(\u0026mut graph, first_name, second_name);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[548608],"length":1,"stats":{"Line":0}},{"line":16,"address":[548662,548715],"length":1,"stats":{"Line":0}},{"line":17,"address":[548648],"length":1,"stats":{"Line":0}},{"line":19,"address":[548697],"length":1,"stats":{"Line":0}},{"line":22,"address":[548736,549649],"length":1,"stats":{"Line":0}},{"line":23,"address":[548767],"length":1,"stats":{"Line":0}},{"line":27,"address":[548820],"length":1,"stats":{"Line":0}},{"line":29,"address":[548888,548841],"length":1,"stats":{"Line":0}},{"line":30,"address":[549025],"length":1,"stats":{"Line":0}},{"line":32,"address":[549119,549058],"length":1,"stats":{"Line":0}},{"line":33,"address":[549259,549284],"length":1,"stats":{"Line":0}},{"line":35,"address":[549294],"length":1,"stats":{"Line":0}},{"line":36,"address":[549417],"length":1,"stats":{"Line":0}},{"line":37,"address":[549457],"length":1,"stats":{"Line":0}},{"line":38,"address":[549474],"length":1,"stats":{"Line":0}},{"line":39,"address":[549596],"length":1,"stats":{"Line":0}},{"line":40,"address":[549637],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend.rs"],"content":"mod regalloc;\n\nuse crate::midend;\n\npub fn generate_code_for_function(function: \u0026mut midend::symtab::Function) {\n    println!(\"generate code for {}\", function.prototype);\n    regalloc::allocate_registers(\u0026function.scope, \u0026function.control_flow);\n}\n\npub fn generate_code(mut symbol_table: midend::symtab::SymbolTable) {\n    for (_, member) in \u0026mut symbol_table.functions {\n        match member {\n            midend::symtab::FunctionOrPrototype::Function(f) =\u003e generate_code_for_function(f),\n            midend::symtab::FunctionOrPrototype::Prototype(p) =\u003e println!(\"{}\", p),\n        }\n    }\n}\n","traces":[{"line":5,"address":[763808],"length":1,"stats":{"Line":0}},{"line":6,"address":[763825],"length":1,"stats":{"Line":0}},{"line":7,"address":[763894],"length":1,"stats":{"Line":0}},{"line":10,"address":[764296,763920],"length":1,"stats":{"Line":0}},{"line":11,"address":[763991,763935],"length":1,"stats":{"Line":0}},{"line":12,"address":[764105],"length":1,"stats":{"Line":0}},{"line":13,"address":[764202],"length":1,"stats":{"Line":0}},{"line":14,"address":[764162,764222],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","ast.rs"],"content":"use crate::{frontend::sourceloc::SourceLoc, midend};\nuse std::fmt::Display;\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum TranslationUnit {\n    FunctionDeclaration(FunctionDeclarationTree),\n    FunctionDefinition(FunctionDefinitionTree),\n    StructDefinition(StructDefinitionTree),\n    Implementation(ImplementationTree),\n}\n\nimpl Display for TranslationUnit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::FunctionDeclaration(function_declaration) =\u003e {\n                write!(f, \"Function Declaration: {}\", function_declaration)\n            }\n            Self::FunctionDefinition(function_definition) =\u003e {\n                write!(f, \"Function Definition: {}\", function_definition)\n            }\n            Self::StructDefinition(struct_definition) =\u003e {\n                write!(f, \"Struct Definition: {}\", struct_definition)\n            }\n            Self::Implementation(implementation) =\u003e {\n                write!(f, \"Implementation: {}\", implementation)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TranslationUnitTree {\n    pub loc: SourceLoc,\n    pub contents: TranslationUnit,\n}\nimpl Display for TranslationUnitTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Translation Unit: {}\", self.contents)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub arguments: Vec\u003cVariableDeclarationTree\u003e,\n    pub return_type: Option\u003cTypenameTree\u003e,\n}\nimpl Display for FunctionDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arg_string = String::from(\"\");\n        for argument in \u0026self.arguments {\n            arg_string.push_str(format!(\"{}\\n\", argument).as_str());\n        }\n\n        match \u0026self.return_type {\n            Some(typename_tree) =\u003e write!(\n                f,\n                \"Function Declaration: {}({})-\u003e{}\",\n                self.name, arg_string, typename_tree\n            ),\n            None =\u003e write!(f, \"Function Declaration: {}({})\", self.name, arg_string),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDefinitionTree {\n    pub prototype: FunctionDeclarationTree,\n    pub body: CompoundExpressionTree,\n}\nimpl Display for FunctionDefinitionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Function Definition: {}, {}\", self.prototype, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct StructDefinitionTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub fields: Vec\u003cVariableDeclarationTree\u003e,\n}\nimpl Display for StructDefinitionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut fields = String::new();\n        for field in \u0026self.fields {\n            fields += \u0026field.to_string();\n            fields += \" \";\n        }\n        write!(f, \"Struct Definition: {}: {}\", self.name, fields)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ImplementationTree {\n    pub loc: SourceLoc,\n    pub type_name: TypenameTree,\n    pub items: Vec\u003cFunctionDefinitionTree\u003e,\n}\nimpl Display for ImplementationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Impl {}\", self.type_name).and_then(|_| {\n            for item in \u0026self.items {\n                write!(f, \"{}\", item)?\n            }\n            Ok(())\n        })\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct CompoundExpressionTree {\n    pub loc: SourceLoc,\n    pub statements: Vec\u003cStatementTree\u003e,\n}\nimpl Display for CompoundExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut statement_string = String::from(\"\");\n        for statement in \u0026self.statements {\n            statement_string.push_str(format!(\"{}\\n\", statement).as_str());\n        }\n        write!(f, \"Compound Expression: {}\", statement_string)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct IfExpressionTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub true_block: CompoundExpressionTree,\n    pub false_block: Option\u003cCompoundExpressionTree\u003e,\n}\nimpl Display for IfExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match \u0026self.false_block {\n            Some(false_block) =\u003e write!(\n                f,\n                \"if {}\\n\\t{{{}}} else {{{}}}\",\n                self.condition, self.true_block, false_block\n            ),\n            None =\u003e write!(f, \"if {}\\n\\t{{{}}}\", self.condition, self.true_block),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct WhileExpressionTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub body: CompoundExpressionTree,\n}\nimpl Display for WhileExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"while ({}) {}\", self.condition, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\n\npub struct CallParamsTree {\n    pub loc: SourceLoc,\n    pub params: Vec\u003cExpressionTree\u003e,\n}\nimpl Display for CallParamsTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut params = String::new();\n        for p in \u0026self.params {\n            if params.len() \u003e 0 {\n                params += \u0026\", \";\n            }\n            params += \u0026format!(\"{}\", p);\n        }\n        write!(f, \"{}\", params)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct MethodCallExpressionTree {\n    pub loc: SourceLoc,\n    pub receiver: ExpressionTree,\n    pub called_method: String,\n    pub params: CallParamsTree,\n}\nimpl Display for MethodCallExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}.{}({})\",\n            self.receiver, self.called_method, self.params\n        )\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FieldExpressionTree {\n    pub loc: SourceLoc,\n    pub receiver: ExpressionTree,\n    pub field: String,\n}\nimpl Display for FieldExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}.{}\", self.receiver, self.field)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Statement {\n    VariableDeclaration(VariableDeclarationTree),\n    Expression(ExpressionTree),\n}\n\nimpl Display for Statement {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::VariableDeclaration(variable_declaration) =\u003e {\n                write!(f, \"{}\", variable_declaration)\n            }\n            Self::Expression(expression) =\u003e {\n                write!(f, \"{}\", expression)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct StatementTree {\n    pub loc: SourceLoc,\n    pub statement: Statement,\n}\nimpl Display for StatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.statement)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct VariableDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub typename: TypenameTree,\n}\nimpl Display for VariableDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}: {}\", self.name, self.typename)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct AssignmentTree {\n    pub loc: SourceLoc,\n    pub assignee: Box\u003cExpressionTree\u003e,\n    pub value: Box\u003cExpressionTree\u003e,\n}\nimpl Display for AssignmentTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} = {}\", self.assignee, self.value)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ArithmeticDualOperands {\n    pub e1: Box\u003cExpressionTree\u003e,\n    pub e2: Box\u003cExpressionTree\u003e,\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ArithmeticExpressionTree {\n    Add(ArithmeticDualOperands),\n    Subtract(ArithmeticDualOperands),\n    Multiply(ArithmeticDualOperands),\n    Divide(ArithmeticDualOperands),\n}\nimpl Display for ArithmeticExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e write!(f, \"({} + {})\", operands.e1, operands.e2),\n            Self::Subtract(operands) =\u003e write!(f, \"({} - {})\", operands.e1, operands.e2),\n            Self::Multiply(operands) =\u003e write!(f, \"({} * {})\", operands.e1, operands.e2),\n            Self::Divide(operands) =\u003e write!(f, \"({} / {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ComparisonExpressionTree {\n    LThan(ArithmeticDualOperands),\n    GThan(ArithmeticDualOperands),\n    LThanE(ArithmeticDualOperands),\n    GThanE(ArithmeticDualOperands),\n    Equals(ArithmeticDualOperands),\n    NotEquals(ArithmeticDualOperands),\n}\nimpl Display for ComparisonExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::LThan(operands) =\u003e write!(f, \"({} \u003c {})\", operands.e1, operands.e2),\n            Self::GThan(operands) =\u003e write!(f, \"({} \u003e {})\", operands.e1, operands.e2),\n            Self::LThanE(operands) =\u003e write!(f, \"({} \u003c= {})\", operands.e1, operands.e2),\n            Self::GThanE(operands) =\u003e write!(f, \"({} \u003e= {})\", operands.e1, operands.e2),\n            Self::Equals(operands) =\u003e write!(f, \"({} == {})\", operands.e1, operands.e2),\n            Self::NotEquals(operands) =\u003e write!(f, \"({} != {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Expression {\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Arithmetic(ArithmeticExpressionTree),\n    Comparison(ComparisonExpressionTree),\n    Assignment(AssignmentTree),\n    If(Box\u003cIfExpressionTree\u003e),\n    While(Box\u003cWhileExpressionTree\u003e),\n    FieldExpression(Box\u003cFieldExpressionTree\u003e),\n    MethodCall(Box\u003cMethodCallExpressionTree\u003e),\n}\nimpl Display for Expression {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Identifier(identifier) =\u003e write!(f, \"{}\", identifier),\n            Self::UnsignedDecimalConstant(constant) =\u003e write!(f, \"{}\", constant),\n            Self::Arithmetic(arithmetic_expression) =\u003e write!(f, \"{}\", arithmetic_expression),\n            Self::Comparison(comparison_expression) =\u003e write!(f, \"{}\", comparison_expression),\n            Self::Assignment(assignment_expression) =\u003e write!(f, \"{}\", assignment_expression),\n            Self::If(if_expression) =\u003e write!(f, \"{}\", if_expression),\n            Self::While(while_expression) =\u003e write!(f, \"{}\", while_expression),\n            Self::FieldExpression(field_expression) =\u003e write!(f, \"{}\", field_expression),\n            Self::MethodCall(method_call) =\u003e write!(f, \"{}\", method_call),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ExpressionTree {\n    pub loc: SourceLoc,\n    pub expression: Expression,\n}\nimpl Display for ExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.expression)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TypenameTree {\n    pub loc: SourceLoc,\n    pub type_: midend::types::Type,\n}\n\nimpl Display for TypenameTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.type_)\n    }\n}\n","traces":[{"line":13,"address":[708368],"length":1,"stats":{"Line":0}},{"line":14,"address":[708401],"length":1,"stats":{"Line":0}},{"line":15,"address":[708466],"length":1,"stats":{"Line":0}},{"line":16,"address":[708475],"length":1,"stats":{"Line":0}},{"line":18,"address":[708564],"length":1,"stats":{"Line":0}},{"line":19,"address":[708572],"length":1,"stats":{"Line":0}},{"line":21,"address":[708688],"length":1,"stats":{"Line":0}},{"line":22,"address":[708700],"length":1,"stats":{"Line":0}},{"line":24,"address":[708813],"length":1,"stats":{"Line":0}},{"line":25,"address":[708825],"length":1,"stats":{"Line":0}},{"line":37,"address":[708960],"length":1,"stats":{"Line":0}},{"line":38,"address":[708984],"length":1,"stats":{"Line":0}},{"line":50,"address":[709934,709072],"length":1,"stats":{"Line":0}},{"line":51,"address":[709119],"length":1,"stats":{"Line":0}},{"line":52,"address":[709129,709201],"length":1,"stats":{"Line":0}},{"line":53,"address":[709725,709304],"length":1,"stats":{"Line":0}},{"line":56,"address":[709319],"length":1,"stats":{"Line":0}},{"line":57,"address":[709578,709374],"length":1,"stats":{"Line":0}},{"line":62,"address":[709413],"length":1,"stats":{"Line":0}},{"line":73,"address":[709968],"length":1,"stats":{"Line":0}},{"line":74,"address":[710007],"length":1,"stats":{"Line":0}},{"line":85,"address":[710128,710626],"length":1,"stats":{"Line":0}},{"line":86,"address":[710166],"length":1,"stats":{"Line":0}},{"line":87,"address":[710176,710248],"length":1,"stats":{"Line":0}},{"line":88,"address":[710501,710331],"length":1,"stats":{"Line":0}},{"line":89,"address":[710597],"length":1,"stats":{"Line":0}},{"line":91,"address":[710354],"length":1,"stats":{"Line":0}},{"line":102,"address":[710656],"length":1,"stats":{"Line":0}},{"line":103,"address":[654496],"length":1,"stats":{"Line":0}},{"line":104,"address":[654513],"length":1,"stats":{"Line":0}},{"line":105,"address":[654728,654590],"length":1,"stats":{"Line":0}},{"line":107,"address":[654709],"length":1,"stats":{"Line":0}},{"line":118,"address":[710800,711348],"length":1,"stats":{"Line":0}},{"line":119,"address":[710847],"length":1,"stats":{"Line":0}},{"line":120,"address":[710925,710857],"length":1,"stats":{"Line":0}},{"line":121,"address":[711013,711139],"length":1,"stats":{"Line":0}},{"line":123,"address":[711033],"length":1,"stats":{"Line":0}},{"line":135,"address":[711376],"length":1,"stats":{"Line":0}},{"line":136,"address":[711408],"length":1,"stats":{"Line":0}},{"line":137,"address":[711466],"length":1,"stats":{"Line":0}},{"line":142,"address":[711656],"length":1,"stats":{"Line":0}},{"line":154,"address":[711824],"length":1,"stats":{"Line":0}},{"line":155,"address":[711863],"length":1,"stats":{"Line":0}},{"line":166,"address":[712577,711984],"length":1,"stats":{"Line":0}},{"line":167,"address":[712022],"length":1,"stats":{"Line":0}},{"line":168,"address":[712032,712100],"length":1,"stats":{"Line":0}},{"line":169,"address":[712316,712180],"length":1,"stats":{"Line":0}},{"line":170,"address":[712342],"length":1,"stats":{"Line":0}},{"line":172,"address":[712335,712370],"length":1,"stats":{"Line":0}},{"line":174,"address":[712205],"length":1,"stats":{"Line":0}},{"line":186,"address":[712608],"length":1,"stats":{"Line":0}},{"line":187,"address":[712647],"length":1,"stats":{"Line":0}},{"line":202,"address":[712832],"length":1,"stats":{"Line":0}},{"line":203,"address":[712871],"length":1,"stats":{"Line":0}},{"line":214,"address":[712992],"length":1,"stats":{"Line":0}},{"line":215,"address":[713024],"length":1,"stats":{"Line":0}},{"line":216,"address":[713172],"length":1,"stats":{"Line":0}},{"line":217,"address":[713177],"length":1,"stats":{"Line":0}},{"line":219,"address":[713060],"length":1,"stats":{"Line":0}},{"line":220,"address":[713069],"length":1,"stats":{"Line":0}},{"line":232,"address":[713280],"length":1,"stats":{"Line":0}},{"line":233,"address":[713304],"length":1,"stats":{"Line":0}},{"line":244,"address":[713392],"length":1,"stats":{"Line":0}},{"line":245,"address":[713431],"length":1,"stats":{"Line":0}},{"line":256,"address":[713552],"length":1,"stats":{"Line":0}},{"line":257,"address":[713591],"length":1,"stats":{"Line":0}},{"line":275,"address":[713712],"length":1,"stats":{"Line":0}},{"line":276,"address":[713745],"length":1,"stats":{"Line":0}},{"line":277,"address":[713781],"length":1,"stats":{"Line":0}},{"line":278,"address":[713948],"length":1,"stats":{"Line":0}},{"line":279,"address":[714127],"length":1,"stats":{"Line":0}},{"line":280,"address":[714306],"length":1,"stats":{"Line":0}},{"line":295,"address":[714496],"length":1,"stats":{"Line":0}},{"line":296,"address":[714529],"length":1,"stats":{"Line":0}},{"line":297,"address":[714565],"length":1,"stats":{"Line":0}},{"line":298,"address":[714738],"length":1,"stats":{"Line":0}},{"line":299,"address":[714917],"length":1,"stats":{"Line":0}},{"line":300,"address":[715096],"length":1,"stats":{"Line":0}},{"line":301,"address":[715275],"length":1,"stats":{"Line":0}},{"line":302,"address":[715454],"length":1,"stats":{"Line":0}},{"line":320,"address":[715648],"length":1,"stats":{"Line":0}},{"line":321,"address":[715680],"length":1,"stats":{"Line":0}},{"line":322,"address":[715715],"length":1,"stats":{"Line":0}},{"line":323,"address":[715812],"length":1,"stats":{"Line":0}},{"line":324,"address":[715933],"length":1,"stats":{"Line":0}},{"line":325,"address":[716060],"length":1,"stats":{"Line":0}},{"line":326,"address":[716187],"length":1,"stats":{"Line":0}},{"line":327,"address":[716314],"length":1,"stats":{"Line":0}},{"line":328,"address":[716441],"length":1,"stats":{"Line":0}},{"line":329,"address":[716568],"length":1,"stats":{"Line":0}},{"line":330,"address":[716692],"length":1,"stats":{"Line":0}},{"line":341,"address":[716832],"length":1,"stats":{"Line":0}},{"line":342,"address":[716856],"length":1,"stats":{"Line":0}},{"line":353,"address":[716944],"length":1,"stats":{"Line":0}},{"line":354,"address":[716968],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":95},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","char_source.rs"],"content":"use std::{\n    fs::File,\n    io::{BufRead, BufReader},\n};\n\npub trait ReadChar {\n    fn read_char(\u0026mut self) -\u003e Option\u003cchar\u003e;\n}\n\npub trait ReadLine {\n    fn read_line(\u0026mut self) -\u003e Option\u003cVec\u003cchar\u003e\u003e;\n}\n\n#[derive(Debug)]\npub struct CharReader\u003cT\u003e\nwhere\n    T: ReadLine,\n{\n    line: Option\u003cVec\u003cchar\u003e\u003e,\n    line_source: T,\n}\n\nimpl\u003cT\u003e CharReader\u003cT\u003e\nwhere\n    T: ReadLine,\n{\n    fn new(mut line_source: T) -\u003e Self {\n        Self {\n            line: line_source.read_line(),\n            line_source,\n        }\n    }\n\n    fn next_line(\u0026mut self) {\n        self.line = self.line_source.read_line();\n    }\n}\n\nimpl\u003cT\u003e ReadChar for CharReader\u003cT\u003e\nwhere\n    T: ReadLine,\n{\n    fn read_char(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        loop {\n            if let Some(line) = \u0026mut self.line {\n                if !line.is_empty() {\n                    return line.pop();\n                } else {\n                    self.next_line();\n                }\n            } else {\n                // First call or exhausted previous line\n                self.next_line();\n\n                if self.line.is_none() {\n                    return None;\n                }\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct FileLineReader {\n    lines: std::io::Lines\u003cBufReader\u003cFile\u003e\u003e,\n}\n\nimpl FileLineReader {\n    pub fn new(f: File) -\u003e Self {\n        let reader = BufReader::new(f);\n        FileLineReader {\n            lines: reader.lines(),\n        }\n    }\n}\n\nimpl ReadLine for FileLineReader {\n    fn read_line(\u0026mut self) -\u003e Option\u003cVec\u003cchar\u003e\u003e {\n        let line_option = match self.lines.next() {\n            Some(result) =\u003e match result {\n                Ok(line) =\u003e Some(line),\n                Err(e) =\u003e panic!(\"Couldn't read next line from file: {}\", e),\n            },\n            None =\u003e None,\n        };\n\n        match line_option {\n            Some(string) =\u003e Some(string.chars().rev().collect()),\n            None =\u003e None,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct StrLineReader\u003c'a\u003e {\n    lines: std::str::SplitInclusive\u003c'a, char\u003e,\n}\n\nimpl\u003c'a\u003e StrLineReader\u003c'a\u003e {\n    pub fn new(s: \u0026'a str) -\u003e Self {\n        Self {\n            lines: s.split_inclusive('\\n').to_owned(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e ReadLine for StrLineReader\u003c'a\u003e {\n    fn read_line(\u0026mut self) -\u003e Option\u003cVec\u003cchar\u003e\u003e {\n        let line_option = self.lines.next();\n        match line_option {\n            Some(string) =\u003e Some(string.chars().rev().collect()),\n            None =\u003e None,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum CharSource\u003c'a\u003e {\n    File(CharReader\u003cFileLineReader\u003e),\n    String(CharReader\u003cStrLineReader\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e CharSource\u003c'a\u003e {\n    pub fn from_file(f: File) -\u003e Self {\n        Self::File(CharReader::\u003cFileLineReader\u003e::new(FileLineReader::new(f)))\n    }\n\n    pub fn from_str(s: \u0026'a str) -\u003e Self {\n        Self::String(CharReader::\u003cStrLineReader\u003e::new(StrLineReader::new(s)))\n    }\n}\n\nimpl\u003c'a\u003e ReadChar for CharSource\u003c'a\u003e {\n    fn read_char(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        match self {\n            Self::File(f) =\u003e f.read_char(),\n            Self::String(s) =\u003e s.read_char(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e Iterator for CharSource\u003c'a\u003e {\n    type Item = char;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.read_char()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::frontend::lexer::CharSource;\n\n    #[test]\n    fn string() {\n        let char_source = CharSource::from_str(\n            \"the quick brown\nfox jumps\nover\nthe\nlazy\ndog\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"the quick brown\nfox jumps\nover\nthe\nlazy\ndog\"\n        );\n    }\n\n    #[test]\n    fn string_multiple_newline() {\n        let char_source = CharSource::from_str(\n            \"the quick brown\n\nfox jumps\nover\n\nthe\nlazy\ndog\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"the quick brown\n\nfox jumps\nover\n\nthe\nlazy\ndog\"\n        );\n    }\n\n    #[test]\n    fn string_newline_at_end() {\n        let char_source = CharSource::from_str(\n            \"text\n\n\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"text\n\n\"\n        );\n    }\n\n    #[test]\n    fn string_newline_in_middle_and_at_end() {\n        let char_source = CharSource::from_str(\n            \"some text\n\n\nmore text\n\n\neven more text\n\n\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"some text\n\n\nmore text\n\n\neven more text\n\n\"\n        );\n    }\n\n    #[test]\n    fn empty_string() {\n        let char_source = CharSource::from_str(\"\");\n\n        assert_eq!(char_source.into_iter().collect::\u003cString\u003e(), \"\");\n    }\n\n    #[test]\n    fn only_newline() {\n        let char_source = CharSource::from_str(\"\\n\");\n\n        assert_eq!(char_source.into_iter().collect::\u003cString\u003e(), \"\\n\");\n    }\n}\n","traces":[{"line":27,"address":[266785,267035,266752,266896],"length":1,"stats":{"Line":16}},{"line":29,"address":[266778,266920],"length":1,"stats":{"Line":21}},{"line":34,"address":[267246,267056,267184,267118],"length":1,"stats":{"Line":2}},{"line":35,"address":[267148,267200,267276,267072],"length":1,"stats":{"Line":9}},{"line":43,"address":[267472,267312],"length":1,"stats":{"Line":21}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[267491,267331],"length":1,"stats":{"Line":22}},{"line":46,"address":[267373,267533],"length":1,"stats":{"Line":21}},{"line":47,"address":[267575,267415],"length":1,"stats":{"Line":21}},{"line":49,"address":[267431,267591],"length":1,"stats":{"Line":5}},{"line":53,"address":[267549,267389],"length":1,"stats":{"Line":2}},{"line":55,"address":[267559,267399],"length":1,"stats":{"Line":7}},{"line":56,"address":[267447,267607],"length":1,"stats":{"Line":7}},{"line":69,"address":[298896],"length":1,"stats":{"Line":0}},{"line":70,"address":[298913],"length":1,"stats":{"Line":0}},{"line":72,"address":[298923],"length":1,"stats":{"Line":0}},{"line":78,"address":[298976,299676,299657],"length":1,"stats":{"Line":0}},{"line":79,"address":[299001],"length":1,"stats":{"Line":0}},{"line":80,"address":[299053],"length":1,"stats":{"Line":0}},{"line":81,"address":[299233],"length":1,"stats":{"Line":0}},{"line":82,"address":[299191,299713],"length":1,"stats":{"Line":0}},{"line":84,"address":[299125],"length":1,"stats":{"Line":0}},{"line":87,"address":[299148],"length":1,"stats":{"Line":0}},{"line":88,"address":[299330,299428],"length":1,"stats":{"Line":0}},{"line":89,"address":[299394],"length":1,"stats":{"Line":0}},{"line":100,"address":[299824],"length":1,"stats":{"Line":14}},{"line":102,"address":[299857],"length":1,"stats":{"Line":16}},{"line":108,"address":[299920],"length":1,"stats":{"Line":21}},{"line":109,"address":[299950],"length":1,"stats":{"Line":21}},{"line":110,"address":[299965],"length":1,"stats":{"Line":21}},{"line":111,"address":[299993],"length":1,"stats":{"Line":19}},{"line":112,"address":[300080],"length":1,"stats":{"Line":2}},{"line":124,"address":[300112],"length":1,"stats":{"Line":0}},{"line":125,"address":[300136],"length":1,"stats":{"Line":0}},{"line":128,"address":[300224],"length":1,"stats":{"Line":6}},{"line":129,"address":[300256],"length":1,"stats":{"Line":6}},{"line":134,"address":[300320],"length":1,"stats":{"Line":6}},{"line":135,"address":[300333],"length":1,"stats":{"Line":21}},{"line":136,"address":[300389],"length":1,"stats":{"Line":0}},{"line":137,"address":[300369],"length":1,"stats":{"Line":21}},{"line":145,"address":[300416],"length":1,"stats":{"Line":6}},{"line":146,"address":[300421],"length":1,"stats":{"Line":6}}],"covered":26,"coverable":42},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","errors.rs"],"content":"use crate::frontend::sourceloc::SourceLoc;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum LexError {\n    InvalidChar(InvalidCharError),\n    UnexpectedEof(UnexpectedEofError),\n}\n\nimpl std::fmt::Display for LexError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::InvalidChar(invalid_char) =\u003e {\n                write!(f, \"Invalid char {} at {}\", invalid_char.c, invalid_char.pos)\n            }\n            Self::UnexpectedEof(unexpected_eof) =\u003e {\n                write!(f, \"Unexpected EOF at {}\", unexpected_eof.pos)\n            }\n        }\n    }\n}\n\nimpl LexError {\n    pub fn invalid_char(c: char, pos: SourceLoc) -\u003e Self {\n        Self::InvalidChar(InvalidCharError { c, pos })\n    }\n\n    pub fn unexpected_eof(pos: SourceLoc) -\u003e Self {\n        Self::UnexpectedEof(UnexpectedEofError { pos })\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct InvalidCharError {\n    c: char,\n    pos: SourceLoc,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct UnexpectedEofError {\n    pos: SourceLoc,\n}\n","traces":[{"line":10,"address":[872112],"length":1,"stats":{"Line":0}},{"line":11,"address":[872144],"length":1,"stats":{"Line":0}},{"line":12,"address":[872289],"length":1,"stats":{"Line":0}},{"line":13,"address":[872297],"length":1,"stats":{"Line":0}},{"line":15,"address":[872174],"length":1,"stats":{"Line":0}},{"line":16,"address":[872182],"length":1,"stats":{"Line":0}},{"line":23,"address":[872432],"length":1,"stats":{"Line":0}},{"line":24,"address":[872449],"length":1,"stats":{"Line":0}},{"line":27,"address":[872496],"length":1,"stats":{"Line":0}},{"line":28,"address":[872509],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","integration_tests.rs"],"content":"use super::token::*;\n\n#[cfg(test)]\nfn assert_single_tokenization(input_str: \u0026str, expected_token: Token) {\n    use crate::frontend::lexer::*;\n\n    println!(\n        \"Assert single tokenization against {} == {}\",\n        input_str, expected_token\n    );\n    let result = Lexer::from_string(input_str).lex_all().expect(\"\");\n    assert_eq!(\n        result,\n        vec! {(expected_token, SourceLoc::new(1, 1)), (Token::Eof, SourceLoc::new(1, 1 + input_str.len()))}\n    );\n}\n\n#[test]\nfn tokenize_l_curly() {\n    assert_single_tokenization(\"{\", Token::LCurly);\n}\n\n#[test]\nfn tokenize_r_curly() {\n    assert_single_tokenization(\"}\", Token::RCurly);\n}\n\n#[test]\nfn tokenize_identifier() {\n    assert_single_tokenization(\"abc\", Token::Identifier(String::from(\"abc\")));\n    assert_single_tokenization(\"abc123\", Token::Identifier(String::from(\"abc123\")));\n    assert_single_tokenization(\"abc123def\", Token::Identifier(String::from(\"abc123def\")));\n    assert_single_tokenization(\n        \"unsignedOrSomething_123\",\n        Token::Identifier(String::from(\"unsignedOrSomething_123\")),\n    );\n    assert_single_tokenization(\n        \"u16_named_fred\",\n        Token::Identifier(String::from(\"u16_named_fred\")),\n    );\n}\n\n#[test]\nfn tokenize_unsigned_decimal_constant() {\n    assert_single_tokenization(\"123\", Token::UnsignedDecimalConstant(123));\n    assert_single_tokenization(\n        \u0026usize::MAX.to_string(),\n        Token::UnsignedDecimalConstant(usize::MAX),\n    );\n    assert_single_tokenization(\n        \u0026usize::MIN.to_string(),\n        Token::UnsignedDecimalConstant(usize::MIN),\n    );\n}\n","traces":[{"line":4,"address":[174656,175892,175848],"length":1,"stats":{"Line":4}},{"line":7,"address":[174678,174772],"length":1,"stats":{"Line":8}},{"line":11,"address":[174858],"length":1,"stats":{"Line":3}},{"line":12,"address":[175656],"length":1,"stats":{"Line":3}}],"covered":4,"coverable":4},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","tests.rs"],"content":"use crate::frontend::lexer::Lexer;\n\nuse super::token::Token;\n\n#[test]\nfn peek_none() {\n    let lexer = Lexer::from_string(\u0026\"\");\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn peek() {\n    let lexer = Lexer::from_string(\u0026\"qwerty\");\n    assert!(lexer.peek_char() == Some('q'));\n}\n\n#[test]\nfn advance_char() {\n    let mut lexer = Lexer::from_string(\u0026\"ab\");\n    assert_eq!(lexer.peek_char(), Some('a'));\n    lexer.advance_char();\n    assert_eq!(lexer.peek_char(), Some('b'));\n}\n\n#[test]\nfn advance_to_end() {\n    let mut lexer = Lexer::from_string(\u0026\"a\");\n    lexer.advance_char();\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn test_loc_chars() {\n    let mut lexer = Lexer::from_string(\u0026\"the quick brown\\nfox jumps\\nover the lazy\\ndog\\n\\n\");\n\n    let mut line_lengths = Vec::new();\n    let mut cols = 0;\n\n    while lexer.peek_char().is_some() {\n        let examined = lexer.peek_char().unwrap();\n        lexer.advance_char();\n        match examined {\n            '\\n' =\u003e {\n                line_lengths.push(cols);\n                cols = 0;\n            }\n            _ =\u003e {\n                cols += 1;\n            }\n        }\n    }\n\n    assert_eq!(line_lengths, vec![15, 9, 13, 3, 0]);\n}\n\n// helper function - do some basic prefixing and suffixing\n// ensure keyword matching behaves as expected with alpha/num pre/suffixes\nfn kw_or_ident(string: \u0026str, expected_token: Token) {\n    let mut positive_match = Lexer::from_string(\u0026string);\n\n    let matched = positive_match.match_kw_or_ident();\n    assert_eq!(matched, Some(expected_token.clone()));\n\n    let prefix_alpha = \"a\".to_owned() + string;\n    let mut negative_match = Lexer::from_string(\u0026\u0026prefix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(prefix_alpha))\n    );\n\n    let prefix_num = \"1\".to_owned() + string;\n    negative_match = Lexer::from_string(\u0026\u0026prefix_num);\n    assert_ne!(negative_match.match_kw_or_ident(), Some(expected_token));\n\n    let suffix_alpha = string.to_owned() + \"a\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(suffix_alpha))\n    );\n\n    let suffix_num = string.to_owned() + \"1\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_num);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(suffix_num))\n    );\n}\n\n// test every keyword\n#[test]\nfn keywords() {\n    let keyword_pairings = vec![\n        (\"u8\", Token::U8),\n        (\"u16\", Token::U16),\n        (\"u32\", Token::U32),\n        (\"u64\", Token::U64),\n        (\"i8\", Token::I8),\n        (\"i16\", Token::I16),\n        (\"i32\", Token::I32),\n        (\"i64\", Token::I64),\n        (\"fun\", Token::Fun),\n        (\"if\", Token::If),\n        (\"else\", Token::Else),\n        (\"pub\", Token::Pub),\n        (\"while\", Token::While),\n        (\"struct\", Token::Struct),\n        (\"impl\", Token::Impl),\n        (\"Self\", Token::SelfUpper),\n        (\"self\", Token::SelfLower),\n        (\"mut\", Token::Mut)];\n\n    for (string, token) in keyword_pairings {\n        kw_or_ident(string, token);\n    }\n}\n\n#[test]\nfn ident() {\n    // test out some basic identifiers - such as ones containing keywords\n    kw_or_ident(\"foobar\", Token::Identifier(\"foobar\".to_owned()));\n    kw_or_ident(\"the_u8\", Token::Identifier(\"the_u8\".to_owned()));\n    kw_or_ident(\"big_if_true\", Token::Identifier(\"big_if_true\".to_owned()));\n\n    // make sure that we can correctly parse the end of identifiers\n    let space_after = \"space_after abcde\";\n    let space_after_ident = Token::Identifier(String::from(\"space_after\"));\n    let mut positive_match = Lexer::from_string(\u0026space_after);\n    assert_eq!(\n        positive_match.match_kw_or_ident(),\n        Some(space_after_ident.clone())\n    );\n\n    let prefix_alpha = \"a\".to_owned() + space_after;\n    let mut negative_match = Lexer::from_string(\u0026\u0026prefix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(String::from(\"aspace_after\")))\n    );\n\n    let prefix_num = \"1\".to_owned() + space_after;\n    negative_match = Lexer::from_string(\u0026\u0026prefix_num);\n    assert_ne!(\n        negative_match.match_kw_or_ident(),\n        Some(space_after_ident.clone())\n    );\n\n    let suffix_alpha = space_after.to_owned() + \"a\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(space_after_ident.clone())\n    );\n\n    let suffix_num = space_after.to_owned() + \"1\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_num);\n    assert_eq!(negative_match.match_kw_or_ident(), Some(space_after_ident));\n}\n\n#[test]\nfn token_display_to_token() {\n    let tokens = vec![\n        Token::U8,\n        Token::U16,\n        Token::U32,\n        Token::U64,\n        Token::I8,\n        Token::I16,\n        Token::I32,\n        Token::I64,\n        Token::Plus,\n        Token::Minus,\n        Token::Star,\n        Token::FSlash,\n        Token::GThan,\n        Token::GThanE,\n        Token::LThan,\n        Token::LThanE,\n        Token::Equals,\n        Token::NotEquals,\n        Token::Assign,\n        Token::Fun,\n        Token::If,\n        Token::Else,\n        Token::While,\n        Token::Pub,\n        Token::Struct,\n        Token::Impl,\n        Token::SelfUpper,\n        Token::SelfLower,\n        Token::Mut,\n        Token::Reference,\n        Token::LParen,\n        Token::RParen,\n        Token::Arrow,\n        Token::LCurly,\n        Token::RCurly,\n        Token::Comma,\n        Token::Dot,\n        Token::Semicolon,\n        Token::Colon,\n    ];\n\n    for token in tokens {\n        let lex_result = Lexer::from_string(\u0026format!(\"{}\", token))\n            .lex_all()\n            .expect(\"\");\n        assert_eq!(lex_result.len(), 2);\n        assert_eq!(token, lex_result[0].0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","token.rs"],"content":"use std::fmt::Display;\n\n#[derive(Clone, Debug)]\npub enum Token {\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    Plus,\n    Minus,\n    Star,\n    FSlash,\n    LThan,\n    GThan,\n    LThanE,\n    GThanE,\n    Equals,\n    NotEquals,\n    Assign,\n    Fun,\n    If,\n    Else,\n    Pub,\n    While,\n    Struct,\n    Impl,\n    SelfUpper,\n    SelfLower,\n    Mut,\n    Reference,\n    LParen,\n    RParen,\n    Arrow,\n    LCurly,\n    RCurly,\n    Comma,\n    Dot,\n    Semicolon,\n    Colon,\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Eof,\n}\n\nimpl PartialEq for Token {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Token::U8, Token::U8) =\u003e true,\n            (Token::U16, Token::U16) =\u003e true,\n            (Token::U32, Token::U32) =\u003e true,\n            (Token::U64, Token::U64) =\u003e true,\n            (Token::I8, Token::I8) =\u003e true,\n            (Token::I16, Token::I16) =\u003e true,\n            (Token::I32, Token::I32) =\u003e true,\n            (Token::I64, Token::I64) =\u003e true,\n            (Token::Plus, Token::Plus) =\u003e true,\n            (Token::Minus, Token::Minus) =\u003e true,\n            (Token::Star, Token::Star) =\u003e true,\n            (Token::FSlash, Token::FSlash) =\u003e true,\n            (Token::LThan, Token::LThan) =\u003e true,\n            (Token::GThan, Token::GThan) =\u003e true,\n            (Token::LThanE, Token::LThanE) =\u003e true,\n            (Token::GThanE, Token::GThanE) =\u003e true,\n            (Token::Equals, Token::Equals) =\u003e true,\n            (Token::NotEquals, Token::NotEquals) =\u003e true,\n            (Token::Assign, Token::Assign) =\u003e true,\n            (Token::Fun, Token::Fun) =\u003e true,\n            (Token::If, Token::If) =\u003e true,\n            (Token::Else, Token::Else) =\u003e true,\n            (Token::While, Token::While) =\u003e true,\n            (Token::Pub, Token::Pub) =\u003e true,\n            (Token::Struct, Token::Struct) =\u003e true,\n            (Token::Impl, Token::Impl) =\u003e true,\n            (Token::SelfUpper, Token::SelfUpper) =\u003e true,\n            (Token::SelfLower, Token::SelfLower) =\u003e true,\n            (Token::Mut, Token::Mut) =\u003e true,\n            (Token::Reference, Token::Reference) =\u003e true,\n            (Token::LParen, Token::LParen) =\u003e true,\n            (Token::RParen, Token::RParen) =\u003e true,\n            (Token::Arrow, Token::Arrow) =\u003e true,\n            (Token::LCurly, Token::LCurly) =\u003e true,\n            (Token::RCurly, Token::RCurly) =\u003e true,\n            (Token::Comma, Token::Comma) =\u003e true,\n            (Token::Dot, Token::Dot) =\u003e true,\n            (Token::Semicolon, Token::Semicolon) =\u003e true,\n            (Token::Colon, Token::Colon) =\u003e true,\n            (Token::Identifier(_), Token::Identifier(_)) =\u003e true,\n            (Token::UnsignedDecimalConstant(_), Token::UnsignedDecimalConstant(_)) =\u003e true,\n            (Token::Eof, Token::Eof) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl Eq for Token {}\n\nimpl Token {\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            Self::U8 =\u003e \"u8\",\n            Self::U16 =\u003e \"u16\",\n            Self::U32 =\u003e \"u32\",\n            Self::U64 =\u003e \"u64\",\n            Self::I8 =\u003e \"i8\",\n            Self::I16 =\u003e \"i16\",\n            Self::I32 =\u003e \"i32\",\n            Self::I64 =\u003e \"i64\",\n            Self::Plus =\u003e \"+\",\n            Self::Minus =\u003e \"-\",\n            Self::Star =\u003e \"*\",\n            Self::FSlash =\u003e \"/\",\n            Self::GThan =\u003e \"\u003e\",\n            Self::GThanE =\u003e \"\u003e=\",\n            Self::LThan =\u003e \"\u003c\",\n            Self::LThanE =\u003e \"\u003c=\",\n            Self::Equals =\u003e \"==\",\n            Self::NotEquals =\u003e \"!=\",\n            Self::Assign =\u003e \"=\",\n            Self::Fun =\u003e \"fun\",\n            Self::If =\u003e \"if\",\n            Self::Else =\u003e \"else\",\n            Self::While =\u003e \"while\",\n            Self::Pub =\u003e \"pub\",\n            Self::Struct =\u003e \"struct\",\n            Self::Impl =\u003e \"impl\",\n            Self::SelfUpper =\u003e \"Self\",\n            Self::SelfLower =\u003e \"self\",\n            Self::Mut =\u003e \"mut\",\n            Self::Reference =\u003e \"\u0026\",\n            Self::LParen =\u003e \"(\",\n            Self::RParen =\u003e \")\",\n            Self::Arrow =\u003e \"-\u003e\",\n            Self::LCurly =\u003e \"{\",\n            Self::RCurly =\u003e \"}\",\n            Self::Comma =\u003e \",\",\n            Self::Dot =\u003e \".\",\n            Self::Semicolon =\u003e \";\",\n            Self::Colon =\u003e \":\",\n            Self::Identifier(_) =\u003e \"identifier\",\n            Self::UnsignedDecimalConstant(_) =\u003e \"unsigned decimal constant\",\n            Self::Eof =\u003e \"EOF\",\n        }\n    }\n}\n\nimpl Display for Token {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::Plus =\u003e write!(f, \"+\"),\n            Self::Minus =\u003e write!(f, \"-\"),\n            Self::Star =\u003e write!(f, \"*\"),\n            Self::FSlash =\u003e write!(f, \"/\"),\n            Self::GThan =\u003e write!(f, \"\u003e\"),\n            Self::GThanE =\u003e write!(f, \"\u003e=\"),\n            Self::LThan =\u003e write!(f, \"\u003c\"),\n            Self::LThanE =\u003e write!(f, \"\u003c=\"),\n            Self::Equals =\u003e write!(f, \"==\"),\n            Self::NotEquals =\u003e write!(f, \"!=\"),\n            Self::Assign =\u003e write!(f, \"=\"),\n            Self::Fun =\u003e write!(f, \"fun\"),\n            Self::If =\u003e write!(f, \"if\"),\n            Self::Else =\u003e write!(f, \"else\"),\n            Self::While =\u003e write!(f, \"while\"),\n            Self::Pub =\u003e write!(f, \"pub\"),\n            Self::Struct =\u003e write!(f, \"struct\"),\n            Self::Impl =\u003e write!(f, \"impl\"),\n            Self::SelfUpper =\u003e write!(f, \"Self\"),\n            Self::SelfLower =\u003e write!(f, \"self\"),\n            Self::Mut =\u003e write!(f, \"mut\"),\n            Self::Reference =\u003e write!(f, \"\u0026\"),\n            Self::LParen =\u003e write!(f, \"(\"),\n            Self::RParen =\u003e write!(f, \")\"),\n            Self::Arrow =\u003e write!(f, \"-\u003e\"),\n            Self::LCurly =\u003e write!(f, \"{{\"),\n            Self::RCurly =\u003e write!(f, \"}}\"),\n            Self::Comma =\u003e write!(f, \",\"),\n            Self::Dot =\u003e write!(f, \".\"),\n            Self::Semicolon =\u003e write!(f, \";\"),\n            Self::Colon =\u003e write!(f, \":\"),\n            Self::Identifier(string) =\u003e write!(f, \"Identifier({})\", string),\n            Self::UnsignedDecimalConstant(constant) =\u003e {\n                write!(f, \"UnsignedDecimalConstant({})\", constant)\n            }\n            Self::Eof =\u003e write!(f, \"EOF\"),\n        }\n    }\n}\n","traces":[{"line":50,"address":[312531,312448],"length":1,"stats":{"Line":1}},{"line":51,"address":[312533,312458],"length":1,"stats":{"Line":2}},{"line":102,"address":[314720],"length":1,"stats":{"Line":0}},{"line":103,"address":[314725],"length":1,"stats":{"Line":0}},{"line":104,"address":[314785],"length":1,"stats":{"Line":0}},{"line":105,"address":[314811],"length":1,"stats":{"Line":0}},{"line":106,"address":[314837],"length":1,"stats":{"Line":0}},{"line":107,"address":[314863],"length":1,"stats":{"Line":0}},{"line":108,"address":[314889],"length":1,"stats":{"Line":0}},{"line":109,"address":[314915],"length":1,"stats":{"Line":0}},{"line":110,"address":[314941],"length":1,"stats":{"Line":0}},{"line":111,"address":[314967],"length":1,"stats":{"Line":0}},{"line":112,"address":[314993],"length":1,"stats":{"Line":0}},{"line":113,"address":[315019],"length":1,"stats":{"Line":0}},{"line":114,"address":[315045],"length":1,"stats":{"Line":0}},{"line":115,"address":[315071],"length":1,"stats":{"Line":0}},{"line":116,"address":[315123],"length":1,"stats":{"Line":0}},{"line":117,"address":[315175],"length":1,"stats":{"Line":0}},{"line":118,"address":[315097],"length":1,"stats":{"Line":0}},{"line":119,"address":[315149],"length":1,"stats":{"Line":0}},{"line":120,"address":[315201],"length":1,"stats":{"Line":0}},{"line":121,"address":[315227],"length":1,"stats":{"Line":0}},{"line":122,"address":[315253],"length":1,"stats":{"Line":0}},{"line":123,"address":[315279],"length":1,"stats":{"Line":0}},{"line":124,"address":[315305],"length":1,"stats":{"Line":0}},{"line":125,"address":[315331],"length":1,"stats":{"Line":0}},{"line":126,"address":[315383],"length":1,"stats":{"Line":0}},{"line":127,"address":[315357],"length":1,"stats":{"Line":0}},{"line":128,"address":[315409],"length":1,"stats":{"Line":0}},{"line":129,"address":[315435],"length":1,"stats":{"Line":0}},{"line":130,"address":[315461],"length":1,"stats":{"Line":0}},{"line":131,"address":[315487],"length":1,"stats":{"Line":0}},{"line":132,"address":[315513],"length":1,"stats":{"Line":0}},{"line":133,"address":[315539],"length":1,"stats":{"Line":0}},{"line":134,"address":[315565],"length":1,"stats":{"Line":0}},{"line":135,"address":[315591],"length":1,"stats":{"Line":0}},{"line":136,"address":[315617],"length":1,"stats":{"Line":0}},{"line":137,"address":[315643],"length":1,"stats":{"Line":0}},{"line":138,"address":[315669],"length":1,"stats":{"Line":0}},{"line":139,"address":[315695],"length":1,"stats":{"Line":0}},{"line":140,"address":[315721],"length":1,"stats":{"Line":0}},{"line":141,"address":[315744],"length":1,"stats":{"Line":0}},{"line":142,"address":[315767],"length":1,"stats":{"Line":0}},{"line":143,"address":[315790],"length":1,"stats":{"Line":0}},{"line":144,"address":[315813],"length":1,"stats":{"Line":0}},{"line":145,"address":[315836],"length":1,"stats":{"Line":0}},{"line":151,"address":[315872],"length":1,"stats":{"Line":1}},{"line":152,"address":[315905],"length":1,"stats":{"Line":1}},{"line":153,"address":[315965],"length":1,"stats":{"Line":1}},{"line":154,"address":[316008],"length":1,"stats":{"Line":1}},{"line":155,"address":[316051],"length":1,"stats":{"Line":1}},{"line":156,"address":[316100],"length":1,"stats":{"Line":1}},{"line":157,"address":[316149],"length":1,"stats":{"Line":1}},{"line":158,"address":[316198],"length":1,"stats":{"Line":1}},{"line":159,"address":[316247],"length":1,"stats":{"Line":1}},{"line":160,"address":[316296],"length":1,"stats":{"Line":1}},{"line":161,"address":[316345],"length":1,"stats":{"Line":1}},{"line":162,"address":[316394],"length":1,"stats":{"Line":1}},{"line":163,"address":[316443],"length":1,"stats":{"Line":1}},{"line":164,"address":[316492],"length":1,"stats":{"Line":1}},{"line":165,"address":[316590],"length":1,"stats":{"Line":1}},{"line":166,"address":[316688],"length":1,"stats":{"Line":1}},{"line":167,"address":[316541],"length":1,"stats":{"Line":1}},{"line":168,"address":[316639],"length":1,"stats":{"Line":1}},{"line":169,"address":[316737],"length":1,"stats":{"Line":1}},{"line":170,"address":[316786],"length":1,"stats":{"Line":1}},{"line":171,"address":[316835],"length":1,"stats":{"Line":1}},{"line":172,"address":[316884],"length":1,"stats":{"Line":1}},{"line":173,"address":[316933],"length":1,"stats":{"Line":1}},{"line":174,"address":[316982],"length":1,"stats":{"Line":1}},{"line":175,"address":[317080],"length":1,"stats":{"Line":1}},{"line":176,"address":[317031],"length":1,"stats":{"Line":1}},{"line":177,"address":[317129],"length":1,"stats":{"Line":1}},{"line":178,"address":[317178],"length":1,"stats":{"Line":1}},{"line":179,"address":[317227],"length":1,"stats":{"Line":1}},{"line":180,"address":[317276],"length":1,"stats":{"Line":1}},{"line":181,"address":[317325],"length":1,"stats":{"Line":1}},{"line":182,"address":[317374],"length":1,"stats":{"Line":1}},{"line":183,"address":[317423],"length":1,"stats":{"Line":1}},{"line":184,"address":[317472],"length":1,"stats":{"Line":1}},{"line":185,"address":[317521],"length":1,"stats":{"Line":1}},{"line":186,"address":[317570],"length":1,"stats":{"Line":1}},{"line":187,"address":[317619],"length":1,"stats":{"Line":1}},{"line":188,"address":[317668],"length":1,"stats":{"Line":1}},{"line":189,"address":[317717],"length":1,"stats":{"Line":1}},{"line":190,"address":[317766],"length":1,"stats":{"Line":1}},{"line":191,"address":[317815],"length":1,"stats":{"Line":1}},{"line":192,"address":[317869],"length":1,"stats":{"Line":1}},{"line":193,"address":[317993],"length":1,"stats":{"Line":1}},{"line":194,"address":[318005],"length":1,"stats":{"Line":1}},{"line":196,"address":[318113],"length":1,"stats":{"Line":0}}],"covered":46,"coverable":91},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer.rs"],"content":"use token::Token;\n\nuse super::sourceloc::SourceLoc;\n\npub use char_source::CharSource;\n\nmod char_source;\npub mod errors;\n#[cfg(test)]\nmod integration_tests;\n#[cfg(test)]\nmod tests;\npub mod token;\n\npub use errors::LexError;\n\n#[derive(Debug)]\npub struct Lexer\u003c'a\u003e {\n    cur_line: usize,\n    cur_col: usize,\n    current_char: Option\u003cchar\u003e,\n    current_token: Option\u003c(Token, SourceLoc)\u003e,\n    char_source: CharSource\u003c'a\u003e,\n}\n\n// public methods:\nimpl\u003c'a\u003e Lexer\u003c'a\u003e {\n    pub fn from_char_source(mut char_source: CharSource\u003c'a\u003e) -\u003e Self {\n        let first_char = char_source.next();\n\n        let start_line = if first_char == Some('\\n') { 2 } else { 1 };\n        let start_col = 1;\n\n        let created = Self {\n            cur_line: start_line,\n            cur_col: start_col,\n            current_char: first_char,\n            current_token: None,\n            char_source,\n        };\n\n        created\n    }\n\n    pub fn from_file(f: std::fs::File) -\u003e Self {\n        Self::from_char_source(CharSource::from_file(f))\n    }\n\n    pub fn from_string(s: \u0026'a str) -\u003e Self {\n        Self::from_char_source(CharSource::from_str(s))\n    }\n\n    pub fn peek(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        if self.current_token.is_none() {\n            self.current_token = Some(self.lex()?);\n        }\n\n        let peeked = self\n            .current_token\n            .clone()\n            .unwrap_or((Token::Eof, SourceLoc::new(self.cur_line, self.cur_col)));\n\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::peek() -\u003e {:?}\", peeked);\n\n        Ok(peeked)\n    }\n\n    // returns the position to which the input has been read\n    pub fn current_loc(\u0026self) -\u003e SourceLoc {\n        SourceLoc::new(self.cur_line, self.cur_col)\n    }\n\n    pub fn next(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        let next_token = self.lex()?;\n        Ok(self\n            .current_token\n            .replace(next_token)\n            .unwrap_or((Token::Eof, SourceLoc::new(self.cur_line, self.cur_col))))\n    }\n\n    pub fn lex_all(\u0026mut self) -\u003e Result\u003cVec\u003c(Token, SourceLoc)\u003e, LexError\u003e {\n        println!(\"Lexer::lex_all()\");\n        let mut tokens: Vec\u003c(Token, SourceLoc)\u003e = Vec::new();\n        if self.current_token.is_none() {\n            tokens.push(self.lex()?);\n        }\n\n        loop {\n            let next_token = self.next()?;\n            println!(\"next_token: {:?}\", next_token);\n            match next_token.0 {\n                Token::Eof =\u003e {\n                    tokens.push(next_token);\n                    break;\n                }\n                _ =\u003e {\n                    tokens.push(next_token);\n                }\n            }\n        }\n\n        println!(\"Lexer::lex_all(): {:?}\", tokens);\n\n        Ok(tokens)\n    }\n}\n\n// private methods\nimpl\u003c'a\u003e Lexer\u003c'a\u003e {\n    fn peek_char(\u0026self) -\u003e Option\u003cchar\u003e {\n        // #[cfg(feature = \"loud_lexing\")]\n        // println!(\"Lexer::peek_char: {:?}\", self.current_char);\n\n        self.current_char\n    }\n\n    fn advance_char(\u0026mut self) {\n        // #[cfg(feature = \"loud_lexing\")]\n        // println!(\"Lexer::advance_char: {:?}\", self.current_char);\n        if let Some(consumed) = self.current_char {\n            if consumed == '\\n' {\n                self.cur_line += 1;\n                self.cur_col = 1;\n            } else {\n                self.cur_col += 1;\n            }\n        }\n        self.current_char = self.char_source.next();\n    }\n\n    fn match_kw_or_ident(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::match_kw_or_ident\");\n\n        let mut identifier = String::new();\n\n        if let Some(first_char) = self.peek_char() {\n            if first_char.is_alphabetic() || first_char == '_' {\n                identifier.push(first_char);\n                self.advance_char();\n                while let Some(c) = self.peek_char() {\n                    if c.is_alphanumeric() || c == '_' {\n                        identifier.push(c);\n                        self.advance_char();\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        let matched = match identifier.as_str() {\n            \"u8\" =\u003e Some(Token::U8),\n            \"u16\" =\u003e Some(Token::U16),\n            \"u32\" =\u003e Some(Token::U32),\n            \"u64\" =\u003e Some(Token::U64),\n            \"i8\" =\u003e Some(Token::I8),\n            \"i16\" =\u003e Some(Token::I16),\n            \"i32\" =\u003e Some(Token::I32),\n            \"i64\" =\u003e Some(Token::I64),\n            \"fun\" =\u003e Some(Token::Fun),\n            \"if\" =\u003e Some(Token::If),\n            \"else\" =\u003e Some(Token::Else),\n            \"while\" =\u003e Some(Token::While),\n            \"pub\" =\u003e Some(Token::Pub),\n            \"struct\" =\u003e Some(Token::Struct),\n            \"impl\" =\u003e Some(Token::Impl),\n            \"Self\" =\u003e Some(Token::SelfUpper),\n            \"self\" =\u003e Some(Token::SelfLower),\n            \"mut\" =\u003e Some(Token::Mut),\n            _ =\u003e {\n                if identifier.len() \u003e 0 {\n                    Some(Token::Identifier(identifier))\n                } else {\n                    None\n                }\n            }\n        };\n\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::match_kw_or_ident: matched {:?}\", matched);\n\n        matched\n    }\n\n    fn match_next_char_for_token_or(\n        \u0026mut self,\n        expected: char,\n        tok_true: Token,\n        tok_false: Token,\n    ) -\u003e Token {\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\n            \"Lexer::match_next_char_for_token_or: expected: {}, true: {}, false: {}\",\n            expected, tok_true, tok_false\n        );\n\n        match self.peek_char() {\n            None =\u003e tok_false,\n            Some(peeked_char) =\u003e {\n                if peeked_char == expected {\n                    self.advance_char();\n                    tok_true\n                } else {\n                    tok_false\n                }\n            }\n        }\n    }\n\n    fn trim_whitespace(\u0026mut self) {\n        while self.peek_char().is_some() \u0026\u0026 self.peek_char().unwrap().is_whitespace() {\n            self.advance_char();\n        }\n    }\n\n    fn lex(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::lex()\");\n\n        self.trim_whitespace();\n        let match_start = SourceLoc::new(self.cur_line, self.cur_col);\n\n        let token = if let Some(peeked_char) = self.peek_char() {\n            match peeked_char {\n                '{' =\u003e {\n                    self.advance_char();\n                    Ok(Token::LCurly)\n                }\n                '}' =\u003e {\n                    self.advance_char();\n                    Ok(Token::RCurly)\n                }\n                '(' =\u003e {\n                    self.advance_char();\n                    Ok(Token::LParen)\n                }\n                ')' =\u003e {\n                    self.advance_char();\n                    Ok(Token::RParen)\n                }\n                '+' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Plus)\n                }\n                '-' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('\u003e', Token::Arrow, Token::Minus))\n                }\n                '*' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Star)\n                }\n                '/' =\u003e {\n                    self.advance_char();\n                    Ok(Token::FSlash)\n                }\n                '\u003e' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('=', Token::GThanE, Token::GThan))\n                }\n                '\u003c' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('=', Token::LThanE, Token::LThan))\n                }\n                '!' =\u003e {\n                    self.advance_char();\n                    match self.peek_char() {\n                        None =\u003e Err(LexError::unexpected_eof(self.current_loc())),\n                        Some(character) =\u003e {\n                            if character == '=' {\n                                self.advance_char();\n                                Ok(Token::NotEquals)\n                            } else {\n                                Err(LexError::invalid_char(character, self.current_loc()))\n                            }\n                        }\n                    }\n                }\n                '=' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('=', Token::Equals, Token::Assign))\n                }\n                ',' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Comma)\n                }\n                '.' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Dot)\n                }\n                ';' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Semicolon)\n                }\n                ':' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Colon)\n                }\n                '\u0026' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Reference)\n                }\n                '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' =\u003e {\n                    let mut constant_string = String::new();\n                    while self.peek_char().is_some() {\n                        let char: char = self.peek_char().unwrap();\n                        if char.is_numeric() {\n                            self.advance_char();\n                            constant_string.push(char);\n                        } else {\n                            break;\n                        }\n                    }\n                    Ok(Token::UnsignedDecimalConstant(\n                        usize::from_str_radix(\u0026constant_string, 10)\n                            .expect(\"Couldn't convert unsigned decimal constant\"),\n                    ))\n                }\n                _ =\u003e match self.match_kw_or_ident() {\n                    Some(token) =\u003e Ok(token),\n                    None =\u003e Err(LexError::invalid_char(\n                        self.peek_char().unwrap(),\n                        self.current_loc(),\n                    )),\n                },\n            }\n        } else {\n            Ok(Token::Eof)\n        };\n\n        self.trim_whitespace();\n\n        match token {\n            Ok(tok) =\u003e {\n                #[cfg(feature = \"loud_lexing\")]\n                println!(\"Lexer::lex(): lexed '{}'@{}\", tok.name(), match_start);\n                Ok((tok, match_start))\n            }\n            Err(e) =\u003e {\n                #[cfg(feature = \"loud_lexing\")]\n                println!(\"Lexer::lex(): lexing error {}\", e);\n                Err(e)\n            }\n        }\n    }\n}\n","traces":[{"line":28,"address":[358128,358412],"length":1,"stats":{"Line":15}},{"line":29,"address":[358222,358170],"length":1,"stats":{"Line":31}},{"line":31,"address":[358226],"length":1,"stats":{"Line":16}},{"line":32,"address":[358158],"length":1,"stats":{"Line":15}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[358448],"length":1,"stats":{"Line":0}},{"line":46,"address":[358465],"length":1,"stats":{"Line":0}},{"line":49,"address":[358512],"length":1,"stats":{"Line":7}},{"line":50,"address":[358542],"length":1,"stats":{"Line":7}},{"line":53,"address":[359263,358592],"length":1,"stats":{"Line":7}},{"line":54,"address":[359046,358630],"length":1,"stats":{"Line":9}},{"line":55,"address":[358743],"length":1,"stats":{"Line":7}},{"line":58,"address":[358656,359146],"length":1,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[359059,359293,358696,359185],"length":1,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[359232],"length":1,"stats":{"Line":4}},{"line":70,"address":[359312],"length":1,"stats":{"Line":6}},{"line":71,"address":[359320],"length":1,"stats":{"Line":7}},{"line":74,"address":[360050,359344,360023],"length":1,"stats":{"Line":3}},{"line":75,"address":[359537,359374],"length":1,"stats":{"Line":7}},{"line":76,"address":[359690,359984,359895,359623],"length":1,"stats":{"Line":28}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[359627,359743],"length":1,"stats":{"Line":14}},{"line":79,"address":[360040,359761,359934],"length":1,"stats":{"Line":8}},{"line":82,"address":[361256,361287,360080],"length":1,"stats":{"Line":5}},{"line":83,"address":[360109],"length":1,"stats":{"Line":5}},{"line":84,"address":[360158],"length":1,"stats":{"Line":5}},{"line":85,"address":[360224,360168],"length":1,"stats":{"Line":2}},{"line":86,"address":[361285,360266],"length":1,"stats":{"Line":5}},{"line":89,"address":[361233],"length":1,"stats":{"Line":0}},{"line":90,"address":[360243,360478],"length":1,"stats":{"Line":6}},{"line":91,"address":[360703,360751],"length":1,"stats":{"Line":8}},{"line":92,"address":[360820],"length":1,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[360860],"length":1,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[360943],"length":1,"stats":{"Line":0}},{"line":103,"address":[361050],"length":1,"stats":{"Line":4}},{"line":105,"address":[361130],"length":1,"stats":{"Line":4}},{"line":111,"address":[361312],"length":1,"stats":{"Line":3}},{"line":115,"address":[361317],"length":1,"stats":{"Line":3}},{"line":118,"address":[361328],"length":1,"stats":{"Line":1}},{"line":121,"address":[361342],"length":1,"stats":{"Line":1}},{"line":122,"address":[361538,361386,361504],"length":1,"stats":{"Line":7}},{"line":123,"address":[361506,361486,361426],"length":1,"stats":{"Line":2}},{"line":124,"address":[361493],"length":1,"stats":{"Line":1}},{"line":126,"address":[361531,361454,361543],"length":1,"stats":{"Line":2}},{"line":129,"address":[361398],"length":1,"stats":{"Line":3}},{"line":132,"address":[361568,364321],"length":1,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[361598],"length":1,"stats":{"Line":2}},{"line":138,"address":[361685,361629],"length":1,"stats":{"Line":4}},{"line":139,"address":[361780,361740],"length":1,"stats":{"Line":4}},{"line":140,"address":[361804],"length":1,"stats":{"Line":2}},{"line":141,"address":[361816],"length":1,"stats":{"Line":2}},{"line":142,"address":[361830],"length":1,"stats":{"Line":2}},{"line":143,"address":[361904],"length":1,"stats":{"Line":2}},{"line":144,"address":[361947],"length":1,"stats":{"Line":2}},{"line":145,"address":[361959],"length":1,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[361981,361756],"length":1,"stats":{"Line":8}},{"line":154,"address":[361997,362063],"length":1,"stats":{"Line":10}},{"line":155,"address":[362138,362040,362177],"length":1,"stats":{"Line":12}},{"line":156,"address":[362252,362291,362154],"length":1,"stats":{"Line":11}},{"line":157,"address":[362366,362268,362405],"length":1,"stats":{"Line":12}},{"line":158,"address":[362519,362382,362480],"length":1,"stats":{"Line":13}},{"line":159,"address":[362633,362496,362594],"length":1,"stats":{"Line":13}},{"line":160,"address":[362708,362610,362747],"length":1,"stats":{"Line":13}},{"line":161,"address":[362861,362724,362822],"length":1,"stats":{"Line":13}},{"line":162,"address":[362936,362838,362975],"length":1,"stats":{"Line":13}},{"line":163,"address":[362952,363089,363050],"length":1,"stats":{"Line":13}},{"line":164,"address":[363203,363066,363164],"length":1,"stats":{"Line":13}},{"line":165,"address":[363180,363317,363278],"length":1,"stats":{"Line":13}},{"line":166,"address":[363294,363392,363431],"length":1,"stats":{"Line":13}},{"line":167,"address":[363545,363408,363506],"length":1,"stats":{"Line":11}},{"line":168,"address":[363522,363620,363659],"length":1,"stats":{"Line":10}},{"line":169,"address":[363773,363636,363734],"length":1,"stats":{"Line":11}},{"line":170,"address":[363750,363887,363848],"length":1,"stats":{"Line":7}},{"line":171,"address":[363962,363864,363984],"length":1,"stats":{"Line":11}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[363973,364059,364083],"length":1,"stats":{"Line":12}},{"line":174,"address":[364088],"length":1,"stats":{"Line":5}},{"line":176,"address":[364065],"length":1,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[364242],"length":1,"stats":{"Line":6}},{"line":187,"address":[364352,364716],"length":1,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[364401,364466],"length":1,"stats":{"Line":2}},{"line":200,"address":[364524],"length":1,"stats":{"Line":1}},{"line":201,"address":[364501],"length":1,"stats":{"Line":1}},{"line":202,"address":[364596,364647,364509],"length":1,"stats":{"Line":2}},{"line":203,"address":[364603],"length":1,"stats":{"Line":1}},{"line":204,"address":[364620],"length":1,"stats":{"Line":1}},{"line":206,"address":[364569],"length":1,"stats":{"Line":0}},{"line":212,"address":[364752],"length":1,"stats":{"Line":1}},{"line":213,"address":[364769,364801],"length":1,"stats":{"Line":6}},{"line":214,"address":[364837],"length":1,"stats":{"Line":2}},{"line":218,"address":[364848,367727],"length":1,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[364886],"length":1,"stats":{"Line":5}},{"line":223,"address":[364896],"length":1,"stats":{"Line":5}},{"line":225,"address":[364949,365119],"length":1,"stats":{"Line":5}},{"line":226,"address":[365005],"length":1,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[365193],"length":1,"stats":{"Line":1}},{"line":229,"address":[365198],"length":1,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[365286],"length":1,"stats":{"Line":1}},{"line":233,"address":[365291],"length":1,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[365379],"length":1,"stats":{"Line":1}},{"line":237,"address":[365384],"length":1,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[365472],"length":1,"stats":{"Line":1}},{"line":241,"address":[365477],"length":1,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[365565],"length":1,"stats":{"Line":1}},{"line":245,"address":[365570],"length":1,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[365658],"length":1,"stats":{"Line":1}},{"line":249,"address":[365668],"length":1,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[365808],"length":1,"stats":{"Line":1}},{"line":253,"address":[365813],"length":1,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[365901],"length":1,"stats":{"Line":1}},{"line":257,"address":[365906],"length":1,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[365994],"length":1,"stats":{"Line":1}},{"line":261,"address":[366004],"length":1,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[366144],"length":1,"stats":{"Line":1}},{"line":265,"address":[366154],"length":1,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[366294],"length":1,"stats":{"Line":1}},{"line":269,"address":[366304],"length":1,"stats":{"Line":1}},{"line":270,"address":[367030],"length":1,"stats":{"Line":0}},{"line":271,"address":[366997],"length":1,"stats":{"Line":1}},{"line":272,"address":[367015,367204,367309],"length":1,"stats":{"Line":2}},{"line":273,"address":[367121],"length":1,"stats":{"Line":1}},{"line":274,"address":[367126],"length":1,"stats":{"Line":1}},{"line":276,"address":[367214],"length":1,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[366360],"length":1,"stats":{"Line":1}},{"line":283,"address":[366370],"length":1,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[366510],"length":1,"stats":{"Line":1}},{"line":287,"address":[366515],"length":1,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[366603],"length":1,"stats":{"Line":1}},{"line":291,"address":[366608],"length":1,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[366696],"length":1,"stats":{"Line":1}},{"line":295,"address":[366701],"length":1,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[366789],"length":1,"stats":{"Line":1}},{"line":299,"address":[366794],"length":1,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[366879],"length":1,"stats":{"Line":1}},{"line":303,"address":[366884],"length":1,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[366964],"length":1,"stats":{"Line":1}},{"line":307,"address":[367319,367378],"length":1,"stats":{"Line":2}},{"line":308,"address":[367444],"length":1,"stats":{"Line":1}},{"line":309,"address":[367488],"length":1,"stats":{"Line":1}},{"line":310,"address":[367514],"length":1,"stats":{"Line":1}},{"line":311,"address":[367715],"length":1,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[367598],"length":1,"stats":{"Line":1}},{"line":317,"address":[367547,367422],"length":1,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[365129],"length":1,"stats":{"Line":2}},{"line":322,"address":[367749],"length":1,"stats":{"Line":5}},{"line":323,"address":[367917],"length":1,"stats":{"Line":0}},{"line":324,"address":[367867],"length":1,"stats":{"Line":0}},{"line":325,"address":[367895],"length":1,"stats":{"Line":0}},{"line":330,"address":[365041],"length":1,"stats":{"Line":3}},{"line":333,"address":[366987],"length":1,"stats":{"Line":2}},{"line":335,"address":[368035],"length":1,"stats":{"Line":2}},{"line":336,"address":[368174],"length":1,"stats":{"Line":2}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[368222],"length":1,"stats":{"Line":2}},{"line":341,"address":[368054],"length":1,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[368102],"length":1,"stats":{"Line":0}}],"covered":140,"coverable":189},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","declarations.rs"],"content":"use crate::frontend::{ast::*, lexer::token::Token};\n\nuse super::{ParseError, Parser};\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    // TODO: pass loc of string to get true start loc of declaration\n    pub fn parse_variable_declaration(\u0026mut self) -\u003e Result\u003cVariableDeclarationTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"variable declaration\")?;\n\n        let declaration = VariableDeclarationTree {\n            loc: start_loc,\n            name: self.parse_identifier()?,\n            typename: {\n                self.expect_token(Token::Colon)?;\n                self.parse_typename()?\n            },\n        };\n\n        self.finish_parsing(\u0026declaration)?;\n\n        Ok(declaration)\n    }\n\n    pub fn parse_function_declaration_or_definition(\n        \u0026mut self,\n    ) -\u003e Result\u003cTranslationUnit, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"function declaration/definition\")?;\n\n        let prototype = self.parse_function_prototype()?;\n\n        let decl_or_def = match self.parse_function_definition(prototype.clone()) {\n            Ok(definition) =\u003e Ok(TranslationUnit::FunctionDefinition(definition)),\n            Err(_) =\u003e Ok(TranslationUnit::FunctionDeclaration(prototype)),\n        };\n\n        self.finish_parsing(decl_or_def.as_ref().unwrap())?;\n\n        decl_or_def\n    }\n\n    pub fn parse_function_definition(\n        \u0026mut self,\n        prototype: FunctionDeclarationTree,\n    ) -\u003e Result\u003cFunctionDefinitionTree, ParseError\u003e {\n        self.start_parsing(\"function definition\")?;\n\n        let parsed_definition = FunctionDefinitionTree {\n            prototype,\n            body: self.parse_block_expression()?,\n        };\n\n        self.finish_parsing(\u0026parsed_definition)?;\n\n        Ok(parsed_definition)\n    }\n\n    pub fn parse_struct_definition(\u0026mut self) -\u003e Result\u003cTranslationUnit, ParseError\u003e {\n        let start_loc = self.start_parsing(\"struct definition\")?;\n\n        self.expect_token(Token::Struct)?;\n        let struct_name = self.parse_identifier()?;\n        self.expect_token(Token::LCurly)?;\n\n        let mut struct_fields = Vec::new();\n\n        loop {\n            match self.peek_token()? {\n                Token::Identifier(_) =\u003e {\n                    struct_fields.push(self.parse_variable_declaration()?);\n\n                    if matches!(self.peek_token()?, Token::Comma) {\n                        self.next_token()?;\n                    }\n                }\n                Token::RCurly =\u003e {\n                    self.next_token()?;\n                    break;\n                }\n                _ =\u003e {\n                    self.unexpected_token::\u003cTranslationUnit\u003e(\u0026[Token::Identifier(\"\".into())])?;\n                }\n            }\n        }\n\n        let struct_definition = TranslationUnit::StructDefinition(StructDefinitionTree {\n            loc: start_loc,\n            name: struct_name,\n            fields: struct_fields,\n        });\n\n        self.finish_parsing(\u0026struct_definition)?;\n\n        Ok(struct_definition)\n    }\n\n    pub fn parse_implementation(\u0026mut self) -\u003e Result\u003cTranslationUnit, ParseError\u003e {\n        let start_loc = self.start_parsing(\"impl block\")?;\n\n        self.expect_token(Token::Impl)?;\n        let implemented_for = self.parse_typename()?;\n        self.expect_token(Token::LCurly);\n\n        let mut items: Vec\u003cFunctionDefinitionTree\u003e = Vec::new();\n\n        while self.peek_token()? != Token::RCurly {\n            let prototype = self.parse_function_prototype()?;\n            items.push(self.parse_function_definition(prototype)?);\n        }\n\n        let implementation = TranslationUnit::Implementation(ImplementationTree {\n            loc: start_loc,\n            type_name: implemented_for,\n            items,\n        });\n\n        self.finish_parsing(\u0026implementation);\n        Ok(implementation)\n    }\n}\n","traces":[{"line":7,"address":[576480,577813],"length":1,"stats":{"Line":0}},{"line":8,"address":[576510],"length":1,"stats":{"Line":0}},{"line":12,"address":[576675],"length":1,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[577601,577538],"length":1,"stats":{"Line":0}},{"line":21,"address":[577736],"length":1,"stats":{"Line":0}},{"line":24,"address":[579234,577920],"length":1,"stats":{"Line":0}},{"line":27,"address":[577950],"length":1,"stats":{"Line":0}},{"line":29,"address":[578113],"length":1,"stats":{"Line":0}},{"line":31,"address":[578561,578492],"length":1,"stats":{"Line":0}},{"line":32,"address":[578715],"length":1,"stats":{"Line":0}},{"line":33,"address":[578605],"length":1,"stats":{"Line":0}},{"line":36,"address":[578853,578920],"length":1,"stats":{"Line":0}},{"line":38,"address":[579118],"length":1,"stats":{"Line":0}},{"line":41,"address":[580456,580379,579280],"length":1,"stats":{"Line":0}},{"line":45,"address":[580443,579314,579405],"length":1,"stats":{"Line":0}},{"line":49,"address":[579725,579662],"length":1,"stats":{"Line":0}},{"line":52,"address":[580155,580092],"length":1,"stats":{"Line":0}},{"line":54,"address":[580290],"length":1,"stats":{"Line":0}},{"line":57,"address":[582741,584104,580480],"length":1,"stats":{"Line":0}},{"line":58,"address":[580510],"length":1,"stats":{"Line":0}},{"line":60,"address":[580697],"length":1,"stats":{"Line":0}},{"line":61,"address":[580964],"length":1,"stats":{"Line":0}},{"line":62,"address":[584073,581178,581266],"length":1,"stats":{"Line":0}},{"line":64,"address":[581491],"length":1,"stats":{"Line":0}},{"line":66,"address":[581498],"length":1,"stats":{"Line":0}},{"line":67,"address":[581583,581519,584013],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[581860,583597,582783],"length":1,"stats":{"Line":0}},{"line":71,"address":[583044,583592],"length":1,"stats":{"Line":0}},{"line":72,"address":[583332,583587],"length":1,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[581926,582750,581840],"length":1,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[583607,581793],"length":1,"stats":{"Line":0}},{"line":85,"address":[582253],"length":1,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[582173],"length":1,"stats":{"Line":0}},{"line":88,"address":[582213],"length":1,"stats":{"Line":0}},{"line":91,"address":[582494,582431],"length":1,"stats":{"Line":0}},{"line":93,"address":[582629],"length":1,"stats":{"Line":0}},{"line":96,"address":[584144,586706,585777],"length":1,"stats":{"Line":0}},{"line":97,"address":[584174],"length":1,"stats":{"Line":0}},{"line":99,"address":[584363],"length":1,"stats":{"Line":0}},{"line":100,"address":[584630],"length":1,"stats":{"Line":0}},{"line":101,"address":[584876,584956],"length":1,"stats":{"Line":0}},{"line":103,"address":[584971],"length":1,"stats":{"Line":0}},{"line":105,"address":[584978,585060,586652,586600],"length":1,"stats":{"Line":0}},{"line":106,"address":[586635,585799],"length":1,"stats":{"Line":0}},{"line":107,"address":[586397,586605,586197],"length":1,"stats":{"Line":0}},{"line":110,"address":[585427],"length":1,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[585331],"length":1,"stats":{"Line":0}},{"line":113,"address":[585387],"length":1,"stats":{"Line":0}},{"line":116,"address":[585692,585637],"length":1,"stats":{"Line":0}},{"line":117,"address":[585699],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","errors.rs"],"content":"use crate::frontend::{\n    lexer::{token::Token, LexError},\n    sourceloc::SourceLoc,\n};\n\n#[derive(Clone, PartialEq, Eq)]\npub enum ParseError {\n    LexError(LexError),\n    UnexpectedToken(UnexpectedTokenError),\n}\n\nimpl std::fmt::Display for ParseError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::LexError(lex_error) =\u003e write!(f, \"{}\", lex_error),\n            Self::UnexpectedToken(unexpected_token) =\u003e {\n                let mut expected_tokens = String::new();\n                for tok in \u0026unexpected_token.expected {\n                    if expected_tokens.len() \u003e 0 {\n                        expected_tokens += \", \";\n                    }\n\n                    expected_tokens += \u0026format!(\"'{}'\", tok.name());\n                }\n                write!(\n                    f,\n                    \"Unexpected token '{}' at {}, expected one of [{}]\",\n                    unexpected_token.got, unexpected_token.loc, expected_tokens\n                )\n            }\n        }\n    }\n}\n\nimpl std::fmt::Debug for ParseError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct UnexpectedTokenError {\n    pub loc: SourceLoc,\n    pub got: Token,\n    pub expected: Vec\u003cToken\u003e,\n}\n\nimpl ParseError {\n    pub fn unexpected_token(loc: SourceLoc, got: Token, expected: \u0026[Token]) -\u003e Self {\n        Self::UnexpectedToken(UnexpectedTokenError {\n            loc,\n            got,\n            expected: expected.to_vec(),\n        })\n    }\n}\n\nimpl From\u003cLexError\u003e for ParseError {\n    fn from(value: LexError) -\u003e Self {\n        Self::LexError(value)\n    }\n}\n","traces":[{"line":13,"address":[875216,876162],"length":1,"stats":{"Line":0}},{"line":14,"address":[875249],"length":1,"stats":{"Line":0}},{"line":15,"address":[875337],"length":1,"stats":{"Line":0}},{"line":16,"address":[875286],"length":1,"stats":{"Line":0}},{"line":17,"address":[875302],"length":1,"stats":{"Line":0}},{"line":18,"address":[875312,875511],"length":1,"stats":{"Line":0}},{"line":19,"address":[875620,875842],"length":1,"stats":{"Line":0}},{"line":20,"address":[875870],"length":1,"stats":{"Line":0}},{"line":23,"address":[875853,875909],"length":1,"stats":{"Line":0}},{"line":25,"address":[875640],"length":1,"stats":{"Line":0}},{"line":36,"address":[876192],"length":1,"stats":{"Line":0}},{"line":37,"address":[876210],"length":1,"stats":{"Line":0}},{"line":49,"address":[876304,876592],"length":1,"stats":{"Line":1}},{"line":50,"address":[876482],"length":1,"stats":{"Line":2}},{"line":52,"address":[876395],"length":1,"stats":{"Line":2}},{"line":53,"address":[876423],"length":1,"stats":{"Line":2}},{"line":59,"address":[876624],"length":1,"stats":{"Line":0}},{"line":60,"address":[876627],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","expressions.rs"],"content":"use crate::{\n    frontend::{ast::*, lexer::token::Token},\n    midend::ir,\n};\n\nuse super::{ParseError, Parser};\n\n// parsing functions which yield an ExpressionTree\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn parse_block_expression(\u0026mut self) -\u003e Result\u003cCompoundExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"compound statement\")?;\n\n        self.expect_token(Token::LCurly)?;\n        let mut statements: Vec\u003cStatementTree\u003e = Vec::new();\n        loop {\n            match self.peek_token()? {\n                Token::RCurly =\u003e break,\n                _ =\u003e statements.push(self.parse_statement()?),\n            }\n        }\n        self.expect_token(Token::RCurly)?;\n\n        let compound_statement = CompoundExpressionTree {\n            loc: start_loc,\n            statements: statements,\n        };\n\n        self.finish_parsing(\u0026compound_statement)?;\n\n        Ok(compound_statement)\n    }\n\n    pub fn expression_starters() -\u003e [Token; 5] {\n        [\n            Token::If,\n            Token::While,\n            Token::Identifier(\"\".into()),\n            Token::UnsignedDecimalConstant(0),\n            Token::LParen,\n        ]\n    }\n\n    pub fn token_starts_expression(t: Token) -\u003e bool {\n        match t {\n            Token::If\n            | Token::While\n            | Token::Identifier(_)\n            | Token::UnsignedDecimalConstant(0)\n            | Token::LParen =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn parse_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"expression\")?;\n\n        assert!(Self::token_starts_expression(self.peek_token()?)); // sanity-check this method call to self-validate\n\n        let mut expr = match self.peek_token()? {\n            Token::If =\u003e self.parse_if_expression()?,\n            Token::While =\u003e self.parse_while_expression()?,\n            Token::Identifier(_) =\u003e self.parse_identifier_expression()?,\n            Token::UnsignedDecimalConstant(_) =\u003e self.parse_literal_expression()?,\n            Token::LParen =\u003e self.parse_parenthesized_expression()?,\n            _ =\u003e self.unexpected_token(\u0026[\n                Token::If,\n                Token::While,\n                Token::Identifier(\"\".into()),\n                Token::UnsignedDecimalConstant(0),\n                Token::LParen,\n            ])?,\n        };\n\n        match self.peek_token()? {\n            Token::Dot =\u003e {\n                if matches!(self.lookahead_token(2)?, Token::LParen) {\n                    expr = self.parse_method_call_expression(expr)?;\n                } else {\n                    expr = self.parse_field_expression(expr)?;\n                }\n            }\n            _ =\u003e {}\n        }\n\n        let peeked = self.peek_token()?;\n        match peeked {\n            Token::Plus\n            | Token::Minus\n            | Token::Star\n            | Token::FSlash\n            | Token::LThan\n            | Token::GThan\n            | Token::LThanE\n            | Token::GThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e {\n                let lhs = expr;\n                expr = self.parse_binary_expression_min_precedence(lhs, 0)?\n            }\n\n            _ =\u003e {\n                #[cfg(feature = \"loud_parsing\")]\n                println!(\"Peeked {} after lhs {} of expression\", peeked, expr);\n            }\n        }\n\n        match self.peek_token()? {\n            Token::Assign =\u003e {\n                expr = self.parse_assignment_expression(expr)?;\n            }\n            _ =\u003e {}\n        }\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_parenthesized_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"parenthesized expression\")?;\n\n        self.expect_token(Token::LParen)?;\n        let parenthesized_expr = self.parse_expression()?;\n        self.expect_token(Token::RParen)?;\n\n        self.finish_parsing(\u0026parenthesized_expr)?;\n        Ok(parenthesized_expr)\n    }\n\n    pub fn parse_if_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"if statement\")?;\n\n        self.expect_token(Token::If)?;\n\n        self.expect_token(Token::LParen)?;\n        let condition: ExpressionTree = self.parse_expression()?;\n        self.expect_token(Token::RParen)?;\n\n        let true_block = self.parse_block_expression()?;\n        let false_block = match self.peek_token()? {\n            Token::Else =\u003e {\n                self.next_token()?;\n                Some(self.parse_block_expression()?)\n            }\n            _ =\u003e None,\n        };\n\n        let if_expression = ExpressionTree {\n            loc: start_loc,\n            expression: Expression::If(Box::new(IfExpressionTree {\n                loc: start_loc,\n                condition,\n                true_block,\n                false_block,\n            })),\n        };\n\n        self.finish_parsing(\u0026if_expression)?;\n\n        Ok(if_expression)\n    }\n\n    pub fn parse_while_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"while loop\")?;\n\n        self.expect_token(Token::While)?;\n\n        self.expect_token(Token::LParen)?;\n        let condition = self.parse_expression()?;\n        self.expect_token(Token::RParen)?;\n\n        let body = self.parse_block_expression()?;\n\n        let while_loop = WhileExpressionTree {\n            loc: start_loc,\n            condition,\n            body,\n        };\n\n        self.finish_parsing(\u0026while_loop)?;\n\n        Ok(ExpressionTree {\n            loc: start_loc,\n            expression: Expression::While(Box::from(while_loop)),\n        })\n    }\n\n    pub fn parse_method_call_expression(\n        \u0026mut self,\n        lhs: ExpressionTree,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\"method call expression\")?;\n        self.expect_token(Token::Dot)?;\n\n        let expr = ExpressionTree {\n            loc: lhs.loc,\n            expression: Expression::MethodCall(Box::from(MethodCallExpressionTree {\n                loc: lhs.loc,\n                receiver: lhs,\n                called_method: self.parse_identifier()?,\n                params: self.parse_call_params(true)?,\n            })),\n        };\n\n        self.finish_parsing(\u0026expr)?;\n        Ok(expr)\n    }\n\n    pub fn parse_field_expression(\n        \u0026mut self,\n        lhs: ExpressionTree,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\"field expression\")?;\n\n        self.expect_token(Token::Dot)?;\n        let expr = ExpressionTree {\n            loc: lhs.loc,\n            expression: Expression::FieldExpression(Box::from(FieldExpressionTree {\n                loc: lhs.loc,\n                receiver: lhs,\n                field: self.parse_identifier()?,\n            })),\n        };\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_call_params(\u0026mut self, allow_self: bool) -\u003e Result\u003cCallParamsTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"call params\")?;\n\n        let mut params = Vec::new();\n\n        self.expect_token(Token::LParen)?;\n        while !matches!(self.peek_token()?, Token::RParen) {\n            if Self::token_starts_expression(self.peek_token()?) {\n                params.push(self.parse_expression()?);\n            } else {\n                self.unexpected_token(\u0026Self::expression_starters())?;\n            }\n        }\n        self.expect_token(Token::RParen)?;\n\n        let params_tree = CallParamsTree {\n            loc: start_loc,\n            params,\n        };\n\n        self.finish_parsing(\u0026params_tree)?;\n\n        Ok(params_tree)\n    }\n\n    pub fn parse_assignment_expression(\n        \u0026mut self,\n        lhs: ExpressionTree,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\"assignment (rhs)\")?;\n\n        self.expect_token(Token::Assign)?;\n\n        let rhs = self.parse_expression()?;\n\n        let assignment = ExpressionTree {\n            loc: lhs.loc.clone(),\n            expression: Expression::Assignment(AssignmentTree {\n                loc: lhs.loc.clone(),\n                assignee: Box::from(lhs),\n                value: Box::from(rhs),\n            }),\n        };\n\n        self.finish_parsing(\u0026assignment)?;\n\n        Ok(assignment)\n    }\n\n    pub fn parse_binary_expression_min_precedence(\n        \u0026mut self,\n        lhs: ExpressionTree,\n        min_precedence: usize,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\u0026format!(\"expression (min precedence: {})\", min_precedence))?;\n        let start_loc = lhs.loc;\n\n        let mut expr = lhs;\n        while Self::token_is_operator_of_at_least_precedence(\u0026self.peek_token()?, min_precedence) {\n            let operation = self.next_token()?;\n            let mut rhs = self.parse_primary_expression()?;\n\n            while Self::token_is_operator_of_at_least_precedence(\n                \u0026self.peek_token()?,\n                ir::BinaryOperations::precedence_of_token(\u0026operation),\n            ) {\n                rhs = self.parse_binary_expression_min_precedence(\n                    rhs,\n                    ir::BinaryOperations::precedence_of_token(\u0026operation),\n                )?;\n            }\n\n            let operands = ArithmeticDualOperands {\n                e1: Box::new(expr),\n                e2: Box::new(rhs),\n            };\n            expr = ExpressionTree {\n                loc: start_loc,\n                expression: match operation {\n                    Token::Plus =\u003e Expression::Arithmetic(ArithmeticExpressionTree::Add(operands)),\n                    Token::Minus =\u003e {\n                        Expression::Arithmetic(ArithmeticExpressionTree::Subtract(operands))\n                    }\n                    Token::Star =\u003e {\n                        Expression::Arithmetic(ArithmeticExpressionTree::Multiply(operands))\n                    }\n                    Token::FSlash =\u003e {\n                        Expression::Arithmetic(ArithmeticExpressionTree::Divide(operands))\n                    }\n                    Token::LThan =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::LThan(operands))\n                    }\n                    Token::GThan =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::GThan(operands))\n                    }\n                    Token::LThanE =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::LThanE(operands))\n                    }\n                    Token::GThanE =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::GThanE(operands))\n                    }\n                    Token::Equals =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::Equals(operands))\n                    }\n                    Token::NotEquals =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::NotEquals(operands))\n                    }\n                    _ =\u003e self.unexpected_token(\u0026[\n                        Token::Plus,\n                        Token::Minus,\n                        Token::Star,\n                        Token::FSlash,\n                        Token::LThan,\n                        Token::GThan,\n                        Token::LThanE,\n                        Token::GThanE,\n                        Token::Equals,\n                        Token::NotEquals,\n                    ])?,\n                },\n            };\n        }\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_primary_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"primary expression\")?;\n\n        let primary_expression = ExpressionTree {\n            loc: start_loc,\n            expression: {\n                match self.peek_token()? {\n                    Token::Identifier(value) =\u003e {\n                        self.next_token()?;\n                        Expression::Identifier(value)\n                    }\n                    Token::UnsignedDecimalConstant(value) =\u003e {\n                        self.next_token()?;\n                        Expression::UnsignedDecimalConstant(value)\n                    }\n                    Token::LParen =\u003e {\n                        self.next_token()?;\n                        let expr = self.parse_expression()?;\n                        self.expect_token(Token::RParen)?;\n                        expr.expression\n                    } // TODO: don't duplciate ExpressionTree here\n                    _ =\u003e self.unexpected_token(\u0026[\n                        Token::Identifier(\"\".into()),\n                        Token::UnsignedDecimalConstant(0),\n                        Token::LParen,\n                    ])?,\n                }\n            },\n        };\n\n        self.finish_parsing(\u0026primary_expression)?;\n\n        Ok(primary_expression)\n    }\n\n    pub fn parse_identifier_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"identifier expression\")?;\n\n        let expr = ExpressionTree {\n            loc: start_loc,\n            expression: Expression::Identifier(self.parse_identifier()?),\n        };\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_literal_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"literal expression\")?;\n\n        let expr = ExpressionTree {\n            loc: start_loc,\n            expression: match self.peek_token()? {\n                Token::UnsignedDecimalConstant(value) =\u003e {\n                    self.next_token()?;\n                    Expression::UnsignedDecimalConstant(value)\n                }\n                _ =\u003e self.unexpected_token(\u0026[Token::UnsignedDecimalConstant(0)])?,\n            },\n        };\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n}\n","traces":[{"line":10,"address":[588276,586736,588676],"length":1,"stats":{"Line":0}},{"line":11,"address":[586766],"length":1,"stats":{"Line":0}},{"line":13,"address":[586938],"length":1,"stats":{"Line":0}},{"line":14,"address":[587200],"length":1,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[588643,587234,587298],"length":1,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[587545,588343],"length":1,"stats":{"Line":0}},{"line":21,"address":[587570,588285],"length":1,"stats":{"Line":0}},{"line":28,"address":[588015,587952],"length":1,"stats":{"Line":0}},{"line":30,"address":[588150],"length":1,"stats":{"Line":0}},{"line":33,"address":[589079,588704,589058],"length":1,"stats":{"Line":0}},{"line":35,"address":[588731],"length":1,"stats":{"Line":0}},{"line":36,"address":[588746],"length":1,"stats":{"Line":0}},{"line":37,"address":[588751,588826],"length":1,"stats":{"Line":0}},{"line":38,"address":[588856],"length":1,"stats":{"Line":0}},{"line":39,"address":[588883],"length":1,"stats":{"Line":0}},{"line":43,"address":[589104],"length":1,"stats":{"Line":0}},{"line":44,"address":[589112,589227],"length":1,"stats":{"Line":0}},{"line":45,"address":[589216],"length":1,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[589209],"length":1,"stats":{"Line":0}},{"line":54,"address":[595012,589264,593332],"length":1,"stats":{"Line":0}},{"line":55,"address":[589309],"length":1,"stats":{"Line":0}},{"line":57,"address":[589472],"length":1,"stats":{"Line":0}},{"line":59,"address":[589696],"length":1,"stats":{"Line":0}},{"line":60,"address":[590198,590040,590415],"length":1,"stats":{"Line":0}},{"line":61,"address":[590063,590451],"length":1,"stats":{"Line":0}},{"line":62,"address":[590901,590109],"length":1,"stats":{"Line":0}},{"line":63,"address":[590132,591126],"length":1,"stats":{"Line":0}},{"line":64,"address":[590086,590676],"length":1,"stats":{"Line":0}},{"line":65,"address":[591704,591460,591817],"length":1,"stats":{"Line":0}},{"line":66,"address":[589967],"length":1,"stats":{"Line":0}},{"line":67,"address":[589985],"length":1,"stats":{"Line":0}},{"line":68,"address":[591380,589993],"length":1,"stats":{"Line":0}},{"line":69,"address":[591412],"length":1,"stats":{"Line":0}},{"line":70,"address":[591452],"length":1,"stats":{"Line":0}},{"line":74,"address":[592050,594982],"length":1,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[592391,593298,592310,592958,593308],"length":1,"stats":{"Line":0}},{"line":77,"address":[592648,592963],"length":1,"stats":{"Line":0}},{"line":79,"address":[592988,593303],"length":1,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[593354,594977],"length":1,"stats":{"Line":0}},{"line":86,"address":[593524],"length":1,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[593601],"length":1,"stats":{"Line":0}},{"line":98,"address":[593693,593756,593960],"length":1,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[593586,593996,594972],"length":1,"stats":{"Line":0}},{"line":108,"address":[594588],"length":1,"stats":{"Line":0}},{"line":109,"address":[594220,594389],"length":1,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[594632,594967],"length":1,"stats":{"Line":0}},{"line":116,"address":[594798],"length":1,"stats":{"Line":0}},{"line":119,"address":[595088,596391],"length":1,"stats":{"Line":0}},{"line":120,"address":[595117],"length":1,"stats":{"Line":0}},{"line":122,"address":[595271],"length":1,"stats":{"Line":0}},{"line":123,"address":[595537],"length":1,"stats":{"Line":0}},{"line":124,"address":[595806,595893,596389],"length":1,"stats":{"Line":0}},{"line":126,"address":[596130,596372],"length":1,"stats":{"Line":0}},{"line":127,"address":[596288],"length":1,"stats":{"Line":0}},{"line":130,"address":[598946,596416,599935],"length":1,"stats":{"Line":0}},{"line":131,"address":[596446],"length":1,"stats":{"Line":0}},{"line":133,"address":[596635],"length":1,"stats":{"Line":0}},{"line":135,"address":[596902],"length":1,"stats":{"Line":0}},{"line":136,"address":[597169],"length":1,"stats":{"Line":0}},{"line":137,"address":[597535,599908,597447],"length":1,"stats":{"Line":0}},{"line":139,"address":[597765,599894],"length":1,"stats":{"Line":0}},{"line":140,"address":[598043,599846,598107],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[598917,598433,598339],"length":1,"stats":{"Line":0}},{"line":143,"address":[598663,598900],"length":1,"stats":{"Line":0}},{"line":145,"address":[598346],"length":1,"stats":{"Line":0}},{"line":150,"address":[599190],"length":1,"stats":{"Line":0}},{"line":158,"address":[599504,599567],"length":1,"stats":{"Line":0}},{"line":160,"address":[599702],"length":1,"stats":{"Line":0}},{"line":163,"address":[602461,602532,599968],"length":1,"stats":{"Line":0}},{"line":164,"address":[599998],"length":1,"stats":{"Line":0}},{"line":166,"address":[600187],"length":1,"stats":{"Line":0}},{"line":168,"address":[600454],"length":1,"stats":{"Line":0}},{"line":169,"address":[600721],"length":1,"stats":{"Line":0}},{"line":170,"address":[600999,601087,602502],"length":1,"stats":{"Line":0}},{"line":172,"address":[601317,602488],"length":1,"stats":{"Line":0}},{"line":180,"address":[601941,601877],"length":1,"stats":{"Line":0}},{"line":182,"address":[602252],"length":1,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[602079],"length":1,"stats":{"Line":0}},{"line":188,"address":[602560,604383,604593],"length":1,"stats":{"Line":0}},{"line":192,"address":[602692,604573,602595],"length":1,"stats":{"Line":0}},{"line":193,"address":[602859,604568],"length":1,"stats":{"Line":0}},{"line":196,"address":[603133],"length":1,"stats":{"Line":0}},{"line":197,"address":[603770],"length":1,"stats":{"Line":0}},{"line":205,"address":[604070,604133],"length":1,"stats":{"Line":0}},{"line":206,"address":[604268],"length":1,"stats":{"Line":0}},{"line":209,"address":[606092,606172,604624],"length":1,"stats":{"Line":0}},{"line":213,"address":[604756,606158,604659],"length":1,"stats":{"Line":0}},{"line":215,"address":[606156,604923],"length":1,"stats":{"Line":0}},{"line":217,"address":[605197],"length":1,"stats":{"Line":0}},{"line":218,"address":[605531],"length":1,"stats":{"Line":0}},{"line":225,"address":[605783,605846],"length":1,"stats":{"Line":0}},{"line":227,"address":[605981],"length":1,"stats":{"Line":0}},{"line":230,"address":[608555,606208,607768],"length":1,"stats":{"Line":0}},{"line":231,"address":[606249],"length":1,"stats":{"Line":0}},{"line":233,"address":[606417],"length":1,"stats":{"Line":0}},{"line":235,"address":[606541,608522,606453],"length":1,"stats":{"Line":0}},{"line":236,"address":[606771,608517],"length":1,"stats":{"Line":0}},{"line":237,"address":[607792,608512],"length":1,"stats":{"Line":0}},{"line":238,"address":[607987,608273],"length":1,"stats":{"Line":0}},{"line":240,"address":[607967,608023],"length":1,"stats":{"Line":0}},{"line":243,"address":[607061,607777],"length":1,"stats":{"Line":0}},{"line":250,"address":[607444,607507],"length":1,"stats":{"Line":0}},{"line":252,"address":[607642],"length":1,"stats":{"Line":0}},{"line":255,"address":[608592,610404,610347],"length":1,"stats":{"Line":0}},{"line":259,"address":[610390,608627,608732],"length":1,"stats":{"Line":0}},{"line":261,"address":[608908,610388],"length":1,"stats":{"Line":0}},{"line":263,"address":[609185,610374],"length":1,"stats":{"Line":0}},{"line":266,"address":[609487],"length":1,"stats":{"Line":0}},{"line":267,"address":[609868],"length":1,"stats":{"Line":0}},{"line":274,"address":[610032,610095],"length":1,"stats":{"Line":0}},{"line":276,"address":[610230],"length":1,"stats":{"Line":0}},{"line":279,"address":[615156,614548,610432],"length":1,"stats":{"Line":0}},{"line":284,"address":[615122,610585,610472],"length":1,"stats":{"Line":0}},{"line":285,"address":[610990],"length":1,"stats":{"Line":0}},{"line":287,"address":[611024],"length":1,"stats":{"Line":0}},{"line":288,"address":[615059,611135,611071],"length":1,"stats":{"Line":0}},{"line":289,"address":[615054,611702],"length":1,"stats":{"Line":0}},{"line":290,"address":[612003,611940,615052],"length":1,"stats":{"Line":0}},{"line":292,"address":[614960,612502],"length":1,"stats":{"Line":0}},{"line":293,"address":[614988,612218,612282],"length":1,"stats":{"Line":0}},{"line":294,"address":[612437],"length":1,"stats":{"Line":0}},{"line":296,"address":[614965,614874,614761,614706],"length":1,"stats":{"Line":0}},{"line":297,"address":[614557],"length":1,"stats":{"Line":0}},{"line":298,"address":[614645],"length":1,"stats":{"Line":0}},{"line":303,"address":[612556],"length":1,"stats":{"Line":0}},{"line":304,"address":[612661],"length":1,"stats":{"Line":0}},{"line":306,"address":[614110],"length":1,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[612830],"length":1,"stats":{"Line":0}},{"line":309,"address":[612938],"length":1,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[613055],"length":1,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[613172],"length":1,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[613289],"length":1,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[613406],"length":1,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[613523],"length":1,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[613640],"length":1,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[613757],"length":1,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[613874],"length":1,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[613988],"length":1,"stats":{"Line":0}},{"line":337,"address":[612908,614261,614374],"length":1,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[611410,611668],"length":1,"stats":{"Line":0}},{"line":355,"address":[611568],"length":1,"stats":{"Line":0}},{"line":358,"address":[615184,616940,618501],"length":1,"stats":{"Line":0}},{"line":359,"address":[615214],"length":1,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[618267,618185],"length":1,"stats":{"Line":0}},{"line":390,"address":[618402],"length":1,"stats":{"Line":0}},{"line":393,"address":[618608,619398],"length":1,"stats":{"Line":0}},{"line":394,"address":[618638],"length":1,"stats":{"Line":0}},{"line":398,"address":[618803],"length":1,"stats":{"Line":0}},{"line":401,"address":[619101,619164],"length":1,"stats":{"Line":0}},{"line":403,"address":[619299],"length":1,"stats":{"Line":0}},{"line":406,"address":[620898,619424],"length":1,"stats":{"Line":0}},{"line":407,"address":[619454],"length":1,"stats":{"Line":0}},{"line":411,"address":[619619],"length":1,"stats":{"Line":0}},{"line":420,"address":[620641],"length":1,"stats":{"Line":0}},{"line":422,"address":[620799],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":199},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","single_token.rs"],"content":"use crate::{\n    frontend::{ast::*, lexer::token::Token},\n    midend::types::{Mutability, Type},\n};\n\nuse super::{ParseError, Parser};\n\n// parsing functions which only consume a single token\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn parse_identifier(\u0026mut self) -\u003e Result\u003cString, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"identifier\")?;\n\n        let identifier = match self.expect_token(Token::Identifier(String::from(\"\")))? {\n            Token::Identifier(value) =\u003e value,\n            _ =\u003e self.unexpected_token::\u003cString\u003e(\u0026[Token::Identifier(\"\".into())])?,\n        };\n\n        self.finish_parsing(\u0026identifier)?;\n\n        Ok(identifier)\n    }\n\n    pub fn parse_typename(\u0026mut self) -\u003e Result\u003cTypenameTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"typename\")?;\n\n        let typename = TypenameTree {\n            loc: start_loc,\n            type_: self.parse_type()?,\n        };\n\n        self.finish_parsing(\u0026typename)?;\n\n        Ok(typename)\n    }\n\n    pub fn parse_type(\u0026mut self) -\u003e Result\u003cType, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"type\")?;\n\n        let type_ = match self.peek_token()? {\n            Token::U8 =\u003e {\n                self.next_token()?;\n                Type::U8\n            }\n            Token::U16 =\u003e {\n                self.next_token()?;\n                Type::U16\n            }\n            Token::U32 =\u003e {\n                self.next_token()?;\n                Type::U32\n            }\n            Token::U64 =\u003e {\n                self.next_token()?;\n                Type::U64\n            }\n            Token::I8 =\u003e {\n                self.next_token()?;\n                Type::I8\n            }\n            Token::I16 =\u003e {\n                self.next_token()?;\n                Type::I16\n            }\n            Token::I32 =\u003e {\n                self.next_token()?;\n                Type::I32\n            }\n            Token::I64 =\u003e {\n                self.next_token()?;\n                Type::I64\n            }\n            Token::Identifier(name) =\u003e {\n                self.next_token()?;\n                Type::UDT(name)\n            }\n            Token::SelfUpper =\u003e {\n                self.next_token()?;\n                Type::Self_\n            }\n            Token::Reference =\u003e {\n                self.next_token()?;\n                Type::Reference(\n                    match self.peek_token()? {\n                        Token::Mut =\u003e {\n                            self.expect_token(Token::Mut)?;\n                            Mutability::Mutable\n                        }\n                        _ =\u003e Mutability::Immutable,\n                    },\n                    Box::from(self.parse_type()?),\n                )\n            }\n            _ =\u003e self.unexpected_token(\u0026[\n                Token::U8,\n                Token::U16,\n                Token::U32,\n                Token::U64,\n                Token::I8,\n                Token::I16,\n                Token::I32,\n                Token::I64,\n                Token::Identifier(\"\".into()),\n                Token::SelfUpper,\n            ])?,\n        };\n        self.finish_parsing(\u0026type_);\n\n        Ok(type_)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::frontend::{\n        lexer::{token::Token, Lexer},\n        parser::{ParseError, Parser},\n        sourceloc::SourceLoc,\n    };\n\n    #[test]\n    fn parse_identifier() {\n        let mut p = Parser::new(Lexer::from_string(\"my_identifier\"));\n        assert_eq!(p.parse_identifier(), Ok(\"my_identifier\".into()));\n    }\n\n    #[test]\n    fn parse_identifier_error() {\n        let mut p = Parser::new(Lexer::from_string(\"struct\"));\n        assert_eq!(\n            p.parse_identifier(),\n            Err(ParseError::unexpected_token(\n                SourceLoc::new(1, 1),\n                Token::Struct,\n                \u0026[Token::Identifier(\"\".into())]\n            ))\n        );\n    }\n}\n","traces":[{"line":10,"address":[622460,620928],"length":1,"stats":{"Line":2}},{"line":11,"address":[620958],"length":1,"stats":{"Line":2}},{"line":13,"address":[621116],"length":1,"stats":{"Line":1}},{"line":14,"address":[621470],"length":1,"stats":{"Line":1}},{"line":15,"address":[621576,622490,621701],"length":1,"stats":{"Line":0}},{"line":18,"address":[622108,622194],"length":1,"stats":{"Line":2}},{"line":20,"address":[622334],"length":1,"stats":{"Line":1}},{"line":23,"address":[622528,623258],"length":1,"stats":{"Line":0}},{"line":24,"address":[622558],"length":1,"stats":{"Line":0}},{"line":28,"address":[622723],"length":1,"stats":{"Line":0}},{"line":31,"address":[622961,623024],"length":1,"stats":{"Line":0}},{"line":33,"address":[623159],"length":1,"stats":{"Line":0}},{"line":36,"address":[627851,623280,629224],"length":1,"stats":{"Line":0}},{"line":37,"address":[623325],"length":1,"stats":{"Line":0}},{"line":39,"address":[623488],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[624597,624313,623946],"length":1,"stats":{"Line":0}},{"line":42,"address":[624530],"length":1,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[624664,624901,623969],"length":1,"stats":{"Line":0}},{"line":46,"address":[624878],"length":1,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[623992,625159,624922],"length":1,"stats":{"Line":0}},{"line":50,"address":[625136],"length":1,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[624015,625180,625417],"length":1,"stats":{"Line":0}},{"line":54,"address":[625394],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[624038,625438,625675],"length":1,"stats":{"Line":0}},{"line":58,"address":[625652],"length":1,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[625696,625933,624061],"length":1,"stats":{"Line":0}},{"line":62,"address":[625910],"length":1,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[625954,624084,626191],"length":1,"stats":{"Line":0}},{"line":66,"address":[626168],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[626449,624107,626212],"length":1,"stats":{"Line":0}},{"line":70,"address":[626426],"length":1,"stats":{"Line":0}},{"line":72,"address":[624168],"length":1,"stats":{"Line":0}},{"line":73,"address":[624216,627930],"length":1,"stats":{"Line":0}},{"line":74,"address":[628147],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[624130,626470,626707],"length":1,"stats":{"Line":0}},{"line":78,"address":[626684],"length":1,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[624153,627865,626728],"length":1,"stats":{"Line":0}},{"line":83,"address":[626958,627860],"length":1,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[627215,627315,627557],"length":1,"stats":{"Line":0}},{"line":86,"address":[627529],"length":1,"stats":{"Line":0}},{"line":88,"address":[627246],"length":1,"stats":{"Line":0}},{"line":90,"address":[627550,627846,627593],"length":1,"stats":{"Line":0}},{"line":93,"address":[628365,628769,628882],"length":1,"stats":{"Line":0}},{"line":94,"address":[623765],"length":1,"stats":{"Line":0}},{"line":95,"address":[623783],"length":1,"stats":{"Line":0}},{"line":96,"address":[623801],"length":1,"stats":{"Line":0}},{"line":97,"address":[623819],"length":1,"stats":{"Line":0}},{"line":98,"address":[623837],"length":1,"stats":{"Line":0}},{"line":99,"address":[623855],"length":1,"stats":{"Line":0}},{"line":100,"address":[623873],"length":1,"stats":{"Line":0}},{"line":101,"address":[623891],"length":1,"stats":{"Line":0}},{"line":102,"address":[623899,628315],"length":1,"stats":{"Line":0}},{"line":103,"address":[628357],"length":1,"stats":{"Line":0}},{"line":106,"address":[629028,629102],"length":1,"stats":{"Line":0}},{"line":108,"address":[629114],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":66},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","tests_old.rs"],"content":"use crate::frontend::ast::*;\nuse crate::frontend::lexer::{token::Token, *};\nuse crate::frontend::sourceloc::SourceLoc;\nuse crate::midend::types::Type;\nuse crate::Parser;\n\n#[cfg(test)]\nfn parser_from_string\u003c'a\u003e(input: \u0026'a str) -\u003e Parser\u003c'a\u003e {\n    Parser::new(Lexer::from_string(input))\n}\n\n/// Expressions\n#[cfg(test)]\nfn parse_and_print_expression(input: \u0026str) -\u003e String {\n    let mut parser = parser_from_string(input);\n    let expr_string = parser.parse_expression().expect(\"\").to_string();\n    let _ = parser.expect_token(Token::Eof);\n    expr_string\n}\n\n#[test]\nfn basic_expression() {\n    assert_eq!(\n        parse_and_print_expression(\"123 + 456 + 789\"),\n        \"(123 + (456 + 789))\"\n    );\n}\n\n#[test]\nfn addition_and_multiplication() {\n    assert_eq!(\n        parse_and_print_expression(\"123 + 456 * 789\"),\n        \"(123 + (456 * 789))\"\n    );\n}\n\n#[test]\nfn parentheses_override_precedence() {\n    assert_eq!(\n        parse_and_print_expression(\"(123 + 456) * 789\"),\n        \"((123 + 456) * 789)\"\n    );\n}\n\n#[test]\nfn mixed_arithmetic_operations() {\n    assert_eq!(\n        parse_and_print_expression(\"1 + 2 * 3 - 4 / 5\"),\n        \"(1 + ((2 * 3) - (4 / 5)))\"\n    );\n}\n\n#[test]\nfn nested_parentheses() {\n    assert_eq!(\n        parse_and_print_expression(\"((1 + 2) * (3 - 4)) / 5\"),\n        \"(((1 + 2) * (3 - 4)) / 5)\"\n    );\n}\n\n#[test]\nfn single_number() {\n    assert_eq!(parse_and_print_expression(\"42\"), \"42\");\n}\n\n#[test]\nfn single_number_parenthesized() {\n    assert_eq!(parse_and_print_expression(\"(42)\"), \"42\");\n}\n\n#[test]\nfn multiple_additions() {\n    assert_eq!(parse_and_print_expression(\"1 + 2 + 3\"), \"(1 + (2 + 3))\");\n}\n\n#[test]\nfn complex_arithmetic_expression() {\n    assert_eq!(\n        parse_and_print_expression(\"3 + 4 * 2 / (1 - 5)\"),\n        \"(3 + (4 * (2 / (1 - 5))))\"\n    );\n}\n\n/// variable declarations\n#[cfg(test)]\nfn parse_and_print_variable_declaration(input: \u0026str) -\u003e String {\n    let mut parser = parser_from_string(input);\n    let expr_string = parser.parse_variable_declaration().expect(\"\").to_string();\n    let _ = parser.expect_token(Token::Eof);\n    expr_string\n}\n\n#[test]\nfn u8_declaration() {\n    assert_eq!(parse_and_print_variable_declaration(\"abc: u8\"), \"abc: u8\");\n}\n\n#[test]\nfn if_expression() {\n    let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;}\");\n    assert_eq!(\n        format!(\"{}\", p.parse_if_expression().expect(\"\")),\n        \"if (a \u003e b)\n\\t{Compound Expression: a = (a + b)\n}\"\n    );\n}\n\n#[test]\nfn if_else_expression() {\n    let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;} else {b = b + a;}\");\n    assert_eq!(\n        format!(\"{}\", p.parse_if_expression().expect(\"\")),\n        \"if (a \u003e b)\n\\t{Compound Expression: a = (a + b)\n} else {Compound Expression: b = (b + a)\n}\"\n    );\n}\n\n#[test]\nfn while_loop() {\n    let mut p = parser_from_string(\"while (a \u003e b) {b = b + a; count = count + 1;} a = a + count;\");\n    assert_eq!(\n        format!(\"{}\", p.parse_while_expression().expect(\"\")),\n        \"while ((a \u003e b)) Compound Expression: b = (b + a)\ncount = (count + 1)\n\"\n    );\n}\n\n#[test]\nfn struct_definition() {\n    let mut p = parser_from_string(\"struct money{\\ndollars: u64,\\ncents: u8\\n}\");\n\n    assert_eq!(\n        p.parse_struct_definition().expect(\"\"),\n        TranslationUnit::StructDefinition(StructDefinitionTree {\n            loc: SourceLoc::new(1, 1),\n            name: \"money\".into(),\n            fields: vec![\n                VariableDeclarationTree {\n                    loc: SourceLoc::new(2, 1),\n                    name: \"dollars\".into(),\n                    typename: TypenameTree {\n                        loc: SourceLoc::new(2, 10),\n                        type_: Type::U64\n                    }\n                },\n                VariableDeclarationTree {\n                    loc: SourceLoc::new(3, 1),\n                    name: \"cents\".into(),\n                    typename: TypenameTree {\n                        loc: SourceLoc::new(3, 8),\n                        type_: Type::U8\n                    }\n                }\n            ]\n        })\n    )\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser.rs"],"content":"// #[cfg(test)]\n// mod tests_old;\n\nuse std::collections::VecDeque;\n\nuse crate::midend::ir;\nuse crate::midend::types::Type;\n\nuse super::{\n    ast::*,\n    lexer::{token::Token, *},\n    sourceloc::SourceLoc,\n};\n\nmod declarations;\nmod errors;\nmod expressions;\nmod single_token;\n\npub use errors::ParseError;\n\npub struct Parser\u003c'a\u003e {\n    lexer: Lexer\u003c'a\u003e,\n    last_match: SourceLoc,\n    upcoming_tokens: VecDeque\u003c(Token, SourceLoc)\u003e,\n    parsing_stack: Vec\u003c(SourceLoc, String)\u003e,\n}\n\nimpl ir::BinaryOperations {\n    pub fn get_precedence(\u0026self) -\u003e usize {\n        match self {\n            Self::Add(_) =\u003e 1,\n            Self::Subtract(_) =\u003e 1,\n            Self::Multiply(_) =\u003e 2,\n            Self::Divide(_) =\u003e 2,\n            Self::LThan(_) =\u003e 3,\n            Self::GThan(_) =\u003e 3,\n            Self::LThanE(_) =\u003e 3,\n            Self::GThanE(_) =\u003e 3,\n            Self::Equals(_) =\u003e 4,\n            Self::NotEquals(_) =\u003e 4,\n        }\n    }\n\n    pub fn precedence_of_token(token: \u0026Token) -\u003e usize {\n        match token {\n            Token::Plus =\u003e 1,\n            Token::Minus =\u003e 1,\n            Token::Star =\u003e 2,\n            Token::FSlash =\u003e 2,\n            Token::LThan =\u003e 3,\n            Token::GThan =\u003e 3,\n            Token::LThanE =\u003e 3,\n            Token::GThanE =\u003e 3,\n            Token::Equals =\u003e 4,\n            Token::NotEquals =\u003e 4,\n            _ =\u003e {\n                panic!(\n                    \"Invalid token {} passed to BinaryOperations::precedence_of_token\",\n                    token\n                );\n            }\n        }\n    }\n}\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn new(lexer: Lexer\u003c'a\u003e) -\u003e Self {\n        let lexer_start_pos = lexer.current_loc();\n        Parser {\n            lexer: lexer,\n            last_match: lexer_start_pos,\n            upcoming_tokens: VecDeque::new(),\n            parsing_stack: Vec::new(),\n        }\n    }\n\n    fn ensure_n_tokens_in_lookahead(\u0026mut self, n: usize) -\u003e Result\u003c(), LexError\u003e {\n        while self.upcoming_tokens.len() \u003c= n \u0026\u0026 self.lexer.peek()?.0 != Token::Eof {\n            self.upcoming_tokens.push_back(self.lexer.next()?);\n        }\n\n        Ok(())\n    }\n\n    // return the next token from the input stream without advancing\n    // utilizes lookahead_token\n    fn peek_token(\u0026mut self) -\u003e Result\u003cToken, LexError\u003e {\n        // FIXME: since lookahead_token_with_loc always unwrap_or's, it can never return an error.\n        match self.peek_token_with_loc() {\n            Ok((token, _)) =\u003e Ok(token),\n            Err(e) =\u003e Err(e),\n        }\n    }\n\n    fn peek_token_with_loc(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        let peeked = self.lookahead_token_with_loc(0)?;\n        // #[cfg(feature = \"loud_parsing\")]\n        // println!(\"Parser::peek_token() -\u003e {}\", peeked);\n        return Ok(peeked);\n    }\n\n    fn lookahead_token(\u0026mut self, lookahead_by: usize) -\u003e Result\u003cToken, LexError\u003e {\n        match self.lookahead_token_with_loc(lookahead_by) {\n            Ok((token, _)) =\u003e Ok(token),\n            Err(e) =\u003e Err(e),\n        }\n    }\n\n    // returns the lookahead_by-th token from the input stream withing advancing, or EOF if that many tokens are not available\n    fn lookahead_token_with_loc(\n        \u0026mut self,\n        lookahead_by: usize,\n    ) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        self.ensure_n_tokens_in_lookahead(lookahead_by)?;\n\n        Ok(self\n            .upcoming_tokens\n            .get(lookahead_by)\n            .cloned()\n            .unwrap_or((Token::Eof, SourceLoc::none())))\n    }\n\n    fn next_token(\u0026mut self) -\u003e Result\u003cToken, ParseError\u003e {\n        self.ensure_n_tokens_in_lookahead(1)?;\n        let (next, start_loc) = self\n            .upcoming_tokens\n            .pop_front()\n            .unwrap_or((Token::Eof, self.lexer.current_loc()));\n        self.last_match = start_loc;\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\"Parser::next_token() -\u003e {}@{}\", next, start_loc);\n        Ok(next)\n    }\n\n    fn expect_token(\u0026mut self, _expected: Token) -\u003e Result\u003cToken, ParseError\u003e {\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\"Parser::expect_token({})\", _expected);\n\n        let (upcoming_token, upcoming_loc) = self.peek_token_with_loc()?;\n        if upcoming_token.eq(\u0026_expected) {\n            self.next_token()\n        } else {\n            Err(ParseError::unexpected_token(\n                upcoming_loc,\n                upcoming_token,\n                \u0026[_expected],\n            ))\n        }\n    }\n\n    fn unexpected_token\u003cT\u003e(\u0026mut self, expected_tokens: \u0026[Token]) -\u003e Result\u003cT, ParseError\u003e {\n        let (current_parse_loc, _current_parse_str) = self\n            .parsing_stack\n            .last()\n            .unwrap_or(\u0026(SourceLoc::none(), String::from(\"UNKNOWN\")))\n            .to_owned();\n\n        let upcoming_token = match self.peek_token() {\n            Ok(tok) =\u003e tok,\n            Err(error) =\u003e return Err(ParseError::from(error)),\n        };\n\n        Err(ParseError::unexpected_token(\n            current_parse_loc,\n            upcoming_token,\n            expected_tokens,\n        ))\n    }\n\n    fn start_parsing(\u0026mut self, what_parsing: \u0026str) -\u003e Result\u003cSourceLoc, ParseError\u003e {\n        for _ in 0..self.parsing_stack.len() {\n            print!(\"\\t\");\n        }\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\"Start parsing {}\", what_parsing);\n\n        let start_loc = self.peek_token_with_loc()?.1;\n        self.parsing_stack\n            .push((start_loc, String::from(what_parsing)));\n        Ok(start_loc)\n    }\n\n    fn finish_parsing\u003cT\u003e(\u0026mut self, _parsed: \u0026T) -\u003e Result\u003c(), ParseError\u003e\n    where\n        T: std::fmt::Display,\n    {\n        let (_parse_start, _parsed_description) = self\n            .parsing_stack\n            .pop()\n            .expect(\"Mismatched loud parsing tracking\");\n        for _ in 0..self.parsing_stack.len() {\n            print!(\"\\t\");\n        }\n\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\n            \"Done parsing {} ({}-{}): {}\",\n            _parsed_description,\n            _parse_start,\n            self.peek_token_with_loc()?.1,\n            _parsed\n        );\n\n        Ok(())\n    }\n}\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn parse(\u0026mut self) -\u003e Result\u003cVec\u003cTranslationUnitTree\u003e, ParseError\u003e {\n        let mut translation_units = Vec::new();\n        while self.peek_token()? != Token::Eof {\n            translation_units.push(self.parse_translation_unit()?);\n        }\n        Ok(translation_units)\n    }\n\n    fn parse_translation_unit(\u0026mut self) -\u003e Result\u003cTranslationUnitTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"translation unit\")?;\n\n        let translation_unit = TranslationUnitTree {\n            loc: start_loc,\n            contents: match self.peek_token()? {\n                Token::Fun =\u003e self.parse_function_declaration_or_definition()?,\n                Token::Struct =\u003e self.parse_struct_definition()?,\n                Token::Impl =\u003e self.parse_implementation()?,\n                _ =\u003e self.unexpected_token(\u0026[Token::Fun, Token::Struct])?,\n            },\n        };\n\n        self.finish_parsing(\u0026translation_unit)?;\n\n        Ok(translation_unit)\n    }\n\n    fn parse_statement(\u0026mut self) -\u003e Result\u003cStatementTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"statement\")?;\n\n        let statement = StatementTree {\n            loc: start_loc,\n            statement: match self.peek_token()? {\n                Token::Identifier(_) =\u003e match self.lookahead_token(1)? {\n                    Token::Colon =\u003e {\n                        Statement::VariableDeclaration(self.parse_variable_declaration()?)\n                    }\n                    _ =\u003e Statement::Expression(self.parse_expression()?),\n                },\n                Token::If | Token::While | Token::LCurly =\u003e {\n                    Statement::Expression(self.parse_expression()?)\n                }\n                _ =\u003e self.unexpected_token::\u003cStatement\u003e(\u0026[\n                    Token::Identifier(\"\".into()),\n                    Token::If,\n                    Token::While,\n                    Token::LCurly,\n                ])?,\n            },\n        };\n\n        if matches!(self.peek_token()?, Token::Semicolon) {\n            self.expect_token(Token::Semicolon)?;\n        }\n\n        self.finish_parsing(\u0026statement)?;\n\n        Ok(statement)\n    }\n\n    fn token_is_operator_of_at_least_precedence(token: \u0026Token, precedence: usize) -\u003e bool {\n        match token {\n            Token::Plus\n            | Token::Minus\n            | Token::Star\n            | Token::FSlash\n            | Token::LThan\n            | Token::GThan\n            | Token::LThanE\n            | Token::GThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e ir::BinaryOperations::precedence_of_token(\u0026token) \u003e= precedence,\n            _ =\u003e false,\n        }\n    }\n\n    fn try_parse_self_param(\u0026mut self) -\u003e Result\u003cOption\u003cVariableDeclarationTree\u003e, ParseError\u003e {\n        let start_loc = self.start_parsing(\"self parameter\")?;\n\n        let is_reference = match self.peek_token()? {\n            Token::Reference =\u003e {\n                self.expect_token(Token::Reference)?;\n                true\n            }\n            _ =\u003e false,\n        };\n\n        let is_mutable = match self.peek_token()? {\n            Token::Mut =\u003e {\n                self.expect_token(Token::Mut)?;\n                true\n            }\n            _ =\u003e false,\n        };\n\n        let maybe_self_param = match self.peek_token()? {\n            Token::SelfLower =\u003e {\n                let typename_loc = self.peek_token_with_loc()?.1;\n                self.expect_token(Token::SelfLower);\n                Some(VariableDeclarationTree {\n                    loc: start_loc,\n                    name: String::from(\"self\"),\n                    typename: TypenameTree {\n                        loc: typename_loc,\n                        type_: Type::Self_,\n                    },\n                })\n            }\n            _ =\u003e None,\n        };\n\n        match \u0026maybe_self_param {\n            Some(self_param) =\u003e self.finish_parsing(self_param)?,\n            None =\u003e self.finish_parsing(\u0026String::from(\"no self param\"))?,\n        };\n\n        Ok(maybe_self_param)\n    }\n\n    fn parse_function_parameters(\u0026mut self) -\u003e Result\u003cVec\u003cVariableDeclarationTree\u003e, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"function parameters\");\n\n        let mut params = Vec::\u003cVariableDeclarationTree\u003e::new();\n\n        loop {\n            match self.peek_token()? {\n                // argument declaration\n                Token::Identifier(_) =\u003e {\n                    params.push(self.parse_variable_declaration()?);\n                    match self.peek_token()? {\n                        Token::Comma =\u003e self.next_token()?, // expect another argument declaration after comma\n                        _ =\u003e break,                         // loop again for anything else\n                    };\n                }\n                Token::RParen =\u003e break, // done on rparen\n                _ =\u003e self.unexpected_token(\u0026[Token::Identifier(\"\".into())])?,\n            }\n        }\n\n        self.finish_parsing(\u0026format!(\"{} parameters\", params.len()));\n        Ok(params)\n    }\n\n    fn parse_function_prototype(\u0026mut self) -\u003e Result\u003cFunctionDeclarationTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"function prototype\")?;\n\n        // start with fun\n        self.expect_token(Token::Fun)?;\n        let prototype = FunctionDeclarationTree {\n            // grab start location and name\n            loc: start_loc,\n            name: self.parse_identifier()?,\n            arguments: {\n                self.expect_token(Token::LParen)?;\n                let params = self.parse_function_parameters()?;\n                self.expect_token(Token::RParen)?;\n                params\n            },\n            return_type: match self.peek_token()? {\n                Token::Arrow =\u003e {\n                    self.next_token()?;\n                    Some(self.parse_typename()?)\n                }\n                _ =\u003e None,\n            },\n        };\n\n        self.finish_parsing(\u0026prototype)?;\n\n        Ok(prototype)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::frontend::{\n        lexer::{token::Token, LexError, Lexer},\n        parser::{ParseError, Parser},\n        sourceloc::SourceLoc,\n    };\n\n    #[test]\n    fn expect_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8\"));\n        let result = p.expect_token(Token::U8);\n        assert_eq!(result, Ok(Token::U8))\n    }\n\n    #[test]\n    fn expect_token_fail() {\n        let mut p = Parser::new(Lexer::from_string(\"abcd\"));\n        let result = p.expect_token(Token::U8);\n        assert_eq!(\n            result,\n            Err(ParseError::unexpected_token(\n                SourceLoc::new(1, 1),\n                Token::Identifier(\"abcd\".into()),\n                \u0026[Token::U8]\n            ))\n        )\n    }\n\n    #[test]\n    fn peek_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8\"));\n        assert_eq!(p.peek_token(), Ok(Token::U8));\n        p.next_token().unwrap();\n        assert_eq!(p.peek_token(), Ok(Token::Eof));\n        p.next_token().unwrap();\n        assert_eq!(p.peek_token(), Ok(Token::Eof));\n    }\n\n    #[test]\n    fn lookahead_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8 u16 u32 u64\"));\n        assert_eq!(p.lookahead_token(0), Ok(Token::U8));\n        assert_eq!(p.lookahead_token(1), Ok(Token::U16));\n        assert_eq!(p.lookahead_token(2), Ok(Token::U32));\n        assert_eq!(p.lookahead_token(3), Ok(Token::U64));\n    }\n\n    #[test]\n    fn unexpected_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8 u16 u32 u64\"));\n        assert_eq!(p.expect_token(Token::U8), Ok(Token::U8));\n        assert_eq!(\n            p.expect_token(Token::U32),\n            Err(ParseError::unexpected_token(\n                SourceLoc::new(1, 4),\n                Token::U16,\n                \u0026[Token::U32]\n            ))\n        );\n    }\n}\n","traces":[{"line":30,"address":[655200],"length":1,"stats":{"Line":0}},{"line":31,"address":[655205],"length":1,"stats":{"Line":0}},{"line":32,"address":[655236],"length":1,"stats":{"Line":0}},{"line":33,"address":[655247],"length":1,"stats":{"Line":0}},{"line":34,"address":[655258],"length":1,"stats":{"Line":0}},{"line":35,"address":[655269],"length":1,"stats":{"Line":0}},{"line":36,"address":[655280],"length":1,"stats":{"Line":0}},{"line":37,"address":[655291],"length":1,"stats":{"Line":0}},{"line":38,"address":[655302],"length":1,"stats":{"Line":0}},{"line":39,"address":[655313],"length":1,"stats":{"Line":0}},{"line":40,"address":[655324],"length":1,"stats":{"Line":0}},{"line":41,"address":[655335],"length":1,"stats":{"Line":0}},{"line":45,"address":[655360],"length":1,"stats":{"Line":0}},{"line":46,"address":[655369],"length":1,"stats":{"Line":0}},{"line":47,"address":[655517],"length":1,"stats":{"Line":0}},{"line":48,"address":[655528],"length":1,"stats":{"Line":0}},{"line":49,"address":[655539],"length":1,"stats":{"Line":0}},{"line":50,"address":[655550],"length":1,"stats":{"Line":0}},{"line":51,"address":[655561],"length":1,"stats":{"Line":0}},{"line":52,"address":[655572],"length":1,"stats":{"Line":0}},{"line":53,"address":[655583],"length":1,"stats":{"Line":0}},{"line":54,"address":[655594],"length":1,"stats":{"Line":0}},{"line":55,"address":[655605],"length":1,"stats":{"Line":0}},{"line":56,"address":[655616],"length":1,"stats":{"Line":0}},{"line":58,"address":[655452],"length":1,"stats":{"Line":0}},{"line":68,"address":[629869,629440],"length":1,"stats":{"Line":5}},{"line":69,"address":[629470,629559],"length":1,"stats":{"Line":12}},{"line":73,"address":[629625],"length":1,"stats":{"Line":7}},{"line":74,"address":[629677],"length":1,"stats":{"Line":7}},{"line":78,"address":[630526,629904],"length":1,"stats":{"Line":5}},{"line":79,"address":[629952,629989],"length":1,"stats":{"Line":14}},{"line":80,"address":[630400,630305],"length":1,"stats":{"Line":4}},{"line":83,"address":[629972],"length":1,"stats":{"Line":4}},{"line":88,"address":[630560],"length":1,"stats":{"Line":1}},{"line":90,"address":[630579],"length":1,"stats":{"Line":1}},{"line":91,"address":[630699],"length":1,"stats":{"Line":1}},{"line":92,"address":[630628],"length":1,"stats":{"Line":0}},{"line":96,"address":[630816],"length":1,"stats":{"Line":4}},{"line":97,"address":[630840],"length":1,"stats":{"Line":4}},{"line":100,"address":[630980],"length":1,"stats":{"Line":3}},{"line":103,"address":[631008],"length":1,"stats":{"Line":1}},{"line":104,"address":[631031],"length":1,"stats":{"Line":1}},{"line":105,"address":[631149],"length":1,"stats":{"Line":1}},{"line":106,"address":[631079],"length":1,"stats":{"Line":0}},{"line":111,"address":[631710,631264],"length":1,"stats":{"Line":1}},{"line":115,"address":[631307],"length":1,"stats":{"Line":1}},{"line":117,"address":[631593,631679,631434],"length":1,"stats":{"Line":12}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[631473,631632,631740],"length":1,"stats":{"Line":4}},{"line":124,"address":[631760,632325],"length":1,"stats":{"Line":1}},{"line":125,"address":[631790],"length":1,"stats":{"Line":1}},{"line":126,"address":[632077,632175,631917],"length":1,"stats":{"Line":7}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[632355,631953,632116],"length":1,"stats":{"Line":3}},{"line":130,"address":[632252],"length":1,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[632266],"length":1,"stats":{"Line":3}},{"line":136,"address":[632368,633075,633170],"length":1,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[632403,632496],"length":1,"stats":{"Line":5}},{"line":141,"address":[632721,632777],"length":1,"stats":{"Line":4}},{"line":142,"address":[632946,633084],"length":1,"stats":{"Line":3}},{"line":144,"address":[633001,632929],"length":1,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[632802],"length":1,"stats":{"Line":1}},{"line":147,"address":[632836],"length":1,"stats":{"Line":1}},{"line":152,"address":[1013288,1014067,1014996,1017520,1013235,1014144,1016688,1016611,1014921,1014120,1016664,1017443,1013312,1015024,1017496,1015832,1018372,1015856,1015779,1012480,1018297],"length":1,"stats":{"Line":0}},{"line":153,"address":[1012544,1012750,1013582,1014208,1013376,1014352,1015294,1015232,1016958,1017584,1016126,1013520,1016896,1017728,1017790,1016064,1015088,1012688,1015920,1016752,1014414],"length":1,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[1015953,1016785,1012577,1013409,1014241,1015121,1017617],"length":1,"stats":{"Line":0}},{"line":159,"address":[1014555,1016267,1013723,1017099,1012891,1015435,1017931],"length":1,"stats":{"Line":0}},{"line":160,"address":[1012990,1013822,1017198,1015534,1016366,1018030,1014654],"length":1,"stats":{"Line":0}},{"line":161,"address":[1012912,1018311,1014081,1013744,1014935,1016288,1017120,1015456,1013249,1017457,1015793,1016625,1017952,1014576],"length":1,"stats":{"Line":0}},{"line":164,"address":[1014782,1013999,1014831,1015662,1013118,1013950,1015711,1016494,1016543,1017326,1017375,1018158,1018207,1013167],"length":1,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[1016438,1015606,1018102,1013894,1017270,1013062,1014726],"length":1,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[633200],"length":1,"stats":{"Line":2}},{"line":172,"address":[633264],"length":1,"stats":{"Line":2}},{"line":173,"address":[633313],"length":1,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[633348],"length":1,"stats":{"Line":2}},{"line":179,"address":[633720,633619],"length":1,"stats":{"Line":2}},{"line":180,"address":[633628],"length":1,"stats":{"Line":1}},{"line":181,"address":[633755],"length":1,"stats":{"Line":1}},{"line":184,"address":[1022400,1019200,1023200,1019166,1019600,1020000,1021200,1018400,1023566,1020766,1023166,1020400,1021600,1022000,1021166,1018800,1019966,1020800,1022366,1022766,1022800,1018766,1019566,1020366,1021566,1021966],"length":1,"stats":{"Line":1}},{"line":188,"address":[1021233,1022033,1018833,1022833,1019233,1019633,1021633,1020433,1022433,1018433,1020033,1023233,1020833],"length":1,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[1020945,1021007,1021807,1019407,1023345,1019007,1019745,1022145,1022545,1021745,1020607,1020145,1018545,1022607,1023007,1023407,1018945,1018607,1019345,1020207,1020545,1022207,1021345,1022945,1019807,1021407],"length":1,"stats":{"Line":2}},{"line":193,"address":[1023145,1023481,1021145,1021945,1023545,1019145,1021481,1019881,1020745,1022281,1019481,1021881,1018681,1020681,1019945,1022745,1022681,1023081,1019081,1018745,1020281,1019545,1020345,1022345,1021081,1021545],"length":1,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[1019908,1019108,1023508,1023108,1021108,1021908,1019508,1020708,1021508,1018708,1020308,1022308,1022708],"length":1,"stats":{"Line":1}},{"line":210,"address":[634489,633792,634478],"length":1,"stats":{"Line":0}},{"line":211,"address":[633822],"length":1,"stats":{"Line":0}},{"line":212,"address":[633845,634487,633902],"length":1,"stats":{"Line":0}},{"line":213,"address":[634241],"length":1,"stats":{"Line":0}},{"line":215,"address":[634127],"length":1,"stats":{"Line":0}},{"line":218,"address":[634512,636341],"length":1,"stats":{"Line":0}},{"line":219,"address":[634542],"length":1,"stats":{"Line":0}},{"line":223,"address":[634707],"length":1,"stats":{"Line":0}},{"line":231,"address":[636106],"length":1,"stats":{"Line":0}},{"line":233,"address":[636264],"length":1,"stats":{"Line":0}},{"line":236,"address":[639628,638120,636368],"length":1,"stats":{"Line":0}},{"line":237,"address":[636398],"length":1,"stats":{"Line":0}},{"line":241,"address":[636563],"length":1,"stats":{"Line":0}},{"line":260,"address":[638806,639623],"length":1,"stats":{"Line":0}},{"line":261,"address":[639096,639385],"length":1,"stats":{"Line":0}},{"line":264,"address":[639378,639421,639618],"length":1,"stats":{"Line":0}},{"line":266,"address":[639556],"length":1,"stats":{"Line":0}},{"line":269,"address":[639664],"length":1,"stats":{"Line":0}},{"line":270,"address":[639683],"length":1,"stats":{"Line":0}},{"line":271,"address":[639739],"length":1,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[639732],"length":1,"stats":{"Line":0}},{"line":285,"address":[640689,639792],"length":1,"stats":{"Line":0}},{"line":286,"address":[639822],"length":1,"stats":{"Line":0}},{"line":288,"address":[639993],"length":1,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[640270,640370],"length":1,"stats":{"Line":0}},{"line":291,"address":[640587],"length":1,"stats":{"Line":0}},{"line":293,"address":[640301],"length":1,"stats":{"Line":0}},{"line":296,"address":[640613,640716],"length":1,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[641037,640937],"length":1,"stats":{"Line":0}},{"line":299,"address":[641254],"length":1,"stats":{"Line":0}},{"line":301,"address":[640968],"length":1,"stats":{"Line":0}},{"line":304,"address":[641280,641353],"length":1,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[641575,641661],"length":1,"stats":{"Line":0}},{"line":307,"address":[641935],"length":1,"stats":{"Line":0}},{"line":308,"address":[642110],"length":1,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[641981],"length":1,"stats":{"Line":0}},{"line":311,"address":[642046],"length":1,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[642028],"length":1,"stats":{"Line":0}},{"line":317,"address":[641582],"length":1,"stats":{"Line":0}},{"line":320,"address":[642303],"length":1,"stats":{"Line":0}},{"line":321,"address":[642353,642755],"length":1,"stats":{"Line":0}},{"line":322,"address":[642379,642702],"length":1,"stats":{"Line":0}},{"line":325,"address":[642648],"length":1,"stats":{"Line":0}},{"line":328,"address":[642912,645042,644297],"length":1,"stats":{"Line":0}},{"line":329,"address":[642942],"length":1,"stats":{"Line":0}},{"line":331,"address":[643013,642969],"length":1,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[645025,643028,643085],"length":1,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[643360,644684,643423],"length":1,"stats":{"Line":0}},{"line":338,"address":[643681,644679],"length":1,"stats":{"Line":0}},{"line":339,"address":[643936,644017],"length":1,"stats":{"Line":0}},{"line":344,"address":[643295,644694],"length":1,"stats":{"Line":0}},{"line":348,"address":[644311],"length":1,"stats":{"Line":0}},{"line":349,"address":[644568],"length":1,"stats":{"Line":0}},{"line":352,"address":[647758,645056],"length":1,"stats":{"Line":0}},{"line":353,"address":[645086],"length":1,"stats":{"Line":0}},{"line":356,"address":[645250],"length":1,"stats":{"Line":0}},{"line":360,"address":[645517],"length":1,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[646633,646696],"length":1,"stats":{"Line":0}},{"line":376,"address":[647838],"length":1,"stats":{"Line":0}},{"line":378,"address":[647996],"length":1,"stats":{"Line":0}}],"covered":44,"coverable":176},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","sourceloc.rs"],"content":"use std::fmt::Display;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct SourceLoc {\n    line: usize,\n    col: usize,\n}\n\nimpl SourceLoc {\n    pub fn none() -\u003e Self {\n        SourceLoc { line: 0, col: 0 }\n    }\n\n    pub fn new(line: usize, col: usize) -\u003e Self {\n        SourceLoc { line, col }\n    }\n}\n\nimpl Display for SourceLoc {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}:{}\", self.line, self.col)\n    }\n}\n","traces":[{"line":12,"address":[767456],"length":1,"stats":{"Line":3}},{"line":16,"address":[767472],"length":1,"stats":{"Line":7}},{"line":22,"address":[767504],"length":1,"stats":{"Line":0}},{"line":23,"address":[767543],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend.rs"],"content":"pub mod ast;\npub mod lexer;\npub mod parser;\npub mod sourceloc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","hashmap_ooo_iter.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::hash::Hash;\n\nfn check_key_order\u003cK, V\u003e(map: \u0026HashMap\u003cK, V\u003e, key_order: \u0026Vec\u003cK\u003e)\nwhere\n    K: Eq + Hash,\n{\n    let mut seen_keys = HashSet::\u003c\u0026K\u003e::new();\n    for key in key_order {\n        assert!(\n            map.contains_key(key),\n            \"All keys in key ordering for out-of-order HashMap iterator must be present in map\"\n        );\n        assert!(\n            !seen_keys.contains(key),\n            \"Duplicate key seen in key ordering for out-of-order HashMap iterator\",\n        );\n        seen_keys.insert(key);\n    }\n\n    assert!(\n        seen_keys.len() == map.len(),\n        \"Missing key(s) from key ordering for out-of-order HashMap iterator. All keys must be included\"\n    );\n}\n\n// the iterator itself only needs to own Key, \u0026Value pairs\npub struct HashMapOOOIter\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a V)\u003e,\n}\n\n// iteration is simply popping from the references vec\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIter\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIter\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // allocate the vector with its full capacity from the get-go\n        let mut references = Vec::\u003c(K, \u0026'a V)\u003e::with_capacity(map.len());\n        // grab values for each key, moving each key into the references vector along with its corresponding value reference\n        for key in key_order.into_iter().rev() {\n            let value_ref: \u0026V = map.get(\u0026key).unwrap();\n            references.push((key, value_ref));\n        }\n\n        HashMapOOOIter { references }\n    }\n}\n\npub struct HashMapOOOIterMut\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a mut V)\u003e,\n}\n\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIterMut\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a mut V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIterMut\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a mut HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // same as for HashMapOOOIter but with additional reference manipulation\n        let mut references = Vec::\u003c(K, \u0026'a mut V)\u003e::with_capacity(map.len());\n        for key in key_order.into_iter().rev() {\n            // get our value reference as normal\n            let value: \u0026V = map.get(\u0026key).unwrap();\n            // create a pointer from the reference, and cast it to a mutable pointer\n            let pointer: *const V = std::ptr::from_ref(value);\n            let mut_pointer: *mut V = pointer as *mut V;\n            // since we have exactly one instance of every key in the map per check_key_order()\n            let value_mut: \u0026mut V = unsafe {\n                // trust that we can .as_mut() the pointer into a mutable reference\n                mut_pointer.as_mut()\n            }\n            .unwrap();\n            references.push((key, value_mut));\n        }\n\n        HashMapOOOIterMut { references }\n    }\n}\n","traces":[{"line":4,"address":[705968,706476],"length":1,"stats":{"Line":0}},{"line":8,"address":[706006],"length":1,"stats":{"Line":0}},{"line":9,"address":[706016,706080],"length":1,"stats":{"Line":0}},{"line":10,"address":[706367,706324],"length":1,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[706447,706420],"length":1,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[706442,706413],"length":1,"stats":{"Line":0}},{"line":21,"address":[706202],"length":1,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[706512],"length":1,"stats":{"Line":0}},{"line":37,"address":[706517],"length":1,"stats":{"Line":0}},{"line":45,"address":[707272,706528],"length":1,"stats":{"Line":0}},{"line":46,"address":[706579],"length":1,"stats":{"Line":0}},{"line":49,"address":[706656],"length":1,"stats":{"Line":0}},{"line":51,"address":[706804,706697,706958,707262],"length":1,"stats":{"Line":0}},{"line":52,"address":[707025,707189],"length":1,"stats":{"Line":0}},{"line":53,"address":[707219],"length":1,"stats":{"Line":0}},{"line":67,"address":[707312],"length":1,"stats":{"Line":0}},{"line":68,"address":[707317],"length":1,"stats":{"Line":0}},{"line":76,"address":[707328,708175],"length":1,"stats":{"Line":0}},{"line":77,"address":[707379],"length":1,"stats":{"Line":0}},{"line":80,"address":[707456],"length":1,"stats":{"Line":0}},{"line":81,"address":[708165,707497,707604,707773],"length":1,"stats":{"Line":0}},{"line":83,"address":[707840,708008],"length":1,"stats":{"Line":0}},{"line":85,"address":[708040],"length":1,"stats":{"Line":0}},{"line":86,"address":[708065],"length":1,"stats":{"Line":0}},{"line":90,"address":[708073],"length":1,"stats":{"Line":0}},{"line":93,"address":[708122],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","main.rs"],"content":"mod backend;\nmod frontend;\nmod midend;\n\nmod hashmap_ooo_iter;\n\nuse backend::generate_code;\nuse frontend::{lexer::Lexer, parser::Parser};\n\nconst FIB_FUN: \u0026str = \"fun fib(u8 n) -\u003e u64\n{\n    u64 result;\n    result = 0;\n    if (n \u003e 0) {\n        if(n == 0) {\n            result = 0;\n        } else {\n         result = 1;\n        }\n    } else {\n        result = (n - 1) - (n - 2);\n    }\n}\";\n\nconst WHILE_LOOP: \u0026str = \"fun down_to_zero(u16 input)\n{\n    input = input;\n    while(input \u003e 0) {\n        input = input - 1;\n    }\n\n    input = input + 1;\n}\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH: \u0026str = \"\nfun while_with_nested_branch(a: u8, b: u16, c: u32) {\n    counter: u8;\n    counter = 0;\n    while (a \u003c b) {\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            counter = counter - 1;\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH_NO_ARGS: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    while (a \u003c b) {\n        u8 counter;\n        if (c \u003e 22) {\n            a = a + b;\n        } else {\n            b = b - 1;\n        }\n    }\n}\n\";\n\nconst NESTED_WHILE_LOOPS: \u0026str = \"\nfun while_with_nested_branch(u8 a, u16 b, u32 c) {\n    while (a \u003c b) {\n        u8 counter;\n        counter = 0;\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            while (counter \u003e 0) {\n            counter = counter - 1;\n            }\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst SSA_EXAMPLE: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    \n    a = b + c;\n    b = a + c;\n    if (a \u003e b) {\n    c = c + 1;\n    } else {\n     c = 1;}\n    c = c + 1;\n    c = c + 1;\n}\";\n\nconst STRUCT_EXAMPLE: \u0026str = \"struct Money {\ndollars: u64,\ncents: u8\n}\n\nimpl Money {\n    fun new(dollars: u64, cents: u8) -\u003e Self {\n        \n    }\n}\n\nfun money_add_dollars(m: Money, dollars: u64) {\n    m.dollars = m.dollars + dollars;\n    m.print();\n}\n\";\n\nfn main() {\n    println!(\"Hello, world!\");\n    let mut parser = Parser::new(Lexer::from_string(STRUCT_EXAMPLE));\n    let program = parser.parse().expect(\"Error parsing input\");\n\n    for t in \u0026program {\n        println!(\"{}\", t);\n    }\n\n    let mut symtab = midend::symbol_table_from_program(program);\n\n    // println!(\"{}\", serde_json::to_string_pretty(\u0026symtab).unwrap());\n    println!(\"SYMTAB IR\");\n    symtab.print_ir();\n\n    symtab.assign_program_points();\n\n    generate_code(symtab);\n}\n","traces":[{"line":122,"address":[372354,372253,371552],"length":1,"stats":{"Line":0}},{"line":123,"address":[371559],"length":1,"stats":{"Line":0}},{"line":124,"address":[371611],"length":1,"stats":{"Line":0}},{"line":125,"address":[371674,371718],"length":1,"stats":{"Line":0}},{"line":127,"address":[371776,371841],"length":1,"stats":{"Line":0}},{"line":128,"address":[371953,372262],"length":1,"stats":{"Line":0}},{"line":131,"address":[371963],"length":1,"stats":{"Line":0}},{"line":134,"address":[372034,372097],"length":1,"stats":{"Line":0}},{"line":135,"address":[372124],"length":1,"stats":{"Line":0}},{"line":137,"address":[372139],"length":1,"stats":{"Line":0}},{"line":139,"address":[372146],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","block_args.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct BlockArgs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for BlockArgs\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, _to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        facts.gen_facts.clone()\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut super::Facts\u003cFact\u003e) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    if !block_facts.kill_facts.contains(read) {\n                        block_facts.gen_facts.insert(read.clone());\n                    }\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.kill_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(mut a: BTreeSet\u003cFact\u003e, b: \u0026BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e super::Facts\u003cFact\u003e {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":17,"address":[378958,378880],"length":1,"stats":{"Line":0}},{"line":18,"address":[378901],"length":1,"stats":{"Line":0}},{"line":21,"address":[378992,379843],"length":1,"stats":{"Line":0}},{"line":22,"address":[379026],"length":1,"stats":{"Line":0}},{"line":23,"address":[379155],"length":1,"stats":{"Line":0}},{"line":25,"address":[379212,379181],"length":1,"stats":{"Line":0}},{"line":26,"address":[379289,379452],"length":1,"stats":{"Line":0}},{"line":27,"address":[379869,379517],"length":1,"stats":{"Line":0}},{"line":28,"address":[379889],"length":1,"stats":{"Line":0}},{"line":31,"address":[379553,379716],"length":1,"stats":{"Line":0}},{"line":32,"address":[379776,379831],"length":1,"stats":{"Line":0}},{"line":38,"address":[379936,380208],"length":1,"stats":{"Line":0}},{"line":39,"address":[379984,380028],"length":1,"stats":{"Line":0}},{"line":40,"address":[380131,380196],"length":1,"stats":{"Line":0}},{"line":43,"address":[380153],"length":1,"stats":{"Line":0}},{"line":46,"address":[380240],"length":1,"stats":{"Line":0}},{"line":48,"address":[380272],"length":1,"stats":{"Line":0}},{"line":58,"address":[380352],"length":1,"stats":{"Line":0}},{"line":59,"address":[380357],"length":1,"stats":{"Line":0}},{"line":62,"address":[380368],"length":1,"stats":{"Line":0}},{"line":63,"address":[380385],"length":1,"stats":{"Line":0}},{"line":66,"address":[380432],"length":1,"stats":{"Line":0}},{"line":67,"address":[380440],"length":1,"stats":{"Line":0}},{"line":70,"address":[380448],"length":1,"stats":{"Line":0}},{"line":71,"address":[380456],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","block_depths.rs"],"content":"\npub struct BlockDepths\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","idfa_base.rs"],"content":"use std::{\n    collections::{BTreeSet, HashMap},\n    fmt::Display,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\npub enum IdfaAnalysisDirection {\n    Forward,\n    Backward,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct BlockFacts\u003cT\u003e {\n    pub in_facts: BTreeSet\u003cT\u003e,\n    pub out_facts: BTreeSet\u003cT\u003e,\n    pub gen_facts: BTreeSet\u003cT\u003e,\n    pub kill_facts: BTreeSet\u003cT\u003e,\n}\n\nimpl\u003cT\u003e BlockFacts\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        BlockFacts {\n            in_facts: BTreeSet::\u003cT\u003e::new(),\n            out_facts: BTreeSet::\u003cT\u003e::new(),\n            gen_facts: BTreeSet::\u003cT\u003e::new(),\n            kill_facts: BTreeSet::\u003cT\u003e::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    facts: HashMap\u003cusize, BlockFacts\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub fn new(n_blocks: usize) -\u003e Self {\n        Self {\n            facts: HashMap::with_capacity(n_blocks),\n        }\n    }\n    pub fn for_label(\u0026self, label: usize) -\u003e \u0026BlockFacts\u003cT\u003e {\n        self.facts.get(\u0026label).unwrap()\n    }\n\n    pub fn for_label_mut(\u0026mut self, label: usize) -\u003e \u0026mut BlockFacts\u003cT\u003e {\n        self.facts.entry(label).or_insert(BlockFacts::\u003cT\u003e::new())\n    }\n}\n\npub trait IdfaImplementor\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    fn f_transfer(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e);\n    fn f_meet(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self;\n    fn reanalyze(\u0026mut self);\n    fn take_facts(self) -\u003e Facts\u003cT\u003e;\n    fn facts(\u0026self) -\u003e \u0026Facts\u003cT\u003e;\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts\u003cT\u003e;\n}\n\n#[derive(Debug)]\npub struct Idfa\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub control_flow: \u0026'a ir::ControlFlow,\n    direction: IdfaAnalysisDirection,\n    last_facts: Facts\u003cT\u003e,\n    pub facts: Facts\u003cT\u003e,\n    f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n    f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n}\n\nimpl\u003c'a, T\u003e Idfa\u003c'a, T\u003e\nwhere\n    Facts\u003cT\u003e: PartialEq,\n    T: std::fmt::Debug + Display + Clone + Ord,\n{\n    fn store_facts_as_last(\u0026mut self) {\n        self.last_facts = self.facts.clone();\n    }\n\n    fn reached_fixpoint(\u0026mut self) -\u003e bool {\n        self.facts == self.last_facts\n    }\n\n    fn analyze_block_forwards\u003c'b\u003e(\u0026mut self, block: \u0026ir::BasicBlock) {\n        let label = block.label;\n        let mut new_in_facts = BTreeSet::\u003cT\u003e::new();\n\n        for predecessor in \u0026block.predecessors {\n            new_in_facts =\n                (self.f_meet)(new_in_facts, \u0026self.facts.for_label(*predecessor).out_facts);\n        }\n\n        self.facts.for_label_mut(label).in_facts = new_in_facts.clone();\n        let transferred = (self.f_transfer)(self.facts.for_label_mut(label), new_in_facts);\n        self.facts.for_label_mut(label).out_facts = transferred;\n    }\n\n    fn analyze_forward(\u0026mut self) {\n        let mut first_iteration = true;\n        while !self.reached_fixpoint() || first_iteration {\n            first_iteration = false;\n            self.store_facts_as_last();\n\n            for (_, block) in \u0026self.control_flow.blocks {\n                self.analyze_block_forwards(block);\n            }\n        }\n    }\n\n    fn analyze_backward(\u0026mut self) {\n        // let mut first_iteration = true;\n        // while !self.reached_fixpoint() || first_iteration {\n        unimplemented!();\n        // first_iteration = false;\n        // self.store_facts_as_last();\n        // }\n    }\n\n    pub fn analyze(\u0026mut self) {\n        (self.f_find_gen_kills)(self.control_flow, \u0026mut self.facts);\n        match self.direction {\n            IdfaAnalysisDirection::Forward =\u003e {\n                self.analyze_forward();\n            }\n            IdfaAnalysisDirection::Backward =\u003e {\n                self.analyze_backward();\n            }\n        }\n    }\n\n    pub fn new(\n        control_flow: \u0026'a ir::ControlFlow,\n        direction: IdfaAnalysisDirection,\n        f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n        f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n        f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    ) -\u003e Self {\n        let mut idfa = Self {\n            control_flow,\n            direction,\n            last_facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            f_find_gen_kills,\n            f_meet,\n            f_transfer,\n        };\n\n        idfa.analyze();\n\n        idfa\n    }\n}\n","traces":[{"line":23,"address":[568604,568320],"length":1,"stats":{"Line":0}},{"line":25,"address":[568342],"length":1,"stats":{"Line":0}},{"line":26,"address":[568352],"length":1,"stats":{"Line":0}},{"line":27,"address":[568398],"length":1,"stats":{"Line":0}},{"line":28,"address":[568441],"length":1,"stats":{"Line":0}},{"line":45,"address":[568624],"length":1,"stats":{"Line":0}},{"line":47,"address":[568642],"length":1,"stats":{"Line":0}},{"line":50,"address":[568688],"length":1,"stats":{"Line":0}},{"line":51,"address":[568702],"length":1,"stats":{"Line":0}},{"line":54,"address":[568736],"length":1,"stats":{"Line":0}},{"line":55,"address":[568762],"length":1,"stats":{"Line":0}},{"line":92,"address":[568895,568816],"length":1,"stats":{"Line":0}},{"line":93,"address":[568833,568926],"length":1,"stats":{"Line":0}},{"line":96,"address":[568960],"length":1,"stats":{"Line":0}},{"line":97,"address":[568968],"length":1,"stats":{"Line":0}},{"line":100,"address":[569944,568992,570132],"length":1,"stats":{"Line":0}},{"line":101,"address":[569025],"length":1,"stats":{"Line":0}},{"line":102,"address":[569074],"length":1,"stats":{"Line":0}},{"line":104,"address":[569097,570109,569154],"length":1,"stats":{"Line":0}},{"line":105,"address":[570062],"length":1,"stats":{"Line":0}},{"line":106,"address":[569262,569971,570122],"length":1,"stats":{"Line":0}},{"line":109,"address":[569348,569961],"length":1,"stats":{"Line":0}},{"line":110,"address":[569568],"length":1,"stats":{"Line":0}},{"line":111,"address":[569667,569934],"length":1,"stats":{"Line":0}},{"line":114,"address":[570160],"length":1,"stats":{"Line":0}},{"line":115,"address":[570177],"length":1,"stats":{"Line":0}},{"line":116,"address":[570187,570251],"length":1,"stats":{"Line":0}},{"line":117,"address":[570201],"length":1,"stats":{"Line":0}},{"line":118,"address":[570206],"length":1,"stats":{"Line":0}},{"line":120,"address":[570266,570216],"length":1,"stats":{"Line":0}},{"line":121,"address":[570336],"length":1,"stats":{"Line":0}},{"line":126,"address":[570352],"length":1,"stats":{"Line":0}},{"line":135,"address":[570400],"length":1,"stats":{"Line":0}},{"line":136,"address":[570417],"length":1,"stats":{"Line":0}},{"line":137,"address":[570435],"length":1,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[570471],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[570459],"length":1,"stats":{"Line":0}},{"line":147,"address":[570496,570918],"length":1,"stats":{"Line":0}},{"line":157,"address":[570588],"length":1,"stats":{"Line":0}},{"line":158,"address":[570614,570679],"length":1,"stats":{"Line":0}},{"line":164,"address":[570844],"length":1,"stats":{"Line":0}},{"line":166,"address":[570890],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","live_vars.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base::{self, IdfaImplementor};\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct LiveVars\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for LiveVars\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = facts.gen_facts.clone();\n\n        for fact in \u0026to_transfer {\n            if !facts.kill_facts.contains(fact) {\n                transferred.insert(fact.clone());\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":16,"address":[196784,197164],"length":1,"stats":{"Line":0}},{"line":17,"address":[196819],"length":1,"stats":{"Line":0}},{"line":19,"address":[196923,196882],"length":1,"stats":{"Line":0}},{"line":20,"address":[197036,197109],"length":1,"stats":{"Line":0}},{"line":21,"address":[197132],"length":1,"stats":{"Line":0}},{"line":25,"address":[197061],"length":1,"stats":{"Line":0}},{"line":28,"address":[198053,197200],"length":1,"stats":{"Line":0}},{"line":29,"address":[197234],"length":1,"stats":{"Line":0}},{"line":30,"address":[197363],"length":1,"stats":{"Line":0}},{"line":32,"address":[197389,197420],"length":1,"stats":{"Line":0}},{"line":33,"address":[197497,197660],"length":1,"stats":{"Line":0}},{"line":34,"address":[198088,197720],"length":1,"stats":{"Line":0}},{"line":36,"address":[197928,197765],"length":1,"stats":{"Line":0}},{"line":37,"address":[197988,198041],"length":1,"stats":{"Line":0}},{"line":43,"address":[198384,198112],"length":1,"stats":{"Line":0}},{"line":47,"address":[198160,198204],"length":1,"stats":{"Line":0}},{"line":48,"address":[198307,198372],"length":1,"stats":{"Line":0}},{"line":51,"address":[198329],"length":1,"stats":{"Line":0}},{"line":54,"address":[198416],"length":1,"stats":{"Line":0}},{"line":56,"address":[198448],"length":1,"stats":{"Line":0}},{"line":66,"address":[198528],"length":1,"stats":{"Line":0}},{"line":67,"address":[198533],"length":1,"stats":{"Line":0}},{"line":70,"address":[198544],"length":1,"stats":{"Line":0}},{"line":71,"address":[198561],"length":1,"stats":{"Line":0}},{"line":74,"address":[198608],"length":1,"stats":{"Line":0}},{"line":75,"address":[198616],"length":1,"stats":{"Line":0}},{"line":78,"address":[198624],"length":1,"stats":{"Line":0}},{"line":79,"address":[198632],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","reaching_defs.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct ReachingDefs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for ReachingDefs\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = BTreeSet::\u003cFact\u003e::new();\n\n        for gen_fact in \u0026facts.gen_facts {\n            if !facts.kill_facts.contains(gen_fact) {\n                transferred.insert(gen_fact.clone());\n            }\n        }\n\n        for in_fact in \u0026facts.in_facts {\n            if !facts.kill_facts.contains(in_fact) {\n                transferred.insert(in_fact.clone());\n            }\n        }\n\n        for transfer_fact in to_transfer {\n            if !facts.kill_facts.contains(\u0026transfer_fact) {\n                transferred.insert(transfer_fact);\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        //TODO: need to be able to possibly act on function arguments for gen/kill\n        // e.g. reaching defs on function arguments\n\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n\nimpl\u003c'a\u003e ReachingDefs\u003c'a\u003e\n// TODO: supertrait?\n{\n    pub fn print(\u0026self) {\n        for label in self.idfa.control_flow.blocks.keys() {\n            let facts = self.idfa.facts.for_label(*label);\n            println!(\"{}:\", label);\n\n            print!(\"\\tGEN:\");\n            for gen_fact in \u0026facts.gen_facts {\n                print!(\"{} \", gen_fact);\n            }\n            println!();\n\n            print!(\"\\tKILL:\");\n            for kill_fact in \u0026facts.kill_facts {\n                print!(\"{} \", kill_fact);\n            }\n            println!();\n\n            print!(\"\\tIN:\");\n            for in_fact in \u0026facts.in_facts {\n                print!(\"{} \", in_fact);\n            }\n            println!();\n\n            print!(\"\\tOUT:\");\n            for out_fact in \u0026facts.out_facts {\n                print!(\"{} \", out_fact);\n            }\n            println!();\n        }\n    }\n}\n","traces":[{"line":17,"address":[184910,183952,185037],"length":1,"stats":{"Line":0}},{"line":18,"address":[183987],"length":1,"stats":{"Line":0}},{"line":20,"address":[184069,184119],"length":1,"stats":{"Line":0}},{"line":21,"address":[184232,184982],"length":1,"stats":{"Line":0}},{"line":22,"address":[185005],"length":1,"stats":{"Line":0}},{"line":26,"address":[184263],"length":1,"stats":{"Line":0}},{"line":27,"address":[184386,184923],"length":1,"stats":{"Line":0}},{"line":28,"address":[184946],"length":1,"stats":{"Line":0}},{"line":32,"address":[184409,184552,184872],"length":1,"stats":{"Line":0}},{"line":33,"address":[184641,184768],"length":1,"stats":{"Line":0}},{"line":34,"address":[184774,184862],"length":1,"stats":{"Line":0}},{"line":38,"address":[184689],"length":1,"stats":{"Line":0}},{"line":41,"address":[185925,185072],"length":1,"stats":{"Line":0}},{"line":45,"address":[185106],"length":1,"stats":{"Line":0}},{"line":46,"address":[185235],"length":1,"stats":{"Line":0}},{"line":48,"address":[185261,185292],"length":1,"stats":{"Line":0}},{"line":49,"address":[185369,185532],"length":1,"stats":{"Line":0}},{"line":50,"address":[185960,185592],"length":1,"stats":{"Line":0}},{"line":52,"address":[185800,185637],"length":1,"stats":{"Line":0}},{"line":53,"address":[185860,185913],"length":1,"stats":{"Line":0}},{"line":59,"address":[186256,185984],"length":1,"stats":{"Line":0}},{"line":63,"address":[186076,186032],"length":1,"stats":{"Line":0}},{"line":64,"address":[186244,186179],"length":1,"stats":{"Line":0}},{"line":67,"address":[186201],"length":1,"stats":{"Line":0}},{"line":70,"address":[186288],"length":1,"stats":{"Line":0}},{"line":72,"address":[186320],"length":1,"stats":{"Line":0}},{"line":82,"address":[186400],"length":1,"stats":{"Line":0}},{"line":83,"address":[186405],"length":1,"stats":{"Line":0}},{"line":86,"address":[186416],"length":1,"stats":{"Line":0}},{"line":87,"address":[186433],"length":1,"stats":{"Line":0}},{"line":90,"address":[186480],"length":1,"stats":{"Line":0}},{"line":91,"address":[186488],"length":1,"stats":{"Line":0}},{"line":94,"address":[186496],"length":1,"stats":{"Line":0}},{"line":95,"address":[186504],"length":1,"stats":{"Line":0}},{"line":102,"address":[186512],"length":1,"stats":{"Line":0}},{"line":103,"address":[186532],"length":1,"stats":{"Line":0}},{"line":104,"address":[186654],"length":1,"stats":{"Line":0}},{"line":105,"address":[186686],"length":1,"stats":{"Line":0}},{"line":107,"address":[186782],"length":1,"stats":{"Line":0}},{"line":108,"address":[186820,186873],"length":1,"stats":{"Line":0}},{"line":109,"address":[186941],"length":1,"stats":{"Line":0}},{"line":111,"address":[187042],"length":1,"stats":{"Line":0}},{"line":113,"address":[187076],"length":1,"stats":{"Line":0}},{"line":114,"address":[187114],"length":1,"stats":{"Line":0}},{"line":115,"address":[187225],"length":1,"stats":{"Line":0}},{"line":117,"address":[187326],"length":1,"stats":{"Line":0}},{"line":119,"address":[187360],"length":1,"stats":{"Line":0}},{"line":120,"address":[187398],"length":1,"stats":{"Line":0}},{"line":121,"address":[187505],"length":1,"stats":{"Line":0}},{"line":123,"address":[187606],"length":1,"stats":{"Line":0}},{"line":125,"address":[187640],"length":1,"stats":{"Line":0}},{"line":126,"address":[187678],"length":1,"stats":{"Line":0}},{"line":127,"address":[187789],"length":1,"stats":{"Line":0}},{"line":129,"address":[187890],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa.rs"],"content":"pub mod block_args;\nmod idfa_base;\npub mod live_vars;\npub mod reaching_defs;\n\npub use block_args::BlockArgs;\npub use idfa_base::Facts;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","control_flow.rs"],"content":"use crate::{\n    frontend::sourceloc::SourceLoc,\n    hashmap_ooo_iter::{HashMapOOOIter, HashMapOOOIterMut},\n};\n\nuse super::ir;\nuse serde::Serialize;\nuse std::{\n    collections::{HashMap, HashSet, VecDeque},\n    fmt::Debug,\n    usize,\n};\n\n/*\n    A ControlFlow represents the notion of ownership over basic blocks. At the end of linearization of a section of code,\n    all relevant basic blocks will be owned by a single control flow. During linearization control flows can branch\n    correspondingly with actual branches in the code, as they are linarized. Each branch gets its own control flow,\n    which owns only the blocks relevant to the contents of branch. When the linearization of each branch is complete,\n    its control flow is merged back to the one from which it was branched. The original brancher then takes ownership\n    of all blocks of the branchee.\n*/\n\n#[derive(Debug, Serialize)]\npub struct ControlFlow {\n    pub blocks: HashMap\u003cusize, ir::BasicBlock\u003e,\n    pub max_block: usize,\n}\n\nimpl ControlFlow {\n    pub fn new() -\u003e Self {\n        let mut starter_blocks = HashMap::\u003cusize, ir::BasicBlock\u003e::new();\n        starter_blocks.insert(0, ir::BasicBlock::new(0));\n        starter_blocks.insert(1, ir::BasicBlock::new(1));\n        ControlFlow {\n            blocks: starter_blocks,\n            max_block: 1,\n        }\n    }\n\n    pub fn block_for_label(\u0026self, label: \u0026usize) -\u003e \u0026ir::BasicBlock {\n        self.blocks.get(label).unwrap()\n    }\n\n    fn block_mut_for_label(\u0026mut self, label: usize) -\u003e \u0026mut ir::BasicBlock {\n        self.blocks\n            .entry(label)\n            .or_insert(ir::BasicBlock::new(label))\n    }\n\n    pub fn next_block(\u0026mut self) -\u003e usize {\n        self.max_block += 1;\n        self.max_block\n    }\n\n    // appends the given statement to the block with the label provided\n    // returns: (Option\u003cusize\u003e, Option\u003cusize\u003e) referring to (if the statement is a branch):\n    // block targeted by branch\n    // block control flow ends up in if the branch is not taken (conditional branches only)\n    // retrurns an option to a reference to the field containing the destination label of the false jump\n    // iff the statement was a conditional jump which forced the end of the block\n    pub fn append_statement_to_block(\n        \u0026mut self,\n        statement: ir::IrLine,\n        label: usize,\n    ) -\u003e (Option\u003cusize\u003e, Option\u003cusize\u003e) {\n        self.append_statement_to_block_raw(statement.clone(), label);\n\n        match \u0026statement.operation {\n            ir::Operations::Jump(jump) =\u003e {\n                let target = jump.destination_block;\n                match \u0026jump.condition {\n                    ir::JumpCondition::Unconditional =\u003e (Some(target), None),\n                    _ =\u003e {\n                        let false_label = self.next_block();\n                        let block_exit = ir::IrLine::new_jump(\n                            SourceLoc::none(),\n                            false_label,\n                            ir::JumpCondition::Unconditional,\n                        );\n                        self.append_statement_to_block_raw(block_exit, label);\n                        (Some(target), Some(false_label))\n                    }\n                }\n            }\n            _ =\u003e (None, None),\n        }\n    }\n\n    fn append_statement_to_block_raw(\u0026mut self, statement: ir::IrLine, label: usize) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(operands) =\u003e {\n                let target_block = operands.destination_block;\n\n                self.block_mut_for_label(target_block)\n                    .predecessors\n                    .insert(label);\n                self.block_mut_for_label(label)\n                    .successors\n                    .insert(target_block);\n            }\n            _ =\u003e {}\n        };\n\n        self.block_mut_for_label(label).statements.push(statement);\n    }\n\n    pub fn to_graphviz(\u0026self) {\n        print!(\"digraph {{fontname=\\\"consolas\\\"; node[shape=box; fontname=\\\"consolas\\\"; nojustify=true]; splines=ortho;\");\n        for block in self.blocks.values() {\n            let mut block_arg_string = String::new();\n            for arg in \u0026block.arguments {\n                block_arg_string += \u0026format!(\"{} \", arg);\n            }\n\n            let mut block_string =\n                String::from(format!(\"Block {}({})\\n\", block.label, block_arg_string));\n            for statement in \u0026block.statements {\n                let stmt_str = \u0026String::from(format!(\"{}\\\\l\", statement)).replace(\"\\\"\", \"\\\\\\\"\");\n                block_string += stmt_str;\n            }\n\n            println!(\"{}[label=\\\"{}\\\\l\\\"]; \", block.label, block_string);\n\n            for successor in \u0026block.successors {\n                print!(\"{}-\u003e{};\", block.label, successor);\n            }\n        }\n\n        println!(\"}}\");\n    }\n}\n\npub struct ControlFlowIntoIter\u003cT\u003e {\n    postorder_stack: VecDeque\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for ControlFlowIntoIter\u003cT\u003e {\n    type Item = T;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_back()\n    }\n}\n\n// TODO: are the postorder and reverse postorder named opposite right now? Need to actually check this...\nimpl ControlFlow {\n    fn generate_postorder_stack(\u0026self) -\u003e Vec\u003cusize\u003e {\n        let mut postorder_stack = Vec::\u003cusize\u003e::new();\n        postorder_stack.clear();\n        let mut visited = HashSet::\u003cusize\u003e::new();\n\n        let mut dfs_stack = Vec::\u003cusize\u003e::new();\n        dfs_stack.push(0);\n\n        // go until done\n        while dfs_stack.len() \u003e 0 {\n            match dfs_stack.pop() {\n                Some(label) =\u003e {\n                    // only visit once\n                    if !visited.contains(\u0026label) {\n                        visited.insert(label);\n\n                        postorder_stack.push(label);\n\n                        for successor in \u0026self.block_for_label(\u0026label).successors {\n                            dfs_stack.push(*successor);\n                        }\n                    }\n                }\n                None =\u003e {}\n            }\n        }\n        postorder_stack\n    }\n\n    pub fn blocks_postorder(\u0026self) -\u003e HashMapOOOIter\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIter::new(\u0026self.blocks, postorder_stack)\n    }\n\n    pub fn blocks_postorder_mut(\u0026mut self) -\u003e HashMapOOOIterMut\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIterMut::new(\u0026mut self.blocks, postorder_stack)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::midend::ir::*;\n\n    #[test]\n    fn starter_blocks() {\n        let cf = ControlFlow::new();\n\n        assert!(cf.blocks.len() == 2);\n        assert!(cf.max_block == 1);\n    }\n\n    #[test]\n    fn get_block_for_label() {\n        let mut cf = ControlFlow::new();\n\n        assert_eq!(cf.block_for_label(\u00260).label, 0);\n\n        assert_eq!(cf.block_mut_for_label(0).label, 0);\n        assert_eq!(cf.block_mut_for_label(999).label, 999);\n    }\n\n    #[test]\n    fn append_statement_to_block() {\n        let mut cf = ControlFlow::new();\n\n        let assignment = IrLine::new_assignment(\n            SourceLoc::none(),\n            Operand::new_as_variable(\"dest\".into()),\n            Operand::new_as_variable(\"source\".into()),\n        );\n        assert_eq!(cf.append_statement_to_block(assignment, 0), (None, None));\n    }\n\n    #[test]\n    fn append_unconditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(SourceLoc::none(), 1, JumpCondition::Unconditional);\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), None));\n    }\n\n    #[test]\n    fn append_conditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a\".into()),\n                b: Operand::new_as_variable(\"eq_b\".into()),\n            }),\n        );\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), Some(2)));\n\n        let second_jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a2\".into()),\n                b: Operand::new_as_variable(\"eq_b2\".into()),\n            }),\n        );\n        assert_eq!(\n            cf.append_statement_to_block(second_jump, 0),\n            (Some(1), Some(3))\n        );\n    }\n}\n","traces":[{"line":30,"address":[420520,420256],"length":1,"stats":{"Line":1}},{"line":31,"address":[420278],"length":1,"stats":{"Line":2}},{"line":32,"address":[420361,420295],"length":1,"stats":{"Line":8}},{"line":33,"address":[420393],"length":1,"stats":{"Line":5}},{"line":40,"address":[420544],"length":1,"stats":{"Line":1}},{"line":41,"address":[420558],"length":1,"stats":{"Line":1}},{"line":44,"address":[420592],"length":1,"stats":{"Line":1}},{"line":45,"address":[420649,420625],"length":1,"stats":{"Line":2}},{"line":47,"address":[420639],"length":1,"stats":{"Line":1}},{"line":50,"address":[420672],"length":1,"stats":{"Line":4}},{"line":51,"address":[420725,420685],"length":1,"stats":{"Line":4}},{"line":52,"address":[420716],"length":1,"stats":{"Line":4}},{"line":61,"address":[421373,420752],"length":1,"stats":{"Line":1}},{"line":66,"address":[420813,420872],"length":1,"stats":{"Line":6}},{"line":68,"address":[420884],"length":1,"stats":{"Line":1}},{"line":69,"address":[420915],"length":1,"stats":{"Line":1}},{"line":70,"address":[420923],"length":1,"stats":{"Line":2}},{"line":71,"address":[420943],"length":1,"stats":{"Line":2}},{"line":72,"address":[421042],"length":1,"stats":{"Line":1}},{"line":74,"address":[421168,421128],"length":1,"stats":{"Line":2}},{"line":76,"address":[421176],"length":1,"stats":{"Line":1}},{"line":78,"address":[421206],"length":1,"stats":{"Line":1}},{"line":80,"address":[421259],"length":1,"stats":{"Line":1}},{"line":81,"address":[421281],"length":1,"stats":{"Line":1}},{"line":85,"address":[420959],"length":1,"stats":{"Line":1}},{"line":89,"address":[421762,421408,421737],"length":1,"stats":{"Line":3}},{"line":90,"address":[421446],"length":1,"stats":{"Line":3}},{"line":91,"address":[421498],"length":1,"stats":{"Line":2}},{"line":92,"address":[421506],"length":1,"stats":{"Line":2}},{"line":94,"address":[421526,421611],"length":1,"stats":{"Line":4}},{"line":97,"address":[421632],"length":1,"stats":{"Line":2}},{"line":104,"address":[421548,421675],"length":1,"stats":{"Line":2}},{"line":107,"address":[423440,421776,423661],"length":1,"stats":{"Line":0}},{"line":108,"address":[421796],"length":1,"stats":{"Line":0}},{"line":109,"address":[421829],"length":1,"stats":{"Line":0}},{"line":110,"address":[421970],"length":1,"stats":{"Line":0}},{"line":111,"address":[422085,421980],"length":1,"stats":{"Line":0}},{"line":112,"address":[422207,423449],"length":1,"stats":{"Line":0}},{"line":115,"address":[422222],"length":1,"stats":{"Line":0}},{"line":117,"address":[422479,422408],"length":1,"stats":{"Line":0}},{"line":118,"address":[423046,422591],"length":1,"stats":{"Line":0}},{"line":119,"address":[423376],"length":1,"stats":{"Line":0}},{"line":122,"address":[422606],"length":1,"stats":{"Line":0}},{"line":124,"address":[422742],"length":1,"stats":{"Line":0}},{"line":125,"address":[422949,422872],"length":1,"stats":{"Line":0}},{"line":129,"address":[421999],"length":1,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[423680,424383],"length":1,"stats":{"Line":0}},{"line":148,"address":[423710],"length":1,"stats":{"Line":0}},{"line":149,"address":[423746],"length":1,"stats":{"Line":0}},{"line":150,"address":[423799],"length":1,"stats":{"Line":0}},{"line":152,"address":[423814],"length":1,"stats":{"Line":0}},{"line":153,"address":[423855,423918],"length":1,"stats":{"Line":0}},{"line":156,"address":[423928],"length":1,"stats":{"Line":0}},{"line":157,"address":[424064,424004],"length":1,"stats":{"Line":0}},{"line":158,"address":[424098],"length":1,"stats":{"Line":0}},{"line":160,"address":[424127],"length":1,"stats":{"Line":0}},{"line":161,"address":[424152],"length":1,"stats":{"Line":0}},{"line":163,"address":[424172],"length":1,"stats":{"Line":0}},{"line":165,"address":[424212],"length":1,"stats":{"Line":0}},{"line":166,"address":[424356],"length":1,"stats":{"Line":0}},{"line":173,"address":[423956],"length":1,"stats":{"Line":0}},{"line":176,"address":[424432],"length":1,"stats":{"Line":0}},{"line":177,"address":[424455],"length":1,"stats":{"Line":0}},{"line":179,"address":[424474],"length":1,"stats":{"Line":0}},{"line":182,"address":[424496],"length":1,"stats":{"Line":0}},{"line":183,"address":[424519],"length":1,"stats":{"Line":0}},{"line":185,"address":[424538],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":69},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","operands.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::{linearizer, types::Type};\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub struct OperandName {\n    pub base_name: String,\n    pub ssa_number: Option\u003cusize\u003e,\n}\n\nimpl PartialEq for OperandName {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        (self.base_name == other.base_name) \u0026\u0026 (self.ssa_number == other.ssa_number)\n    }\n}\n\nimpl Eq for OperandName {}\n\nimpl PartialOrd for OperandName {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        Some(\n            self.base_name\n                .cmp(\u0026other.base_name)\n                .then(match self.ssa_number {\n                    Some(self_ssa_number) =\u003e match other.ssa_number {\n                        Some(other_ssa_number) =\u003e self_ssa_number.cmp(\u0026other_ssa_number),\n                        None =\u003e std::cmp::Ordering::Greater,\n                    },\n                    None =\u003e match other.ssa_number {\n                        Some(_) =\u003e std::cmp::Ordering::Less,\n                        None =\u003e std::cmp::Ordering::Equal,\n                    },\n                }),\n        )\n    }\n}\n\nimpl Ord for OperandName {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Display for OperandName {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self.ssa_number {\n            Some(number) =\u003e {\n                write!(f, \"{}.{}\", self.base_name, number)\n            }\n            None =\u003e write!(f, \"{}\", self.base_name),\n        }\n    }\n}\n\nimpl OperandName {\n    pub fn new_basic(base_name: String) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: None,\n        }\n    }\n\n    fn new_ssa(base_name: String, ssa_number: usize) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: Some(ssa_number),\n        }\n    }\n\n    pub fn into_non_ssa(mut self) -\u003e Self {\n        self.ssa_number = None;\n        self\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub enum Operand {\n    Variable(OperandName),\n    Temporary(OperandName),\n    UnsignedDecimalConstant(usize),\n}\n\nimpl Display for Operand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Variable(name) =\u003e {\n                // write!(f, \"[V {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::Temporary(name) =\u003e {\n                // write!(f, \"[T {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::UnsignedDecimalConstant(value) =\u003e {\n                // write!(f, \"[C {}]\", value)\n                write!(f, \"{}\", value)\n            }\n        }\n    }\n}\n\nimpl PartialEq for Operand {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.cmp(other) == std::cmp::Ordering::Equal\n    }\n}\n\nimpl Eq for Operand {}\n\nimpl PartialOrd for Operand {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        match (self, other) {\n            (Operand::Variable(var_self), Operand::Variable(var_other)) =\u003e {\n                Some(var_self.cmp(var_other))\n            }\n            (Operand::Temporary(temp_self), Operand::Temporary(temp_other)) =\u003e {\n                Some(temp_self.cmp(temp_other))\n            }\n            (\n                Operand::UnsignedDecimalConstant(value_self),\n                Operand::UnsignedDecimalConstant(value_other),\n            ) =\u003e Some(value_self.cmp(value_other)),\n            (_, _) =\u003e None,\n        }\n    }\n}\n\nimpl Ord for Operand {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        let partial_result = self.partial_cmp(other);\n\n        match partial_result {\n            Some(ordering) =\u003e ordering,\n            None =\u003e match (self, other) {\n                (Operand::Variable(_), Operand::Temporary(_)) =\u003e std::cmp::Ordering::Greater,\n                (Operand::Variable(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::Temporary(_), Operand::Variable(_)) =\u003e std::cmp::Ordering::Less,\n                (Operand::Temporary(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Variable(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Temporary(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n\n                (Operand::Variable(_), Operand::Variable(_))\n                | (Operand::Temporary(_), Operand::Temporary(_))\n                | (Operand::UnsignedDecimalConstant(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    panic!(\"Non-covered case in Operand::cmp\")\n                }\n            },\n        }\n    }\n}\n\nimpl Operand {\n    pub fn new_as_variable(identifier: String) -\u003e Self {\n        Operand::Variable(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_temporary(identifier: String) -\u003e Self {\n        Operand::Temporary(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_unsigned_decimal_constant(constant: usize) -\u003e Self {\n        Operand::UnsignedDecimalConstant(constant)\n    }\n\n    pub fn type_\u003c'a\u003e(\u0026self, context: \u0026'a linearizer::walkcontext::WalkContext) -\u003e \u0026'a Type {\n        match self {\n            Operand::Variable(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::Temporary(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::UnsignedDecimalConstant(value) =\u003e {\n                if *value \u003e (u32::MAX as usize) {\n                    \u0026Type::U64\n                } else if *value \u003e (u16::MAX as usize) {\n                    \u0026Type::U32\n                } else if *value \u003e (u8::MAX as usize) {\n                    \u0026Type::U16\n                } else {\n                    \u0026Type::U8\n                }\n            }\n        }\n    }\n\n    pub fn get_name(\u0026self) -\u003e Option\u003c\u0026OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n\n    pub fn get_name_mut(\u0026mut self) -\u003e Option\u003c\u0026mut OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n}\n\n/*\n groupings of operands\n*/\n\n#[derive(Debug, Serialize, Clone)]\npub struct DualSourceOperands {\n    pub a: Operand,\n    pub b: Operand,\n}\n\nimpl DualSourceOperands {\n    pub fn new(a: Operand, b: Operand) -\u003e Self {\n        DualSourceOperands { a, b }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct BinaryArithmeticOperands {\n    pub destination: Operand,\n    pub sources: DualSourceOperands,\n}\n\nimpl BinaryArithmeticOperands {\n    pub fn from(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryArithmeticOperands {\n            destination,\n            sources: DualSourceOperands::new(source_a, source_b),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct SourceDestOperands {\n    pub destination: Operand,\n    pub source: Operand,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub enum JumpCondition {\n    Unconditional,\n    Eq(DualSourceOperands),\n    NE(DualSourceOperands),\n    GT(DualSourceOperands),\n    LT(DualSourceOperands),\n    GE(DualSourceOperands),\n    LE(DualSourceOperands),\n}\n\nimpl Display for JumpCondition {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Unconditional =\u003e {\n                write!(f, \"jmp\")\n            }\n            Self::Eq(operands) =\u003e {\n                write!(f, \"jeq({}, {})\", operands.a, operands.b)\n            }\n            Self::NE(operands) =\u003e {\n                write!(f, \"jne({}, {})\", operands.a, operands.b)\n            }\n            Self::LT(operands) =\u003e {\n                write!(f, \"jl({}, {})\", operands.a, operands.b)\n            }\n            Self::GT(operands) =\u003e {\n                write!(f, \"jg({}, {})\", operands.a, operands.b)\n            }\n            Self::LE(operands) =\u003e {\n                write!(f, \"jle({}, {})\", operands.a, operands.b)\n            }\n            Self::GE(operands) =\u003e {\n                write!(f, \"jge({}, {})\", operands.a, operands.b)\n            }\n        }\n    }\n}\n\npub type OrderedArgumentList = Vec\u003cOperand\u003e;\n\nfn arg_list_to_string(args: \u0026OrderedArgumentList) -\u003e String {\n    let mut arg_string = String::new();\n    for arg in args {\n        if arg_string.len() \u003e 0 {\n            arg_string += \u0026\",\";\n        }\n\n        arg_string += \u0026format!(\"{}\", arg);\n    }\n    arg_string\n}\n\n/// ## Function Call Operands\n#[derive(Debug, Serialize, Clone)]\npub struct FunctionCallOperands {\n    pub function_name: String,\n    pub arguments: OrderedArgumentList,\n    pub return_value_to: Option\u003cOperand\u003e,\n}\n\nimpl Display for FunctionCallOperands {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}({})\",\n            self.function_name,\n            arg_list_to_string(\u0026self.arguments)\n        )\n    }\n}\n\nimpl FunctionCallOperands {\n    pub fn new(\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self {\n            function_name: name.into(),\n            arguments,\n            return_value_to,\n        }\n    }\n}\n\n/// ## Method Call Operands\n#[derive(Debug, Serialize, Clone)]\npub struct MethodCallOperands {\n    pub receiver: Operand,\n    pub call: FunctionCallOperands,\n}\n\nimpl Display for MethodCallOperands {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}.{}\", self.receiver, self.call)\n    }\n}\n\nimpl MethodCallOperands {\n    pub fn new(\n        receiver: Operand,\n        method_name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self {\n            receiver,\n            call: FunctionCallOperands::new(method_name, arguments, return_value_to),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct FieldReadOperands {\n    pub receiver: Operand,\n    pub field_name: String,\n    pub destination: Operand,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct FieldWriteOperands {\n    pub receiver: Operand,\n    pub field_name: String,\n    pub source: Operand,\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::midend::ir::*;\n\n    #[test]\n    fn operand_name_ord() {\n        // non-ssa operand names\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"b\".into())),\n            Ordering::Less\n        );\n\n        // ssa operand names\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 4)),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 5)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"b\".into(), 4)),\n            Ordering::Less\n        );\n\n        // mixed ssa and non-ssa\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_ssa(\"a\".into(), 1)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 1).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn operand_name_into_non_ssa() {\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 123).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n    }\n\n    #[test]\n    fn operand_eq() {\n        // variable against other types\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // temporary against other types\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // unsigned decimal constant against other types\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n    }\n\n    #[test]\n    fn operand_get_name() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name(),\n            None\n        );\n    }\n\n    #[test]\n    fn operand_get_name_mut() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name_mut(),\n            None\n        );\n    }\n}\n","traces":[{"line":14,"address":[322384],"length":1,"stats":{"Line":3}},{"line":15,"address":[322407],"length":1,"stats":{"Line":3}},{"line":22,"address":[322464],"length":1,"stats":{"Line":1}},{"line":24,"address":[322495,322576,322487],"length":1,"stats":{"Line":3}},{"line":25,"address":[322491],"length":1,"stats":{"Line":1}},{"line":26,"address":[322509],"length":1,"stats":{"Line":1}},{"line":27,"address":[322527],"length":1,"stats":{"Line":1}},{"line":28,"address":[322606],"length":1,"stats":{"Line":1}},{"line":29,"address":[322636],"length":1,"stats":{"Line":1}},{"line":31,"address":[322551],"length":1,"stats":{"Line":1}},{"line":32,"address":[322560],"length":1,"stats":{"Line":1}},{"line":33,"address":[322567],"length":1,"stats":{"Line":1}},{"line":41,"address":[322656],"length":1,"stats":{"Line":1}},{"line":42,"address":[322670],"length":1,"stats":{"Line":1}},{"line":47,"address":[322704],"length":1,"stats":{"Line":1}},{"line":48,"address":[322737],"length":1,"stats":{"Line":1}},{"line":49,"address":[322755],"length":1,"stats":{"Line":0}},{"line":50,"address":[322764],"length":1,"stats":{"Line":0}},{"line":52,"address":[322897],"length":1,"stats":{"Line":1}},{"line":58,"address":[323024],"length":1,"stats":{"Line":3}},{"line":65,"address":[323088],"length":1,"stats":{"Line":1}},{"line":68,"address":[323096],"length":1,"stats":{"Line":1}},{"line":72,"address":[323152],"length":1,"stats":{"Line":1}},{"line":73,"address":[323163],"length":1,"stats":{"Line":1}},{"line":74,"address":[323189],"length":1,"stats":{"Line":1}},{"line":86,"address":[323216],"length":1,"stats":{"Line":0}},{"line":87,"address":[323248],"length":1,"stats":{"Line":0}},{"line":88,"address":[323287],"length":1,"stats":{"Line":0}},{"line":90,"address":[323296],"length":1,"stats":{"Line":0}},{"line":92,"address":[323384],"length":1,"stats":{"Line":0}},{"line":94,"address":[323393],"length":1,"stats":{"Line":0}},{"line":96,"address":[323502],"length":1,"stats":{"Line":0}},{"line":98,"address":[323514],"length":1,"stats":{"Line":0}},{"line":105,"address":[323648],"length":1,"stats":{"Line":1}},{"line":106,"address":[323662],"length":1,"stats":{"Line":1}},{"line":113,"address":[323755,323696],"length":1,"stats":{"Line":1}},{"line":114,"address":[323757,323710],"length":1,"stats":{"Line":2}},{"line":115,"address":[323796],"length":1,"stats":{"Line":1}},{"line":116,"address":[323824],"length":1,"stats":{"Line":1}},{"line":118,"address":[323849],"length":1,"stats":{"Line":1}},{"line":119,"address":[323877],"length":1,"stats":{"Line":1}},{"line":121,"address":[323888],"length":1,"stats":{"Line":1}},{"line":125,"address":[323835],"length":1,"stats":{"Line":1}},{"line":131,"address":[323936],"length":1,"stats":{"Line":1}},{"line":132,"address":[323969],"length":1,"stats":{"Line":1}},{"line":134,"address":[323978],"length":1,"stats":{"Line":1}},{"line":135,"address":[324002],"length":1,"stats":{"Line":1}},{"line":136,"address":[324032],"length":1,"stats":{"Line":1}},{"line":137,"address":[324223],"length":1,"stats":{"Line":1}},{"line":139,"address":[324230],"length":1,"stats":{"Line":1}},{"line":141,"address":[324247],"length":1,"stats":{"Line":1}},{"line":143,"address":[324254],"length":1,"stats":{"Line":1}},{"line":146,"address":[324261],"length":1,"stats":{"Line":1}},{"line":149,"address":[324268],"length":1,"stats":{"Line":1}},{"line":155,"address":[324182],"length":1,"stats":{"Line":0}},{"line":163,"address":[324288],"length":1,"stats":{"Line":1}},{"line":164,"address":[324301],"length":1,"stats":{"Line":1}},{"line":167,"address":[324368],"length":1,"stats":{"Line":2}},{"line":168,"address":[324381],"length":1,"stats":{"Line":2}},{"line":171,"address":[324448],"length":1,"stats":{"Line":1}},{"line":172,"address":[324456],"length":1,"stats":{"Line":1}},{"line":175,"address":[324480,325104],"length":1,"stats":{"Line":1}},{"line":176,"address":[324513,325079],"length":1,"stats":{"Line":2}},{"line":177,"address":[324957,324574,325060,325002,324588],"length":1,"stats":{"Line":0}},{"line":178,"address":[324583],"length":1,"stats":{"Line":0}},{"line":179,"address":[325097,324756,324619,324994],"length":1,"stats":{"Line":0}},{"line":181,"address":[324659,325380,324639,325332,325439],"length":1,"stats":{"Line":0}},{"line":182,"address":[324651],"length":1,"stats":{"Line":0}},{"line":183,"address":[325372,325134,324696,325471],"length":1,"stats":{"Line":0}},{"line":185,"address":[324711],"length":1,"stats":{"Line":1}},{"line":186,"address":[324731,325509,325576],"length":1,"stats":{"Line":2}},{"line":187,"address":[325494],"length":1,"stats":{"Line":0}},{"line":188,"address":[325542,325483],"length":1,"stats":{"Line":1}},{"line":189,"address":[325527],"length":1,"stats":{"Line":0}},{"line":190,"address":[325516,325559],"length":1,"stats":{"Line":2}},{"line":191,"address":[325561],"length":1,"stats":{"Line":0}},{"line":193,"address":[325544],"length":1,"stats":{"Line":1}},{"line":199,"address":[325600],"length":1,"stats":{"Line":1}},{"line":200,"address":[325610],"length":1,"stats":{"Line":1}},{"line":201,"address":[325647],"length":1,"stats":{"Line":1}},{"line":202,"address":[325668],"length":1,"stats":{"Line":1}},{"line":203,"address":[325684],"length":1,"stats":{"Line":1}},{"line":207,"address":[325712],"length":1,"stats":{"Line":1}},{"line":208,"address":[325722],"length":1,"stats":{"Line":1}},{"line":209,"address":[325759],"length":1,"stats":{"Line":1}},{"line":210,"address":[325780],"length":1,"stats":{"Line":1}},{"line":211,"address":[325796],"length":1,"stats":{"Line":1}},{"line":227,"address":[325824],"length":1,"stats":{"Line":1}},{"line":239,"address":[326058,325888],"length":1,"stats":{"Line":1}},{"line":242,"address":[325960],"length":1,"stats":{"Line":1}},{"line":265,"address":[326080],"length":1,"stats":{"Line":0}},{"line":266,"address":[326113],"length":1,"stats":{"Line":0}},{"line":268,"address":[326144],"length":1,"stats":{"Line":0}},{"line":270,"address":[326192],"length":1,"stats":{"Line":0}},{"line":271,"address":[326209],"length":1,"stats":{"Line":0}},{"line":273,"address":[326371],"length":1,"stats":{"Line":0}},{"line":274,"address":[326388],"length":1,"stats":{"Line":0}},{"line":276,"address":[326729],"length":1,"stats":{"Line":0}},{"line":277,"address":[326746],"length":1,"stats":{"Line":0}},{"line":279,"address":[326550],"length":1,"stats":{"Line":0}},{"line":280,"address":[326567],"length":1,"stats":{"Line":0}},{"line":282,"address":[327087],"length":1,"stats":{"Line":0}},{"line":283,"address":[327104],"length":1,"stats":{"Line":0}},{"line":285,"address":[326908],"length":1,"stats":{"Line":0}},{"line":286,"address":[326925],"length":1,"stats":{"Line":0}},{"line":294,"address":[327795,327280],"length":1,"stats":{"Line":0}},{"line":295,"address":[327315],"length":1,"stats":{"Line":0}},{"line":296,"address":[327393,327325],"length":1,"stats":{"Line":0}},{"line":297,"address":[327473,327534],"length":1,"stats":{"Line":0}},{"line":298,"address":[327560],"length":1,"stats":{"Line":0}},{"line":301,"address":[327588,327553],"length":1,"stats":{"Line":0}},{"line":303,"address":[327495],"length":1,"stats":{"Line":0}},{"line":315,"address":[328068,327824],"length":1,"stats":{"Line":0}},{"line":316,"address":[327863,327968,327917],"length":1,"stats":{"Line":0}},{"line":320,"address":[327882],"length":1,"stats":{"Line":0}},{"line":326,"address":[328096,328333,328354],"length":1,"stats":{"Line":0}},{"line":332,"address":[328139],"length":1,"stats":{"Line":0}},{"line":347,"address":[328368],"length":1,"stats":{"Line":0}},{"line":348,"address":[328407],"length":1,"stats":{"Line":0}},{"line":353,"address":[328528,328740],"length":1,"stats":{"Line":0}},{"line":361,"address":[328642],"length":1,"stats":{"Line":0}}],"covered":70,"coverable":121},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","operations.rs"],"content":"use serde::Serialize;\nuse std::{collections::HashMap, fmt::Display};\n\nuse crate::midend::{symtab::Function, types::Type};\n\nuse super::operands::*;\n\n/// ## Binary Operations\n#[derive(Debug, Serialize, Clone)]\npub enum BinaryOperations {\n    Add(BinaryArithmeticOperands),\n    Subtract(BinaryArithmeticOperands),\n    Multiply(BinaryArithmeticOperands),\n    Divide(BinaryArithmeticOperands),\n    LThan(BinaryArithmeticOperands),\n    GThan(BinaryArithmeticOperands),\n    LThanE(BinaryArithmeticOperands),\n    GThanE(BinaryArithmeticOperands),\n    Equals(BinaryArithmeticOperands),\n    NotEquals(BinaryArithmeticOperands),\n}\n\nimpl Display for BinaryOperations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} + {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Subtract(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} - {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Multiply(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} * {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Divide(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} / {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Equals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} == {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::NotEquals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} != {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n        }\n    }\n}\n\nimpl BinaryOperations {\n    pub fn new_add(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Add(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_subtract(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Subtract(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_multiply(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Multiply(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_divide(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Divide(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Equals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_not_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::NotEquals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn raw_operands(\u0026self) -\u003e \u0026BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n\n    pub fn raw_operands_mut(\u0026mut self) -\u003e \u0026mut BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n}\n\n/// ## Jump\n#[derive(Debug, Serialize, Clone)]\npub struct JumpOperation {\n    pub destination_block: usize,\n    pub block_args: HashMap\u003cOperandName, OperandName\u003e,\n    pub condition: JumpCondition,\n}\n\nimpl Display for JumpOperation {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut block_args_string = String::new();\n        for (arg, operand) in \u0026self.block_args {\n            block_args_string += \u0026format!(\"{}:{} \", arg, operand);\n        }\n        write!(\n            f,\n            \"{} Block{}({})\",\n            self.condition, self.destination_block, block_args_string\n        )\n    }\n}\n\nimpl JumpOperation {\n    pub fn new(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self {\n            destination_block,\n            block_args: HashMap::new(),\n            condition,\n        }\n    }\n}\n\n/// ## Enum of all operations\n#[derive(Debug, Serialize, Clone)]\npub enum Operations {\n    Assignment(SourceDestOperands),\n    BinaryOperation(BinaryOperations),\n    Jump(JumpOperation),\n    FunctionCall(FunctionCallOperands),\n    MethodCall(MethodCallOperands),\n    FieldRead(FieldReadOperands),\n    FieldWrite(FieldWriteOperands),\n}\n\nimpl Display for Operations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Assignment(assignment) =\u003e {\n                write!(f, \"{} = {}\", assignment.destination, assignment.source)\n            }\n            Self::BinaryOperation(binary_operation) =\u003e write!(f, \"{}\", binary_operation),\n            Self::Jump(jump) =\u003e write!(f, \"{}\", jump),\n            Self::FunctionCall(function_call) =\u003e write!(f, \"{}\", function_call),\n            Self::MethodCall(method_call) =\u003e write!(f, \"{}\", method_call),\n            Self::FieldRead(field_read) =\u003e write!(\n                f,\n                \"{} = {}.{}\",\n                field_read.destination, field_read.receiver, field_read.field_name\n            ),\n            Self::FieldWrite(field_write) =\u003e write!(\n                f,\n                \"{}.{} = {}\",\n                field_write.receiver, field_write.field_name, field_write.source\n            ),\n        }\n    }\n}\n\nimpl Operations {\n    pub fn new_assignment(destination: Operand, source: Operand) -\u003e Self {\n        Self::Assignment(SourceDestOperands {\n            destination,\n            source,\n        })\n    }\n\n    pub fn new_jump(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self::Jump(JumpOperation::new(destination_block, condition))\n    }\n\n    pub fn new_function_call(\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::FunctionCall(FunctionCallOperands::new(name, arguments, return_value_to))\n    }\n\n    pub fn new_method_call(\n        receiver: Operand,\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::MethodCall(MethodCallOperands::new(\n            receiver,\n            name,\n            arguments,\n            return_value_to,\n        ))\n    }\n\n    pub fn new_field_read(receiver: Operand, field_name: String, destination: Operand) -\u003e Self {\n        Self::FieldRead(FieldReadOperands {\n            receiver,\n            field_name,\n            destination,\n        })\n    }\n\n    pub fn new_field_write(source: Operand, receiver: Operand, field_name: String) -\u003e Self {\n        Self::FieldWrite(FieldWriteOperands {\n            receiver,\n            field_name,\n            source,\n        })\n    }\n}\n","traces":[{"line":24,"address":[655648],"length":1,"stats":{"Line":0}},{"line":25,"address":[655681],"length":1,"stats":{"Line":0}},{"line":26,"address":[655717],"length":1,"stats":{"Line":0}},{"line":27,"address":[655734],"length":1,"stats":{"Line":0}},{"line":33,"address":[655947],"length":1,"stats":{"Line":0}},{"line":34,"address":[655964],"length":1,"stats":{"Line":0}},{"line":40,"address":[656183],"length":1,"stats":{"Line":0}},{"line":41,"address":[656200],"length":1,"stats":{"Line":0}},{"line":47,"address":[656419],"length":1,"stats":{"Line":0}},{"line":48,"address":[656436],"length":1,"stats":{"Line":0}},{"line":54,"address":[656655],"length":1,"stats":{"Line":0}},{"line":55,"address":[656672],"length":1,"stats":{"Line":0}},{"line":61,"address":[656891],"length":1,"stats":{"Line":0}},{"line":62,"address":[656908],"length":1,"stats":{"Line":0}},{"line":68,"address":[657127],"length":1,"stats":{"Line":0}},{"line":69,"address":[657144],"length":1,"stats":{"Line":0}},{"line":75,"address":[657363],"length":1,"stats":{"Line":0}},{"line":76,"address":[657380],"length":1,"stats":{"Line":0}},{"line":82,"address":[657599],"length":1,"stats":{"Line":0}},{"line":83,"address":[657616],"length":1,"stats":{"Line":0}},{"line":89,"address":[657835],"length":1,"stats":{"Line":0}},{"line":90,"address":[657852],"length":1,"stats":{"Line":0}},{"line":101,"address":[658080],"length":1,"stats":{"Line":1}},{"line":102,"address":[658097],"length":1,"stats":{"Line":1}},{"line":109,"address":[658160],"length":1,"stats":{"Line":1}},{"line":110,"address":[658177],"length":1,"stats":{"Line":2}},{"line":117,"address":[658240],"length":1,"stats":{"Line":0}},{"line":118,"address":[658257],"length":1,"stats":{"Line":0}},{"line":125,"address":[658320],"length":1,"stats":{"Line":0}},{"line":126,"address":[658337],"length":1,"stats":{"Line":0}},{"line":133,"address":[658400],"length":1,"stats":{"Line":0}},{"line":134,"address":[658417],"length":1,"stats":{"Line":0}},{"line":141,"address":[658480],"length":1,"stats":{"Line":0}},{"line":142,"address":[658497],"length":1,"stats":{"Line":0}},{"line":149,"address":[658560],"length":1,"stats":{"Line":0}},{"line":150,"address":[658577],"length":1,"stats":{"Line":0}},{"line":157,"address":[658640],"length":1,"stats":{"Line":0}},{"line":158,"address":[658657],"length":1,"stats":{"Line":0}},{"line":165,"address":[658720],"length":1,"stats":{"Line":0}},{"line":166,"address":[658737],"length":1,"stats":{"Line":0}},{"line":173,"address":[658800],"length":1,"stats":{"Line":0}},{"line":174,"address":[658817],"length":1,"stats":{"Line":0}},{"line":181,"address":[658880],"length":1,"stats":{"Line":1}},{"line":182,"address":[659034,659050,659002,658986,658970,659018,659066,658954,658935,658890],"length":1,"stats":{"Line":2}},{"line":183,"address":[659041],"length":1,"stats":{"Line":0}},{"line":196,"address":[659088],"length":1,"stats":{"Line":1}},{"line":197,"address":[659242,659210,659194,659258,659162,659274,659098,659143,659178,659226],"length":1,"stats":{"Line":2}},{"line":198,"address":[659134],"length":1,"stats":{"Line":0}},{"line":221,"address":[659296,660002],"length":1,"stats":{"Line":0}},{"line":222,"address":[659334],"length":1,"stats":{"Line":0}},{"line":223,"address":[659344,659401],"length":1,"stats":{"Line":0}},{"line":224,"address":[659772,659548],"length":1,"stats":{"Line":0}},{"line":226,"address":[659571],"length":1,"stats":{"Line":0}},{"line":235,"address":[660032,660202],"length":1,"stats":{"Line":3}},{"line":238,"address":[660072],"length":1,"stats":{"Line":3}},{"line":257,"address":[660224],"length":1,"stats":{"Line":0}},{"line":258,"address":[660257],"length":1,"stats":{"Line":0}},{"line":259,"address":[660313],"length":1,"stats":{"Line":0}},{"line":260,"address":[660330],"length":1,"stats":{"Line":0}},{"line":262,"address":[660477],"length":1,"stats":{"Line":0}},{"line":263,"address":[660605],"length":1,"stats":{"Line":0}},{"line":264,"address":[660729],"length":1,"stats":{"Line":0}},{"line":265,"address":[660857],"length":1,"stats":{"Line":0}},{"line":266,"address":[660985],"length":1,"stats":{"Line":0}},{"line":271,"address":[661217],"length":1,"stats":{"Line":0}},{"line":281,"address":[661456],"length":1,"stats":{"Line":2}},{"line":282,"address":[661474],"length":1,"stats":{"Line":2}},{"line":288,"address":[661568],"length":1,"stats":{"Line":2}},{"line":289,"address":[661592],"length":1,"stats":{"Line":2}},{"line":292,"address":[661648],"length":1,"stats":{"Line":0}},{"line":297,"address":[661678],"length":1,"stats":{"Line":0}},{"line":300,"address":[661744],"length":1,"stats":{"Line":0}},{"line":306,"address":[661777],"length":1,"stats":{"Line":0}},{"line":314,"address":[661840],"length":1,"stats":{"Line":0}},{"line":315,"address":[661866],"length":1,"stats":{"Line":0}},{"line":322,"address":[662000],"length":1,"stats":{"Line":0}},{"line":323,"address":[662040],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":77},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","tests.rs"],"content":"use crate::midend::ir::*;\n\n#[test]\nfn ir_line_new_assignment() {\n    let assignment = IrLine::new_assignment(\n        SourceLoc::new(123, 456),\n        Operand::new_as_variable(\"a\".into()),\n        Operand::new_as_unsigned_decimal_constant(99),\n    );\n\n    assert_eq!(assignment.loc, SourceLoc::new(123, 456));\n    assert!(matches!(assignment.operation, Operations::Assignment(_)));\n}\n\n#[test]\nfn ir_line_new_binary_op() {\n    let binary_operation = IrLine::new_binary_op(\n        SourceLoc::new(123, 456),\n        BinaryOperations::new_add(\n            Operand::new_as_variable(\"result\".into()),\n            Operand::new_as_variable(\"a\".into()),\n            Operand::new_as_variable(\"b\".into()),\n        ),\n    );\n\n    assert_eq!(binary_operation.loc, SourceLoc::new(123, 456));\n    assert!(matches!(\n        binary_operation.operation,\n        Operations::BinaryOperation(_)\n    ));\n}\n\n#[test]\nfn ir_line_new_jump() {\n    let jump = IrLine::new_jump(SourceLoc::new(123, 456), 8, JumpCondition::Unconditional);\n\n    assert_eq!(jump.loc, SourceLoc::new(123, 456));\n    assert!(matches!(jump.operation, Operations::Jump(_)));\n}\n\n#[cfg(test)]\nfn operand_from_string(name: \u0026str) -\u003e Operand {\n    Operand::new_as_variable(name.into())\n}\n\n#[cfg(test)]\nfn line_from_op(operation: Operations) -\u003e IrLine {\n    IrLine::new(SourceLoc::new(0, 0), operation)\n}\n\n#[cfg(test)]\nfn operand_name_from_string(name: \u0026str) -\u003e OperandName {\n    OperandName::new_basic(name.into())\n}\n\n#[test]\nfn read_operand_names() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n\n#[test]\nfn read_operand_names_mut() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir.rs"],"content":"pub mod control_flow;\npub mod operands;\npub mod operations;\n#[cfg(test)]\nmod tests;\n\nuse std::collections::BTreeSet;\nuse std::fmt::Display;\n\nuse crate::frontend::sourceloc::SourceLoc;\nuse crate::midend::ir;\nuse serde::Serialize;\n\npub use control_flow::ControlFlow;\npub use operands::*;\npub use operations::*;\n\n#[derive(Debug, Serialize, Clone)]\npub struct IrLine {\n    pub loc: SourceLoc,\n    pub operation: Operations,\n}\n\nimpl Display for IrLine {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.operation)\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct BasicBlock {\n    pub label: usize,\n    pub statements: Vec\u003cir::IrLine\u003e,\n    pub arguments: BTreeSet\u003cir::OperandName\u003e,\n    pub successors: BTreeSet\u003cusize\u003e,\n    pub predecessors: BTreeSet\u003cusize\u003e,\n}\n\nimpl BasicBlock {\n    pub fn new(label: usize) -\u003e Self {\n        BasicBlock {\n            statements: Vec::new(),\n            label: label,\n            arguments: BTreeSet::new(),\n            successors: BTreeSet::\u003cusize\u003e::new(),\n            predecessors: BTreeSet::\u003cusize\u003e::new(),\n        }\n    }\n}\n\nimpl IrLine {\n    fn new(loc: SourceLoc, operation: Operations) -\u003e Self {\n        IrLine {\n            loc: loc,\n            operation: operation,\n        }\n    }\n\n    pub fn new_assignment(loc: SourceLoc, destination: Operand, source: Operand) -\u003e Self {\n        Self::new(loc, Operations::new_assignment(destination, source))\n    }\n\n    pub fn new_binary_op(loc: SourceLoc, op: BinaryOperations) -\u003e Self {\n        Self::new(loc, Operations::BinaryOperation(op))\n    }\n\n    pub fn new_jump(\n        loc: SourceLoc,\n        destination_block: usize,\n        condition: operands::JumpCondition,\n    ) -\u003e Self {\n        Self::new(loc, Operations::new_jump(destination_block, condition))\n    }\n\n    pub fn new_function_call(\n        loc: SourceLoc,\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_function_call(name, arguments, return_value_to),\n        )\n    }\n\n    pub fn new_method_call(\n        loc: SourceLoc,\n        receiver: Operand,\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_method_call(receiver, name, arguments, return_value_to),\n        )\n    }\n\n    pub fn new_field_read(\n        loc: SourceLoc,\n        receiver: Operand,\n        field_name: String,\n        destination: Operand,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_field_read(receiver, field_name, destination),\n        )\n    }\n\n    pub fn new_field_write(\n        source: Operand,\n        loc: SourceLoc,\n        receiver: Operand,\n        field_name: String,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_field_write(source, receiver, field_name),\n        )\n    }\n\n    pub fn read_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e match \u0026source_dest.source.get_name() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026operation.raw_operands().sources;\n                match sources.a.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values() {\n                    operand_names.push(arg);\n                }\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                for arg in \u0026function_call.arguments {\n                    match arg.get_name() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026method_call.call;\n                for arg in \u0026inner_function_call.arguments {\n                    match arg.get_name() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::FieldRead(field_read) =\u003e {\n                operand_names.push(field_read.receiver.get_name().unwrap());\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.source.get_name().unwrap());\n            }\n        }\n        operand_names\n    }\n\n    pub fn read_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e match source_dest.source.get_name_mut() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026mut operation.raw_operands_mut().sources;\n                match sources.a.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026mut jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values_mut() {\n                    operand_names.push(arg);\n                }\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                for arg in \u0026mut function_call.arguments {\n                    match arg.get_name_mut() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026mut method_call.call;\n                for arg in \u0026mut inner_function_call.arguments {\n                    match arg.get_name_mut() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::FieldRead(field_read) =\u003e {\n                operand_names.push(field_read.receiver.get_name_mut().unwrap());\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.source.get_name_mut().unwrap());\n            }\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operand_names.push(source_dest.destination.get_name().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands();\n                operand_names.push(arithmetic_operands.destination.get_name().unwrap());\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                if let Some(retval) = \u0026function_call.return_value_to {\n                    operand_names.push(retval.get_name().unwrap());\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026method_call.call;\n                if let Some(retval) = \u0026inner_function_call.return_value_to {\n                    operand_names.push(retval.get_name().unwrap());\n                }\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.receiver.get_name().unwrap());\n            }\n            Operations::Jump(_) | Operations::FieldRead(_) =\u003e {}\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operand_names.push(source_dest.destination.get_name_mut().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands_mut();\n                operand_names.push(arithmetic_operands.destination.get_name_mut().unwrap());\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                if let Some(retval) = \u0026mut function_call.return_value_to {\n                    operand_names.push(retval.get_name_mut().unwrap());\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026mut method_call.call;\n                if let Some(retval) = \u0026mut inner_function_call.return_value_to {\n                    operand_names.push(retval.get_name_mut().unwrap());\n                }\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.receiver.get_name_mut().unwrap());\n            }\n            Operations::Jump(_) | Operations::FieldRead(_) =\u003e {}\n        }\n\n        operand_names\n    }\n}\n","traces":[{"line":25,"address":[252704],"length":1,"stats":{"Line":0}},{"line":26,"address":[252728],"length":1,"stats":{"Line":0}},{"line":40,"address":[253131,252816],"length":1,"stats":{"Line":4}},{"line":42,"address":[252851],"length":1,"stats":{"Line":4}},{"line":44,"address":[252861],"length":1,"stats":{"Line":4}},{"line":45,"address":[252910],"length":1,"stats":{"Line":5}},{"line":46,"address":[252956],"length":1,"stats":{"Line":5}},{"line":52,"address":[253168],"length":1,"stats":{"Line":2}},{"line":59,"address":[253248],"length":1,"stats":{"Line":1}},{"line":60,"address":[253317],"length":1,"stats":{"Line":2}},{"line":63,"address":[253376],"length":1,"stats":{"Line":1}},{"line":64,"address":[253430],"length":1,"stats":{"Line":1}},{"line":67,"address":[253504],"length":1,"stats":{"Line":2}},{"line":72,"address":[253579],"length":1,"stats":{"Line":2}},{"line":75,"address":[253632],"length":1,"stats":{"Line":0}},{"line":83,"address":[253744],"length":1,"stats":{"Line":0}},{"line":87,"address":[253792],"length":1,"stats":{"Line":0}},{"line":96,"address":[253912],"length":1,"stats":{"Line":0}},{"line":100,"address":[253968],"length":1,"stats":{"Line":0}},{"line":108,"address":[254056],"length":1,"stats":{"Line":0}},{"line":112,"address":[254112],"length":1,"stats":{"Line":0}},{"line":120,"address":[254189],"length":1,"stats":{"Line":0}},{"line":124,"address":[256196,254240],"length":1,"stats":{"Line":1}},{"line":125,"address":[254287],"length":1,"stats":{"Line":1}},{"line":126,"address":[254300],"length":1,"stats":{"Line":1}},{"line":127,"address":[254365,254734],"length":1,"stats":{"Line":2}},{"line":128,"address":[254781,254878],"length":1,"stats":{"Line":2}},{"line":131,"address":[254410],"length":1,"stats":{"Line":1}},{"line":132,"address":[254422,254888],"length":1,"stats":{"Line":2}},{"line":133,"address":[254905],"length":1,"stats":{"Line":1}},{"line":134,"address":[254961,255020],"length":1,"stats":{"Line":2}},{"line":137,"address":[255027,255004],"length":1,"stats":{"Line":2}},{"line":138,"address":[255070],"length":1,"stats":{"Line":1}},{"line":142,"address":[254448],"length":1,"stats":{"Line":1}},{"line":143,"address":[255229,255251,254456,255163,255207,255185],"length":1,"stats":{"Line":6}},{"line":145,"address":[255217],"length":1,"stats":{"Line":1}},{"line":151,"address":[255273],"length":1,"stats":{"Line":1}},{"line":152,"address":[255399,255337],"length":1,"stats":{"Line":2}},{"line":155,"address":[255375,255406],"length":1,"stats":{"Line":2}},{"line":156,"address":[255449],"length":1,"stats":{"Line":1}},{"line":161,"address":[255508,255121],"length":1,"stats":{"Line":2}},{"line":162,"address":[255625],"length":1,"stats":{"Line":0}},{"line":165,"address":[254499],"length":1,"stats":{"Line":0}},{"line":166,"address":[255665,254514],"length":1,"stats":{"Line":0}},{"line":167,"address":[255765],"length":1,"stats":{"Line":0}},{"line":168,"address":[255825],"length":1,"stats":{"Line":0}},{"line":173,"address":[254552],"length":1,"stats":{"Line":0}},{"line":174,"address":[254567],"length":1,"stats":{"Line":0}},{"line":175,"address":[254582,255881],"length":1,"stats":{"Line":0}},{"line":176,"address":[255981],"length":1,"stats":{"Line":0}},{"line":177,"address":[256041],"length":1,"stats":{"Line":0}},{"line":182,"address":[254617],"length":1,"stats":{"Line":0}},{"line":183,"address":[254629,256089],"length":1,"stats":{"Line":0}},{"line":185,"address":[254652],"length":1,"stats":{"Line":0}},{"line":186,"address":[254667,256145],"length":1,"stats":{"Line":0}},{"line":189,"address":[254835],"length":1,"stats":{"Line":1}},{"line":192,"address":[258172,256224],"length":1,"stats":{"Line":1}},{"line":193,"address":[256271],"length":1,"stats":{"Line":1}},{"line":194,"address":[256284],"length":1,"stats":{"Line":1}},{"line":195,"address":[256349,256718],"length":1,"stats":{"Line":2}},{"line":196,"address":[256854,256757],"length":1,"stats":{"Line":2}},{"line":199,"address":[256394],"length":1,"stats":{"Line":1}},{"line":200,"address":[256406,256864],"length":1,"stats":{"Line":2}},{"line":201,"address":[256881],"length":1,"stats":{"Line":1}},{"line":202,"address":[256996,256937],"length":1,"stats":{"Line":2}},{"line":205,"address":[256980,257003],"length":1,"stats":{"Line":2}},{"line":206,"address":[257046],"length":1,"stats":{"Line":1}},{"line":210,"address":[256432],"length":1,"stats":{"Line":1}},{"line":211,"address":[257161,257139,256440,257227,257183,257205],"length":1,"stats":{"Line":6}},{"line":213,"address":[257237],"length":1,"stats":{"Line":1}},{"line":219,"address":[257249],"length":1,"stats":{"Line":1}},{"line":220,"address":[257313,257375],"length":1,"stats":{"Line":2}},{"line":223,"address":[257351,257382],"length":1,"stats":{"Line":2}},{"line":224,"address":[257425],"length":1,"stats":{"Line":1}},{"line":229,"address":[257484,257097],"length":1,"stats":{"Line":2}},{"line":230,"address":[257601],"length":1,"stats":{"Line":0}},{"line":233,"address":[256483],"length":1,"stats":{"Line":0}},{"line":234,"address":[257641,256498],"length":1,"stats":{"Line":0}},{"line":235,"address":[257741],"length":1,"stats":{"Line":0}},{"line":236,"address":[257801],"length":1,"stats":{"Line":0}},{"line":241,"address":[256536],"length":1,"stats":{"Line":0}},{"line":242,"address":[256551],"length":1,"stats":{"Line":0}},{"line":243,"address":[257857,256566],"length":1,"stats":{"Line":0}},{"line":244,"address":[257957],"length":1,"stats":{"Line":0}},{"line":245,"address":[258017],"length":1,"stats":{"Line":0}},{"line":250,"address":[256601],"length":1,"stats":{"Line":0}},{"line":251,"address":[258065,256613],"length":1,"stats":{"Line":0}},{"line":253,"address":[256636],"length":1,"stats":{"Line":0}},{"line":254,"address":[256651,258121],"length":1,"stats":{"Line":0}},{"line":258,"address":[256811],"length":1,"stats":{"Line":1}},{"line":261,"address":[259003,258208],"length":1,"stats":{"Line":1}},{"line":262,"address":[258249],"length":1,"stats":{"Line":1}},{"line":263,"address":[258262],"length":1,"stats":{"Line":1}},{"line":264,"address":[258327],"length":1,"stats":{"Line":1}},{"line":265,"address":[258339,258653],"length":1,"stats":{"Line":2}},{"line":267,"address":[258362],"length":1,"stats":{"Line":1}},{"line":268,"address":[258374,258709],"length":1,"stats":{"Line":2}},{"line":269,"address":[258717],"length":1,"stats":{"Line":1}},{"line":271,"address":[258450],"length":1,"stats":{"Line":0}},{"line":272,"address":[258790,258470],"length":1,"stats":{"Line":0}},{"line":273,"address":[258798],"length":1,"stats":{"Line":0}},{"line":276,"address":[258508],"length":1,"stats":{"Line":0}},{"line":277,"address":[258523],"length":1,"stats":{"Line":0}},{"line":278,"address":[258540,258871],"length":1,"stats":{"Line":0}},{"line":279,"address":[258879],"length":1,"stats":{"Line":0}},{"line":282,"address":[258581],"length":1,"stats":{"Line":0}},{"line":283,"address":[258952,258593],"length":1,"stats":{"Line":0}},{"line":288,"address":[258399],"length":1,"stats":{"Line":1}},{"line":291,"address":[259040,259835],"length":1,"stats":{"Line":1}},{"line":292,"address":[259081],"length":1,"stats":{"Line":1}},{"line":293,"address":[259094],"length":1,"stats":{"Line":1}},{"line":294,"address":[259159],"length":1,"stats":{"Line":1}},{"line":295,"address":[259171,259485],"length":1,"stats":{"Line":2}},{"line":297,"address":[259194],"length":1,"stats":{"Line":1}},{"line":298,"address":[259541,259206],"length":1,"stats":{"Line":2}},{"line":299,"address":[259549],"length":1,"stats":{"Line":1}},{"line":301,"address":[259282],"length":1,"stats":{"Line":0}},{"line":302,"address":[259302,259622],"length":1,"stats":{"Line":0}},{"line":303,"address":[259630],"length":1,"stats":{"Line":0}},{"line":306,"address":[259340],"length":1,"stats":{"Line":0}},{"line":307,"address":[259355],"length":1,"stats":{"Line":0}},{"line":308,"address":[259372,259703],"length":1,"stats":{"Line":0}},{"line":309,"address":[259711],"length":1,"stats":{"Line":0}},{"line":312,"address":[259413],"length":1,"stats":{"Line":0}},{"line":313,"address":[259425,259784],"length":1,"stats":{"Line":0}},{"line":318,"address":[259231],"length":1,"stats":{"Line":1}}],"covered":70,"coverable":126},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","linearizer","treewalk.rs"],"content":"use std::clone;\n\nuse crate::{\n    frontend::{ast::*, sourceloc::SourceLoc},\n    midend::{\n        ir::{self, IrLine},\n        symtab::{self, SymbolTable},\n        types::Type,\n    },\n};\n\nuse super::walkcontext::WalkContext;\n\n#[derive(Clone, Debug)]\npub struct Value {\n    pub type_: Type,\n    pub operand: Option\u003cir::Operand\u003e,\n}\n\nimpl Value {\n    pub fn unit() -\u003e Self {\n        Self {\n            type_: Type::Unit,\n            operand: None,\n        }\n    }\n\n    pub fn from_type(type_: Type) -\u003e Self {\n        Self {\n            type_,\n            operand: None,\n        }\n    }\n\n    pub fn from_type_and_name(type_: Type, operand: ir::Operand) -\u003e Self {\n        Self {\n            type_,\n            operand: Some(operand),\n        }\n    }\n\n    pub fn from_operand(operand: ir::Operand, context: \u0026WalkContext) -\u003e Self {\n        Self {\n            type_: operand.type_(context).clone(),\n            operand: Some(operand),\n        }\n    }\n}\n\nimpl Into\u003cir::Operand\u003e for Value {\n    fn into(self) -\u003e ir::Operand {\n        self.operand.unwrap()\n    }\n}\n\nimpl Into\u003cType\u003e for Value {\n    fn into(self) -\u003e Type {\n        self.type_\n    }\n}\n\npub trait TableWalk {\n    fn walk(self, symbol_table: \u0026mut SymbolTable);\n}\n\npub trait Walk {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value;\n}\n\npub trait ReturnWalk\u003cT, U\u003e {\n    fn walk(self, context: T) -\u003e U;\n}\n\nimpl TableWalk for TranslationUnitTree {\n    fn walk(self, symbol_table: \u0026mut SymbolTable) {\n        match self.contents {\n            TranslationUnit::FunctionDeclaration(function_declaration) =\u003e {\n                let declared_function =\n                    function_declaration.walk(\u0026mut WalkContext::new(\u0026symbol_table.global_scope));\n                symbol_table.insert_function_prototype(declared_function);\n            }\n            TranslationUnit::FunctionDefinition(function_definition) =\u003e {\n                let context = WalkContext::new(\u0026symbol_table.global_scope);\n                symbol_table.insert_function(function_definition.walk(context));\n            }\n            TranslationUnit::StructDefinition(struct_definition) =\u003e {\n                let mut defined_struct = symtab::StructRepr::new(struct_definition.name);\n                for field in struct_definition.fields {\n                    // TODO: global scoping\n                    let field_type = field\n                        .typename\n                        .walk(\u0026mut WalkContext::new(\u0026symbol_table.global_scope));\n                    defined_struct.add_field(field.name, field_type.type_);\n                }\n\n                symbol_table\n                    .global_scope\n                    .insert_struct_definition(defined_struct);\n            }\n            TranslationUnit::Implementation(implementation) =\u003e {\n                let mut impl_context = WalkContext::new(\u0026symbol_table.global_scope);\n                let implemented_for_type = implementation.type_name.walk(\u0026mut impl_context).type_;\n\n                let methods: Vec\u003csymtab::Function\u003e = implementation\n                    .items\n                    .into_iter()\n                    .map(|item| {\n                        let impl_context = WalkContext::new(\u0026symbol_table.global_scope);\n                        item.walk(impl_context)\n                    })\n                    .collect();\n\n                let implemented_for_mut = symbol_table\n                    .global_scope\n                    .lookup_type_mut(\u0026implemented_for_type)\n                    .unwrap();\n\n                for method in methods {\n                    implemented_for_mut.add_method(method);\n                }\n            }\n        }\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003cWalkContext\u003c'a\u003e, symtab::Function\u003e for FunctionDefinitionTree {\n    fn walk(self, mut context: WalkContext\u003c'a\u003e) -\u003e symtab::Function {\n        let mut declared_prototype = self.prototype.walk(\u0026mut context);\n        context.push_scope(declared_prototype.create_argument_scope());\n\n        self.body.walk(\u0026mut context);\n        let argument_scope = context.pop_last_scope();\n\n        symtab::Function::new(\n            declared_prototype,\n            argument_scope,\n            context.take_control_flow(),\n        )\n    }\n}\n\nimpl Walk for TypenameTree {\n    fn walk(self, _context: \u0026mut WalkContext) -\u003e Value {\n        Value::from_type(self.type_)\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, symtab::Variable\u003e for VariableDeclarationTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e symtab::Variable {\n        symtab::Variable::new(self.name.clone(), self.typename.walk(context).type_)\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, symtab::FunctionPrototype\u003e for FunctionDeclarationTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e symtab::FunctionPrototype {\n        symtab::FunctionPrototype::new(\n            self.name,\n            self.arguments\n                .into_iter()\n                .map(|x| x.walk(context))\n                .collect(),\n            match self.return_type {\n                Some(typename) =\u003e typename.walk(context).type_,\n                None =\u003e Type::Unit,\n            },\n        )\n    }\n}\n\nimpl Walk for ArithmeticExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let (temp_dest, op) = match self {\n            ArithmeticExpressionTree::Add(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_add(dest, lhs, rhs),\n                )\n            }\n            ArithmeticExpressionTree::Subtract(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest: ir::Operand = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_subtract(dest, lhs, rhs),\n                )\n            }\n            ArithmeticExpressionTree::Multiply(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_multiply(dest, lhs, rhs),\n                )\n            }\n            ArithmeticExpressionTree::Divide(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_divide(dest, lhs, rhs),\n                )\n            }\n        };\n\n        // TODO: associate location with arithmetic expression trees\n        let operation = IrLine::new_binary_op(SourceLoc::none(), op);\n        context.append_statement_to_current_block(operation);\n        Value::from_operand(temp_dest, context)\n    }\n}\n\nimpl Walk for ComparisonExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let (temp_dest, op) = match self {\n            ComparisonExpressionTree::LThan(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::GThan(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::LThanE(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::GThanE(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::Equals(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_equals(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::NotEquals(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_not_equals(dest, lhs, rhs),\n                )\n            }\n        };\n\n        // TODO: association location with comparison expression tree\n        let operation = IrLine::new_binary_op(SourceLoc::none(), op);\n        context.append_statement_to_current_block(operation);\n        Value::from_operand(temp_dest, context)\n    }\n}\n\nimpl Walk for ExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        match self.expression {\n            Expression::Identifier(ident) =\u003e {\n                Value::from_operand(ir::Operand::new_as_variable(ident), context)\n            }\n            Expression::UnsignedDecimalConstant(constant) =\u003e Value::from_operand(\n                ir::Operand::new_as_unsigned_decimal_constant(constant),\n                context,\n            ),\n            Expression::Arithmetic(arithmetic_operation) =\u003e arithmetic_operation.walk(context),\n            Expression::Comparison(comparison_operation) =\u003e comparison_operation.walk(context),\n            Expression::Assignment(assignment_expression) =\u003e assignment_expression.walk(context),\n            Expression::If(if_expression) =\u003e if_expression.walk(context),\n            Expression::While(while_expression) =\u003e while_expression.walk(context),\n            Expression::FieldExpression(field_expression) =\u003e {\n                let (receiver, field) = field_expression.walk(context);\n                let destination = context.next_temp(field.type_);\n                let field_read_line = ir::IrLine::new_field_read(\n                    self.loc,\n                    receiver.into(),\n                    field.operand.unwrap().get_name().unwrap().base_name.clone(),\n                    destination.clone(),\n                );\n                context.append_statement_to_current_block(field_read_line);\n                Value::from_operand(destination, context)\n            }\n            Expression::MethodCall(method_call) =\u003e method_call.walk(context),\n        }\n    }\n}\n\nimpl Walk for AssignmentTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let assignment_ir = match self.assignee.expression {\n            Expression::FieldExpression(field_expression_tree) =\u003e {\n                let (receiver, field) = field_expression_tree.walk(context);\n                IrLine::new_field_write(\n                    self.value.walk(context).into(),\n                    self.loc,\n                    receiver.into(),\n                    field.operand.unwrap().get_name().unwrap().base_name.clone(),\n                )\n            }\n            _ =\u003e IrLine::new_assignment(\n                self.loc,\n                self.assignee.walk(context).into(),\n                self.value.walk(context).into(),\n            ),\n        };\n\n        context.append_statement_to_current_block(assignment_ir);\n\n        Value::unit()\n    }\n}\n\nimpl Walk for IfExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        // FUTURE: optimize condition walk to use different jumps\n        let condition_loc = self.condition.loc.clone();\n        let condition_result: ir::Operand = self.condition.walk(context).into();\n        let if_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n\n        let (_, maybe_else_label) =\n            context.create_conditional_branch_from_current(condition_loc, if_condition);\n        let if_value = self.true_block.walk(context);\n\n        // create a separate, mutable value which contains the true result\n        let mut result_value = if_value.clone();\n\n        // if a false block exists AND the 'if' value exists\n        if self.false_block.is_some() \u0026\u0026 if_value.operand.is_some() {\n            // we need to copy the 'if' result to the common result_value at the end of the 'if' block\n            let result_operand = context.next_temp(if_value.type_.clone());\n            result_value = Value::from_operand(result_operand.clone(), context);\n            let assign_if_result_line =\n                ir::IrLine::new_assignment(self.loc, result_operand, if_value.clone().into());\n            context.append_statement_to_current_block(assign_if_result_line);\n        }\n        context.converge_current_block();\n\n        match (maybe_else_label, self.false_block) {\n            (Some(else_label), Some(else_block)) =\u003e {\n                context.set_current_block(else_label);\n                let else_value = else_block.walk(context);\n\n                // sanity-check that both branches return the same type\n                if if_value.type_ != else_value.type_ {\n                    panic!(\n                        \"If and Else branches return different types ({} and {}): {}\",\n                        if_value.type_, else_value.type_, self.loc\n                    );\n                }\n\n                // if the 'else' value exists (have already passed check to assert types are the same)\n                if else_value.operand.is_some() {\n                    // copy the 'else' result to the common result_value at the end of the 'else' block\n                    let assign_else_result_line = ir::IrLine::new_assignment(\n                        self.loc,\n                        result_value.clone().into(),\n                        else_value.into(),\n                    );\n                    context.append_statement_to_current_block(assign_else_result_line);\n                }\n\n                context.converge_current_block();\n            }\n            (None, None) =\u003e {}\n            (_, _) =\u003e {\n                panic!(\n                    \"Mismatched else label and else block - expect to have either both or neither\"\n                );\n            }\n        };\n\n        result_value\n    }\n}\n\nimpl Walk for WhileExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let loop_done = context.create_loop(self.loc, self.condition);\n\n        self.body.walk(context);\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n\n        Value::unit()\n    }\n}\n\n// returns (receiver, field_info)\n// receiver is the value containing the receiver of the field access\n// field_info is a value containing name and type information of the field being accessed\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, (Value, Value)\u003e for FieldExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e (Value, Value) {\n        let receiver = self.receiver.walk(context);\n\n        let struct_name = match \u0026receiver.type_ {\n            Type::UDT(type_name) =\u003e type_name,\n            _ =\u003e panic!(\n                \"Field expression receiver must be of struct type (got {})\",\n                receiver.type_\n            ),\n        };\n\n        let receiver_definition = context.lookup_struct(struct_name).expect(\u0026format!(\n            \"Error handling for failed lookups is unimplemented: {}.{}\",\n            receiver.type_, self.field\n        ));\n        // TODO: error handling\n        let accessed_field = receiver_definition.get_field(\u0026self.field).unwrap();\n        (\n            receiver,\n            Value::from_type_and_name(\n                accessed_field.type_().clone(),\n                ir::Operand::Variable(ir::OperandName::new_basic(self.field)),\n            ),\n        )\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, Vec\u003cValue\u003e\u003e for CallParamsTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Vec\u003cValue\u003e {\n        let mut param_values = Vec::new();\n\n        for param in self.params {\n            param_values.push(param.walk(context));\n        }\n\n        param_values\n    }\n}\n\nimpl Walk for MethodCallExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let receiver = self.receiver.walk(context);\n\n        let type_definition = context.lookup_type(\u0026receiver.type_).unwrap();\n        let called_method: symtab::FunctionPrototype = type_definition\n            .lookup_method(\u0026self.called_method)\n            .unwrap()\n            .prototype()\n            .clone();\n\n        let return_value_to = if called_method.return_type != Type::Unit {\n            Some(context.next_temp(called_method.return_type))\n        } else {\n            None\n        };\n        // //TODO: error handling and checking\n        // assert!(called_method.arguments.len() == params.len());\n\n        let params: Vec\u003cir::Operand\u003e = self\n            .params\n            .walk(context)\n            .into_iter()\n            .map(|value| value.into())\n            .collect();\n\n        let method_call_line = IrLine::new_method_call(\n            self.loc,\n            receiver.into(),\n            \u0026called_method.name,\n            params,\n            return_value_to.clone(),\n        );\n\n        context.append_statement_to_current_block(method_call_line);\n\n        match return_value_to {\n            Some(operand) =\u003e Value::from_operand(operand, context),\n            None =\u003e Value::unit(),\n        }\n    }\n}\n\nimpl Walk for StatementTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        match self.statement {\n            Statement::VariableDeclaration(declaration_tree) =\u003e {\n                let declared_variable = declaration_tree.walk(context);\n                context.scope().insert_variable(declared_variable);\n                Value::unit()\n            }\n            Statement::Expression(expression_tree) =\u003e expression_tree.walk(context),\n        }\n    }\n}\n\nimpl Walk for CompoundExpressionTree {\n    fn walk(mut self, context: \u0026mut WalkContext) -\u003e Value {\n        context.push_scope(symtab::Scope::new());\n        let last_statement = self.statements.pop();\n        for statement in self.statements {\n            statement.walk(context);\n        }\n\n        let last_statement_value = match last_statement {\n            Some(statement_tree) =\u003e match statement_tree.statement {\n                Statement::VariableDeclaration(variable_declaration_tree) =\u003e {\n                    variable_declaration_tree.walk(context);\n                    Value::unit()\n                }\n                Statement::Expression(expression_tree) =\u003e expression_tree.walk(context),\n            },\n            None =\u003e Value::unit(),\n        };\n\n        context.pop_scope_to_subscope_of_next();\n\n        last_statement_value\n    }\n}\n","traces":[{"line":21,"address":[372432],"length":1,"stats":{"Line":0}},{"line":28,"address":[372528],"length":1,"stats":{"Line":0}},{"line":35,"address":[372608],"length":1,"stats":{"Line":0}},{"line":38,"address":[372640],"length":1,"stats":{"Line":0}},{"line":42,"address":[372720,372935],"length":1,"stats":{"Line":1}},{"line":44,"address":[372769,372828],"length":1,"stats":{"Line":2}},{"line":45,"address":[372840],"length":1,"stats":{"Line":1}},{"line":51,"address":[373075,372960],"length":1,"stats":{"Line":1}},{"line":52,"address":[372976],"length":1,"stats":{"Line":1}},{"line":57,"address":[373104],"length":1,"stats":{"Line":0}},{"line":58,"address":[373129],"length":1,"stats":{"Line":0}},{"line":75,"address":[717056,718015,717987],"length":1,"stats":{"Line":0}},{"line":76,"address":[717081],"length":1,"stats":{"Line":0}},{"line":77,"address":[717223],"length":1,"stats":{"Line":0}},{"line":78,"address":[717292,717696],"length":1,"stats":{"Line":0}},{"line":80,"address":[717868],"length":1,"stats":{"Line":0}},{"line":82,"address":[717412],"length":1,"stats":{"Line":0}},{"line":83,"address":[717455],"length":1,"stats":{"Line":0}},{"line":84,"address":[718062],"length":1,"stats":{"Line":0}},{"line":86,"address":[717470],"length":1,"stats":{"Line":0}},{"line":87,"address":[718225,717526],"length":1,"stats":{"Line":0}},{"line":88,"address":[718233,718334,718461,719175],"length":1,"stats":{"Line":0}},{"line":90,"address":[718885,718595],"length":1,"stats":{"Line":0}},{"line":92,"address":[718651,718900,718829],"length":1,"stats":{"Line":0}},{"line":93,"address":[718996],"length":1,"stats":{"Line":0}},{"line":96,"address":[718793],"length":1,"stats":{"Line":0}},{"line":98,"address":[718681],"length":1,"stats":{"Line":0}},{"line":100,"address":[717594],"length":1,"stats":{"Line":0}},{"line":101,"address":[717678],"length":1,"stats":{"Line":0}},{"line":102,"address":[719436,719309],"length":1,"stats":{"Line":0}},{"line":104,"address":[719520],"length":1,"stats":{"Line":0}},{"line":107,"address":[677144,677169,676976],"length":1,"stats":{"Line":0}},{"line":108,"address":[677006],"length":1,"stats":{"Line":0}},{"line":109,"address":[677076],"length":1,"stats":{"Line":0}},{"line":113,"address":[719663,719711],"length":1,"stats":{"Line":0}},{"line":118,"address":[719941,719751],"length":1,"stats":{"Line":0}},{"line":119,"address":[720021,720102],"length":1,"stats":{"Line":0}},{"line":127,"address":[720176,721009,720943],"length":1,"stats":{"Line":0}},{"line":128,"address":[720403,720203],"length":1,"stats":{"Line":0}},{"line":129,"address":[720482,720424],"length":1,"stats":{"Line":0}},{"line":131,"address":[720499],"length":1,"stats":{"Line":0}},{"line":132,"address":[720597],"length":1,"stats":{"Line":0}},{"line":135,"address":[720604],"length":1,"stats":{"Line":0}},{"line":136,"address":[720685],"length":1,"stats":{"Line":0}},{"line":137,"address":[720738],"length":1,"stats":{"Line":0}},{"line":143,"address":[721040],"length":1,"stats":{"Line":0}},{"line":144,"address":[721056],"length":1,"stats":{"Line":0}},{"line":149,"address":[721104,721448,721467],"length":1,"stats":{"Line":0}},{"line":150,"address":[721139,721222],"length":1,"stats":{"Line":0}},{"line":155,"address":[722114,721504,722041],"length":1,"stats":{"Line":0}},{"line":157,"address":[721538],"length":1,"stats":{"Line":0}},{"line":158,"address":[721700,721595],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[677212,677184],"length":1,"stats":{"Line":0}},{"line":161,"address":[721729],"length":1,"stats":{"Line":0}},{"line":162,"address":[721737],"length":1,"stats":{"Line":0}},{"line":163,"address":[721779,721947],"length":1,"stats":{"Line":0}},{"line":164,"address":[721846],"length":1,"stats":{"Line":0}},{"line":171,"address":[723893,723904,722144],"length":1,"stats":{"Line":0}},{"line":172,"address":[722206,723779],"length":1,"stats":{"Line":0}},{"line":173,"address":[722395],"length":1,"stats":{"Line":0}},{"line":174,"address":[722692,722427,722896],"length":1,"stats":{"Line":0}},{"line":175,"address":[723146,722911],"length":1,"stats":{"Line":0}},{"line":176,"address":[723240,723177],"length":1,"stats":{"Line":0}},{"line":178,"address":[723302],"length":1,"stats":{"Line":0}},{"line":179,"address":[723350],"length":1,"stats":{"Line":0}},{"line":182,"address":[722470],"length":1,"stats":{"Line":0}},{"line":183,"address":[724031,724235,722502],"length":1,"stats":{"Line":0}},{"line":184,"address":[724250,724485],"length":1,"stats":{"Line":0}},{"line":185,"address":[724516,724579],"length":1,"stats":{"Line":0}},{"line":187,"address":[724641],"length":1,"stats":{"Line":0}},{"line":188,"address":[724689],"length":1,"stats":{"Line":0}},{"line":191,"address":[722545],"length":1,"stats":{"Line":0}},{"line":192,"address":[725242,725446,722577],"length":1,"stats":{"Line":0}},{"line":193,"address":[725696,725461],"length":1,"stats":{"Line":0}},{"line":194,"address":[725727,725790],"length":1,"stats":{"Line":0}},{"line":196,"address":[725852],"length":1,"stats":{"Line":0}},{"line":197,"address":[725900],"length":1,"stats":{"Line":0}},{"line":200,"address":[722620],"length":1,"stats":{"Line":0}},{"line":201,"address":[722652,726648,726450],"length":1,"stats":{"Line":0}},{"line":202,"address":[726898,726663],"length":1,"stats":{"Line":0}},{"line":203,"address":[726929,726992],"length":1,"stats":{"Line":0}},{"line":205,"address":[727054],"length":1,"stats":{"Line":0}},{"line":206,"address":[727102],"length":1,"stats":{"Line":0}},{"line":212,"address":[723873,727577],"length":1,"stats":{"Line":0}},{"line":213,"address":[727666],"length":1,"stats":{"Line":0}},{"line":214,"address":[727689],"length":1,"stats":{"Line":0}},{"line":219,"address":[727952,729942,729953],"length":1,"stats":{"Line":0}},{"line":220,"address":[728014,729822],"length":1,"stats":{"Line":0}},{"line":221,"address":[728267],"length":1,"stats":{"Line":0}},{"line":222,"address":[728299,728717,728921],"length":1,"stats":{"Line":0}},{"line":223,"address":[728936,729183],"length":1,"stats":{"Line":0}},{"line":224,"address":[729283,729214],"length":1,"stats":{"Line":0}},{"line":226,"address":[729345],"length":1,"stats":{"Line":0}},{"line":227,"address":[729393],"length":1,"stats":{"Line":0}},{"line":230,"address":[728342],"length":1,"stats":{"Line":0}},{"line":231,"address":[728374,730290,730086],"length":1,"stats":{"Line":0}},{"line":232,"address":[730305,730540],"length":1,"stats":{"Line":0}},{"line":233,"address":[730571,730634],"length":1,"stats":{"Line":0}},{"line":235,"address":[730696],"length":1,"stats":{"Line":0}},{"line":236,"address":[730744],"length":1,"stats":{"Line":0}},{"line":239,"address":[728417],"length":1,"stats":{"Line":0}},{"line":240,"address":[728449,731297,731501],"length":1,"stats":{"Line":0}},{"line":241,"address":[731516,731751],"length":1,"stats":{"Line":0}},{"line":242,"address":[731782,731845],"length":1,"stats":{"Line":0}},{"line":244,"address":[731907],"length":1,"stats":{"Line":0}},{"line":245,"address":[731955],"length":1,"stats":{"Line":0}},{"line":248,"address":[728492],"length":1,"stats":{"Line":0}},{"line":249,"address":[728524,732712,732508],"length":1,"stats":{"Line":0}},{"line":250,"address":[732727,732962],"length":1,"stats":{"Line":0}},{"line":251,"address":[733056,732993],"length":1,"stats":{"Line":0}},{"line":253,"address":[733118],"length":1,"stats":{"Line":0}},{"line":254,"address":[733166],"length":1,"stats":{"Line":0}},{"line":257,"address":[728567],"length":1,"stats":{"Line":0}},{"line":258,"address":[733719,733923,728599],"length":1,"stats":{"Line":0}},{"line":259,"address":[733938,734173],"length":1,"stats":{"Line":0}},{"line":260,"address":[734267,734204],"length":1,"stats":{"Line":0}},{"line":262,"address":[734329],"length":1,"stats":{"Line":0}},{"line":263,"address":[734377],"length":1,"stats":{"Line":0}},{"line":266,"address":[728642],"length":1,"stats":{"Line":0}},{"line":267,"address":[735134,734930,728674],"length":1,"stats":{"Line":0}},{"line":268,"address":[735149,735384],"length":1,"stats":{"Line":0}},{"line":269,"address":[735415,735478],"length":1,"stats":{"Line":0}},{"line":271,"address":[735540],"length":1,"stats":{"Line":0}},{"line":272,"address":[735588],"length":1,"stats":{"Line":0}},{"line":278,"address":[729916,736063],"length":1,"stats":{"Line":0}},{"line":279,"address":[736158],"length":1,"stats":{"Line":0}},{"line":280,"address":[736181],"length":1,"stats":{"Line":0}},{"line":285,"address":[736448,737319,737330],"length":1,"stats":{"Line":1}},{"line":286,"address":[736483],"length":1,"stats":{"Line":1}},{"line":287,"address":[736575],"length":1,"stats":{"Line":0}},{"line":288,"address":[736611],"length":1,"stats":{"Line":0}},{"line":291,"address":[736677],"length":1,"stats":{"Line":1}},{"line":294,"address":[736733],"length":1,"stats":{"Line":0}},{"line":295,"address":[736802],"length":1,"stats":{"Line":0}},{"line":296,"address":[736871],"length":1,"stats":{"Line":0}},{"line":297,"address":[737328,737151,736942],"length":1,"stats":{"Line":0}},{"line":298,"address":[736991,737348],"length":1,"stats":{"Line":0}},{"line":299,"address":[737040],"length":1,"stats":{"Line":0}},{"line":300,"address":[737052,737588,737799],"length":1,"stats":{"Line":0}},{"line":301,"address":[738092,737983],"length":1,"stats":{"Line":0}},{"line":303,"address":[738100],"length":1,"stats":{"Line":0}},{"line":304,"address":[738118,738270],"length":1,"stats":{"Line":0}},{"line":305,"address":[738412,738278,738470],"length":1,"stats":{"Line":0}},{"line":306,"address":[738541],"length":1,"stats":{"Line":0}},{"line":308,"address":[738734],"length":1,"stats":{"Line":0}},{"line":309,"address":[738804],"length":1,"stats":{"Line":0}},{"line":311,"address":[739109,737089],"length":1,"stats":{"Line":0}},{"line":317,"address":[740880,739280,741667],"length":1,"stats":{"Line":0}},{"line":318,"address":[739324],"length":1,"stats":{"Line":0}},{"line":319,"address":[739499,739584,739413],"length":1,"stats":{"Line":0}},{"line":320,"address":[739605,739559,739811],"length":1,"stats":{"Line":0}},{"line":322,"address":[739891,740118],"length":1,"stats":{"Line":0}},{"line":323,"address":[740141],"length":1,"stats":{"Line":0}},{"line":324,"address":[740159,740310],"length":1,"stats":{"Line":0}},{"line":325,"address":[740510,740452,740318],"length":1,"stats":{"Line":0}},{"line":329,"address":[739441],"length":1,"stats":{"Line":0}},{"line":330,"address":[740990,739459],"length":1,"stats":{"Line":0}},{"line":331,"address":[741168,741396],"length":1,"stats":{"Line":0}},{"line":335,"address":[740831],"length":1,"stats":{"Line":0}},{"line":337,"address":[741473],"length":1,"stats":{"Line":0}},{"line":342,"address":[744843,741808,744419],"length":1,"stats":{"Line":0}},{"line":344,"address":[742043,741851],"length":1,"stats":{"Line":0}},{"line":345,"address":[742075],"length":1,"stats":{"Line":0}},{"line":346,"address":[742292,742354],"length":1,"stats":{"Line":0}},{"line":347,"address":[742176],"length":1,"stats":{"Line":0}},{"line":348,"address":[742244],"length":1,"stats":{"Line":0}},{"line":351,"address":[742478],"length":1,"stats":{"Line":0}},{"line":353,"address":[742537],"length":1,"stats":{"Line":0}},{"line":356,"address":[742620],"length":1,"stats":{"Line":0}},{"line":359,"address":[742728,742672,743339,742757],"length":1,"stats":{"Line":0}},{"line":361,"address":[742778],"length":1,"stats":{"Line":0}},{"line":362,"address":[742853,742922],"length":1,"stats":{"Line":0}},{"line":363,"address":[744745,743079],"length":1,"stats":{"Line":0}},{"line":365,"address":[743324],"length":1,"stats":{"Line":0}},{"line":367,"address":[742739],"length":1,"stats":{"Line":0}},{"line":369,"address":[743349],"length":1,"stats":{"Line":0}},{"line":370,"address":[743657],"length":1,"stats":{"Line":0}},{"line":371,"address":[743737],"length":1,"stats":{"Line":0}},{"line":372,"address":[743790],"length":1,"stats":{"Line":0}},{"line":375,"address":[743949,743877],"length":1,"stats":{"Line":0}},{"line":376,"address":[744428,743974],"length":1,"stats":{"Line":0}},{"line":383,"address":[743963,744004],"length":1,"stats":{"Line":0}},{"line":386,"address":[744030],"length":1,"stats":{"Line":0}},{"line":387,"address":[744070],"length":1,"stats":{"Line":0}},{"line":388,"address":[744108],"length":1,"stats":{"Line":0}},{"line":390,"address":[744330],"length":1,"stats":{"Line":0}},{"line":393,"address":[744015],"length":1,"stats":{"Line":0}},{"line":397,"address":[744679,743537],"length":1,"stats":{"Line":0}},{"line":403,"address":[743575],"length":1,"stats":{"Line":0}},{"line":408,"address":[745225,744880,745196],"length":1,"stats":{"Line":0}},{"line":409,"address":[745058,744926],"length":1,"stats":{"Line":0}},{"line":411,"address":[745066],"length":1,"stats":{"Line":0}},{"line":412,"address":[745147],"length":1,"stats":{"Line":0}},{"line":413,"address":[745164],"length":1,"stats":{"Line":0}},{"line":415,"address":[745176],"length":1,"stats":{"Line":0}},{"line":423,"address":[745248,746495,746634],"length":1,"stats":{"Line":0}},{"line":424,"address":[745283,745431],"length":1,"stats":{"Line":0}},{"line":426,"address":[745439],"length":1,"stats":{"Line":0}},{"line":427,"address":[745498],"length":1,"stats":{"Line":0}},{"line":428,"address":[745523,746541],"length":1,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[745613,745693,745506,745900],"length":1,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[745985],"length":1,"stats":{"Line":0}},{"line":441,"address":[746038],"length":1,"stats":{"Line":0}},{"line":442,"address":[746359],"length":1,"stats":{"Line":0}},{"line":443,"address":[746120,746183],"length":1,"stats":{"Line":0}},{"line":444,"address":[746203,746299],"length":1,"stats":{"Line":0}},{"line":451,"address":[746672,747168],"length":1,"stats":{"Line":0}},{"line":452,"address":[746707],"length":1,"stats":{"Line":0}},{"line":454,"address":[746781,746857,746960],"length":1,"stats":{"Line":0}},{"line":455,"address":[747136,747073],"length":1,"stats":{"Line":0}},{"line":458,"address":[747102],"length":1,"stats":{"Line":0}},{"line":463,"address":[747216,748942,749130],"length":1,"stats":{"Line":0}},{"line":464,"address":[747260,747447],"length":1,"stats":{"Line":0}},{"line":466,"address":[747455,747516],"length":1,"stats":{"Line":0}},{"line":467,"address":[747608],"length":1,"stats":{"Line":0}},{"line":468,"address":[747564],"length":1,"stats":{"Line":0}},{"line":473,"address":[747761,747787,747971,747687],"length":1,"stats":{"Line":0}},{"line":474,"address":[747937,747794],"length":1,"stats":{"Line":0}},{"line":476,"address":[747767],"length":1,"stats":{"Line":0}},{"line":481,"address":[747870,748046],"length":1,"stats":{"Line":0}},{"line":485,"address":[677232,677260],"length":1,"stats":{"Line":0}},{"line":489,"address":[748115],"length":1,"stats":{"Line":0}},{"line":490,"address":[748288,748136],"length":1,"stats":{"Line":0}},{"line":491,"address":[748304],"length":1,"stats":{"Line":0}},{"line":492,"address":[748379],"length":1,"stats":{"Line":0}},{"line":493,"address":[748443],"length":1,"stats":{"Line":0}},{"line":496,"address":[748605],"length":1,"stats":{"Line":0}},{"line":498,"address":[748612],"length":1,"stats":{"Line":0}},{"line":499,"address":[748776,748653],"length":1,"stats":{"Line":0}},{"line":500,"address":[748732],"length":1,"stats":{"Line":0}},{"line":506,"address":[749577,749605,749168],"length":1,"stats":{"Line":0}},{"line":507,"address":[749203],"length":1,"stats":{"Line":0}},{"line":508,"address":[749308],"length":1,"stats":{"Line":0}},{"line":509,"address":[749365],"length":1,"stats":{"Line":0}},{"line":510,"address":[749383,749441],"length":1,"stats":{"Line":0}},{"line":511,"address":[749549],"length":1,"stats":{"Line":0}},{"line":513,"address":[749248],"length":1,"stats":{"Line":0}},{"line":519,"address":[750726,750667,749616],"length":1,"stats":{"Line":0}},{"line":520,"address":[749736,749650],"length":1,"stats":{"Line":0}},{"line":521,"address":[749756],"length":1,"stats":{"Line":0}},{"line":522,"address":[749776,750023,749896],"length":1,"stats":{"Line":0}},{"line":523,"address":[750176,750684],"length":1,"stats":{"Line":0}},{"line":526,"address":[750201],"length":1,"stats":{"Line":0}},{"line":527,"address":[750238],"length":1,"stats":{"Line":0}},{"line":528,"address":[750440],"length":1,"stats":{"Line":0}},{"line":529,"address":[750536],"length":1,"stats":{"Line":0}},{"line":530,"address":[750566],"length":1,"stats":{"Line":0}},{"line":532,"address":[750578,750346],"length":1,"stats":{"Line":0}},{"line":534,"address":[750319],"length":1,"stats":{"Line":0}},{"line":537,"address":[750332],"length":1,"stats":{"Line":0}},{"line":539,"address":[750628],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":255},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","linearizer","walkcontext.rs"],"content":"use std::collections::{HashMap, HashSet};\n\nuse crate::{\n    frontend::{ast, sourceloc::SourceLoc},\n    midend::{ir, symtab, symtab::*, types::Type},\n};\n\nuse super::treewalk::*;\n\npub struct WalkContext\u003c'a\u003e {\n    control_flow: ir::ControlFlow,\n    branch_points: HashMap\u003cusize, HashSet\u003cusize\u003e\u003e, // map from branch origin to set of target blocks\n    convergence_points: HashMap\u003cusize, usize\u003e, // map of label -\u003e label that block should jump to when done\n    global_scope: \u0026'a symtab::Scope,\n    scopes: Vec\u003csymtab::Scope\u003e,\n    // index of number of temporary variables used in this control flow (across all blocks)\n    temp_num: usize,\n    current_block: usize,\n}\n\nimpl\u003c'a\u003e WalkContext\u003c'a\u003e {\n    pub fn new(global_scope: \u0026'a Scope) -\u003e WalkContext\u003c'a\u003e {\n        let starter_flow = ir::ControlFlow::new();\n\n        let mut convergence_points = HashMap::\u003cusize, usize\u003e::new();\n        convergence_points.insert(0, 1);\n\n        WalkContext {\n            control_flow: starter_flow,\n            branch_points: HashMap::\u003cusize, HashSet\u003cusize\u003e\u003e::new(),\n            convergence_points,\n            global_scope,\n            scopes: Vec::new(),\n            temp_num: 0,\n            current_block: 0,\n        }\n    }\n\n    pub fn take_control_flow(mut self) -\u003e ir::ControlFlow {\n        for (from, to) in self.convergence_points.clone() {\n            assert_eq!(self.converge_block(from), to); // TODO: need assert?\n        }\n        self.control_flow\n    }\n\n    fn replace_branch_and_convergence_points(\u0026mut self, old_block: usize, new_block: usize) {\n        // replace all instances of old_block with new_block in both branch and convergence point tracking\n        // self.branch_points = self\n        //     .branch_points\n        //     .iter()\n        //     .map(|(source, dest_set)| {\n        //         (\n        //             if *source == old_block {\n        //                 new_block\n        //             } else {\n        //                 *source\n        //             },\n        //             dest_set\n        //                 .into_iter()\n        //                 .map(|target| {\n        //                     if *target == old_block {\n        //                         new_block\n        //                     } else {\n        //                         *target\n        //                     }\n        //                 })\n        //                 .collect(),\n        //         )\n        //     })\n        //     .collect();\n\n        self.convergence_points = self\n            .convergence_points\n            .iter()\n            .map(|(from, to)| {\n                (\n                    if *from == old_block { new_block } else { *from },\n                    if *to == old_block { new_block } else { *to },\n                )\n            })\n            .collect();\n    }\n\n    pub fn append_statement_to_current_block(\u0026mut self, statement: ir::IrLine) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(_) =\u003e {\n                panic!(\"WalkContext::append_statement_to_current_block does NOT support jumps!\")\n            }\n            _ =\u003e {}\n        }\n        self.append_to_current_block(statement);\n    }\n\n    ///appends the given statement to the current basic block\n    ///if the statement is any sort of branch, the current block will be updated to be the target of the branch\n    ///if the branch is conditional, the function returns Some(false_label) where false_label is the target of the\n    ///block control flows to when the condition is not met\n    ///for unconditional branches and other statements, returns None\n    fn append_to_current_block(\u0026mut self, statement: ir::IrLine) -\u003e Option\u003cusize\u003e {\n        match self\n            .control_flow\n            .append_statement_to_block(statement, self.current_block)\n        {\n            (Some(new_current), false_label) =\u003e {\n                self.replace_branch_and_convergence_points(self.current_block, new_current);\n                self.set_current_block(new_current);\n                false_label\n            }\n            (None, _) =\u003e None,\n        }\n    }\n\n    /// creates a branch from the current block based on a condition\n    /// returns the target of the branch\n    fn create_branch_from_current(\u0026mut self) -\u003e usize {\n        let branch_target = self.control_flow.next_block();\n\n        match self.branch_points.get(\u0026self.current_block) {\n            Some(_) =\u003e panic!(\n                \"create_branch_from_current called with existing branch (from block {})\",\n                self.current_block\n            ),\n            None =\u003e {\n                self.branch_points\n                    .insert(self.current_block, HashSet::new());\n            }\n        };\n\n        self.branch_points\n            .get_mut(\u0026self.current_block)\n            .unwrap()\n            .insert(branch_target);\n        branch_target\n    }\n\n    fn add_branch(\u0026mut self, from: usize, to: usize) {\n        self.branch_points\n            .get_mut(\u0026from)\n            .expect(\"add_branch expects existing branch\")\n            .insert(to);\n    }\n\n    fn add_convergence_point_for_branch(\u0026mut self, from: usize, to: usize) {\n        match self.convergence_points.insert(from, to) {\n            Some(existing_convergence) =\u003e {\n                if existing_convergence != to {\n                    self.add_convergence_point_for_branch(to, existing_convergence);\n                }\n            }\n            None =\u003e {}\n        }\n    }\n\n    fn create_convergence_points_for_branch(\u0026mut self, branch_from: usize) -\u003e usize {\n        let convergence_point = match self.convergence_points.get(\u0026branch_from) {\n            Some(existing_convergence) =\u003e *existing_convergence,\n            None =\u003e self.control_flow.next_block(),\n        };\n\n        for branch_target in self\n            .branch_points\n            .get(\u0026branch_from)\n            .expect(\"Creation of convergence points requires existence of branch(es)\")\n            .clone()\n        {\n            self.add_convergence_point_for_branch(branch_target, convergence_point);\n        }\n        convergence_point\n    }\n\n    ///append an unconditional jump from the end of block_label to its convergence point\n    ///return the block to which control has converged\n    fn converge_block(\u0026mut self, block_label: usize) -\u003e usize {\n        let converge_to = self\n            .convergence_points\n            .remove(\u0026block_label)\n            .expect(\u0026format!(\"Block {} has no convergence point\", block_label));\n\n        let convergence_jump = ir::IrLine::new_jump(\n            SourceLoc::none(),\n            converge_to,\n            ir::JumpCondition::Unconditional,\n        );\n        // ignore return value - appending an unconditional jump\n        self.control_flow\n            .append_statement_to_block(convergence_jump, block_label);\n        converge_to\n    }\n\n    pub fn converge_current_block(\u0026mut self) {\n        let converged_to = self.converge_block(self.current_block);\n        self.set_current_block(converged_to);\n    }\n\n    pub fn set_current_block(\u0026mut self, label: usize) {\n        self.current_block = label;\n    }\n\n    pub fn create_conditional_branch_from_current(\n        \u0026mut self,\n        loc: SourceLoc,\n        condition: ir::JumpCondition,\n    ) -\u003e (usize, Option\u003cusize\u003e) {\n        let branch_origin = self.current_block;\n        let true_label = self.create_branch_from_current();\n\n        let true_condition_jump = ir::IrLine::new_jump(loc, true_label, condition);\n        let maybe_false_label = self.append_to_current_block(true_condition_jump);\n        match maybe_false_label {\n            Some(false_label) =\u003e self.add_branch(branch_origin, false_label),\n            None =\u003e {}\n        }\n\n        self.create_convergence_points_for_branch(branch_origin);\n\n        (true_label, maybe_false_label)\n    }\n\n    ///returns the label which control jumps to after the loop\n    pub fn create_loop(\u0026mut self, loc: SourceLoc, condition: ast::ExpressionTree) -\u003e usize {\n        // first, jump to a fresh block which will be the top of the loop\n        let loop_top = self.control_flow.next_block();\n        let loop_entry = ir::IrLine::new_jump(loc, loop_top, ir::JumpCondition::Unconditional);\n        // ignore return value - appending an unconditional jump\n        self.append_to_current_block(loop_entry);\n\n        // FUTURE: optimize condition walk to use different jumps\n        // check the condition of the loop, giving us the loop body and loop done labels\n        let condition_loc = condition.loc.clone();\n        let condition_result: ir::Operand = condition.walk(self).into();\n        let loop_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n        let (_, loop_done_label) =\n            self.create_conditional_branch_from_current(condition_loc, loop_condition);\n        let loop_done_label = loop_done_label.unwrap();\n\n        self.convergence_points.insert(self.current_block, loop_top);\n        self.converge_block(loop_done_label);\n\n        loop_done_label\n    }\n\n    pub fn next_temp(\u0026mut self, type_: Type) -\u003e ir::Operand {\n        let temp_name = String::from(\".T\") + \u0026self.temp_num.to_string();\n        self.temp_num += 1;\n        self.scope()\n            .insert_variable(symtab::Variable::new(temp_name.clone(), type_));\n        ir::Operand::new_as_temporary(temp_name)\n    }\n\n    pub fn push_scope(\u0026mut self, scope: symtab::Scope) {\n        self.scopes.push(scope)\n    }\n\n    pub fn pop_scope_to_subscope_of_next(\u0026mut self) {\n        let popped = self\n            .scopes\n            .pop()\n            .expect(\"WalkContext::pop_scope_to_subscope_of_next expects valid scope\");\n        self.scope().insert_subscope(popped);\n    }\n\n    pub fn pop_last_scope(\u0026mut self) -\u003e symtab::Scope {\n        if self.scopes.len() \u003e 1 {\n            panic!(\n                \"WalkContext::pop_last_scope() called with {} parent scopes\",\n                self.scopes.len()\n            );\n        }\n\n        self.scopes\n            .pop()\n            .expect(\"WalkContext::pop_last_scope() called with no scopese\")\n    }\n\n    pub fn scope(\u0026mut self) -\u003e \u0026mut symtab::Scope {\n        self.scopes\n            .last_mut()\n            .expect(\"WalkContext::scope() expects valid scope\")\n    }\n\n    // TODO: check ordering\n    fn all_scopes(\u0026self) -\u003e std::vec::IntoIter\u003c\u0026Scope\u003e {\n        let mut scopes_ref: Vec\u003c\u0026Scope\u003e = self.scopes.iter().rev().collect();\n        scopes_ref.push(\u0026self.global_scope);\n        scopes_ref.into_iter()\n    }\n\n    pub fn lookup_variable_by_name(\n        \u0026self,\n        name: \u0026ir::OperandName,\n    ) -\u003e Result\u003c\u0026symtab::Variable, UndefinedSymbolError\u003e {\n        for scope in self.all_scopes() {\n            match scope.lookup_variable_by_name(\u0026name.base_name) {\n                Ok(variable) =\u003e return Ok(variable),\n                _ =\u003e {}\n            }\n        }\n\n        Err(UndefinedSymbolError::variable(\u0026name.base_name))\n    }\n\n    pub fn lookup_type(\u0026self, type_: \u0026Type) -\u003e Result\u003c\u0026TypeDefinition, UndefinedSymbolError\u003e {\n        for scope in self.all_scopes() {\n            match scope.lookup_type(type_) {\n                Ok(variable) =\u003e return Ok(variable),\n                _ =\u003e {}\n            }\n        }\n\n        Err(UndefinedSymbolError::type_(\u0026type_))\n    }\n\n    pub fn lookup_struct(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026StructRepr, UndefinedSymbolError\u003e {\n        for scope in self.all_scopes() {\n            match scope.lookup_struct(name) {\n                Ok(variable) =\u003e return Ok(variable),\n                _ =\u003e {}\n            }\n        }\n\n        Err(UndefinedSymbolError::struct_(\u0026name))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        frontend::{ast, sourceloc::SourceLoc},\n        midend::{ir, linearizer::walkcontext::WalkContext, symtab},\n    };\n\n    fn assert_no_remaining_convergences(context: WalkContext) {\n        // allow convergence to block 1 as that should be the final block in the control flow\n        for (from, to) in context.convergence_points {\n            assert_eq!(to, 1);\n        }\n    }\n\n    fn assert_branch(context: \u0026WalkContext, from: usize, to: usize) {\n        let branches = context.branch_points.get(\u0026from);\n        assert!(branches.is_some());\n        let branches = branches.unwrap();\n        assert!(branches.contains(\u0026to));\n    }\n\n    fn assert_convergence(context: \u0026WalkContext, from: usize, to: usize) {\n        let convergence = context.convergence_points.get(\u0026from);\n        assert_eq!(convergence, Some(\u0026to));\n    }\n\n    #[test]\n    fn walk_context_initial_state() {\n        let global_scope = symtab::Scope::new();\n        let context = WalkContext::new(\u0026global_scope);\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn append_statement() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n        let assignment = ir::IrLine::new_assignment(\n            SourceLoc::none(),\n            ir::Operand::new_as_variable(\"dest\".into()),\n            ir::Operand::new_as_variable(\"source\".into()),\n        );\n        context.append_statement_to_current_block(assignment);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_branch() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n    }\n\n    #[test]\n    fn add_branch() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n        assert_eq!(branch_to, 2);\n        assert_eq!(second_branch_to, 3);\n    }\n\n    #[test]\n    fn simple_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n    }\n\n    #[test]\n    fn complex_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        // create the convergence point and assert that both branch targets converge to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn simple_multiple_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 2 targets, nested in a branch with one target\n    #[test]\n    fn complex_multiple_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // and add to that second branch a second target\n        let second_nested_branch_to = context.control_flow.next_block();\n        context.add_branch(nested_branch_from, second_nested_branch_to);\n        assert_branch(\u0026context, nested_branch_from, second_nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 1 target, nested within a branch with 2 targets\n    #[test]\n    fn complex_multiple_branch_convergence_points_2() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_to, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(branch_to);\n        assert_convergence(\u0026context, branch_to, nested_converge_to);\n\n        // and re-assert our original convergence\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn converge_block() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        assert_eq!(context.converge_block(branch_to), converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn converge_current_block() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        context.set_current_block(branch_to);\n        context.converge_current_block();\n\n        assert_eq!(context.current_block, converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_loop() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n        context.push_scope(symtab::Scope::new());\n\n        let before_loop = context.current_block;\n\n        let loop_done = context.create_loop(\n            SourceLoc::none(),\n            ast::ExpressionTree {\n                loc: SourceLoc::none(),\n                expression: { ast::Expression::UnsignedDecimalConstant(123) },\n            },\n        );\n\n        assert_ne!(before_loop, context.current_block);\n        assert_ne!(loop_done, context.current_block);\n\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n\n        assert_no_remaining_convergences(context);\n    }\n}\n","traces":[{"line":22,"address":[891585,891543,890960],"length":1,"stats":{"Line":4}},{"line":23,"address":[890989],"length":1,"stats":{"Line":4}},{"line":25,"address":[891028],"length":1,"stats":{"Line":4}},{"line":26,"address":[891076],"length":1,"stats":{"Line":4}},{"line":30,"address":[891211],"length":1,"stats":{"Line":4}},{"line":33,"address":[891310],"length":1,"stats":{"Line":4}},{"line":39,"address":[891616,892034],"length":1,"stats":{"Line":0}},{"line":40,"address":[891791,891701,891638],"length":1,"stats":{"Line":0}},{"line":41,"address":[891842,892060],"length":1,"stats":{"Line":0}},{"line":43,"address":[891881],"length":1,"stats":{"Line":0}},{"line":46,"address":[892367,892208],"length":1,"stats":{"Line":1}},{"line":72,"address":[892243,892406],"length":1,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[378750,378720],"length":1,"stats":{"Line":2}},{"line":77,"address":[378760],"length":1,"stats":{"Line":1}},{"line":78,"address":[378813],"length":1,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[892448,892678,892653],"length":1,"stats":{"Line":1}},{"line":85,"address":[892473],"length":1,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[892515,892620],"length":1,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[892539],"length":1,"stats":{"Line":1}},{"line":99,"address":[892688],"length":1,"stats":{"Line":1}},{"line":100,"address":[892719,892705],"length":1,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[892712],"length":1,"stats":{"Line":1}},{"line":104,"address":[892745],"length":1,"stats":{"Line":1}},{"line":105,"address":[892790],"length":1,"stats":{"Line":1}},{"line":106,"address":[892812],"length":1,"stats":{"Line":1}},{"line":107,"address":[892827],"length":1,"stats":{"Line":1}},{"line":109,"address":[892839],"length":1,"stats":{"Line":1}},{"line":115,"address":[892864],"length":1,"stats":{"Line":3}},{"line":116,"address":[892884],"length":1,"stats":{"Line":3}},{"line":118,"address":[892911],"length":1,"stats":{"Line":4}},{"line":119,"address":[892961],"length":1,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[893049,893096],"length":1,"stats":{"Line":8}},{"line":125,"address":[893117,893061],"length":1,"stats":{"Line":2}},{"line":129,"address":[893135,893149],"length":1,"stats":{"Line":10}},{"line":130,"address":[893142],"length":1,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[893200],"length":1,"stats":{"Line":3}},{"line":137,"address":[893224],"length":1,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[893296],"length":1,"stats":{"Line":1}},{"line":144,"address":[893325],"length":1,"stats":{"Line":5}},{"line":145,"address":[893363],"length":1,"stats":{"Line":1}},{"line":146,"address":[893377],"length":1,"stats":{"Line":1}},{"line":147,"address":[893401],"length":1,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[893408,893789],"length":1,"stats":{"Line":1}},{"line":155,"address":[893433],"length":1,"stats":{"Line":2}},{"line":156,"address":[893483],"length":1,"stats":{"Line":1}},{"line":157,"address":[893511],"length":1,"stats":{"Line":1}},{"line":160,"address":[893530,893695],"length":1,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[893746,893784],"length":1,"stats":{"Line":5}},{"line":168,"address":[893771],"length":1,"stats":{"Line":5}},{"line":173,"address":[893824,894213],"length":1,"stats":{"Line":1}},{"line":174,"address":[893849,894076],"length":1,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[894108,893883],"length":1,"stats":{"Line":3}},{"line":180,"address":[894119],"length":1,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[894132],"length":1,"stats":{"Line":2}},{"line":185,"address":[894170],"length":1,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[894240],"length":1,"stats":{"Line":1}},{"line":191,"address":[894253],"length":1,"stats":{"Line":1}},{"line":192,"address":[894277],"length":1,"stats":{"Line":1}},{"line":195,"address":[894288],"length":1,"stats":{"Line":4}},{"line":196,"address":[894298],"length":1,"stats":{"Line":4}},{"line":199,"address":[894784,894320,894809],"length":1,"stats":{"Line":1}},{"line":204,"address":[894389],"length":1,"stats":{"Line":1}},{"line":205,"address":[894498,894425],"length":1,"stats":{"Line":2}},{"line":207,"address":[894506],"length":1,"stats":{"Line":1}},{"line":208,"address":[894627],"length":1,"stats":{"Line":1}},{"line":209,"address":[894668],"length":1,"stats":{"Line":1}},{"line":210,"address":[894732,894692],"length":1,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[894725],"length":1,"stats":{"Line":1}},{"line":216,"address":[894749],"length":1,"stats":{"Line":1}},{"line":220,"address":[895663,894832],"length":1,"stats":{"Line":1}},{"line":222,"address":[894979,894883],"length":1,"stats":{"Line":2}},{"line":223,"address":[894987],"length":1,"stats":{"Line":1}},{"line":225,"address":[895029],"length":1,"stats":{"Line":1}},{"line":229,"address":[895041],"length":1,"stats":{"Line":1}},{"line":230,"address":[895114],"length":1,"stats":{"Line":1}},{"line":231,"address":[895331,895393],"length":1,"stats":{"Line":2}},{"line":232,"address":[895215],"length":1,"stats":{"Line":1}},{"line":233,"address":[895283],"length":1,"stats":{"Line":1}},{"line":235,"address":[895524],"length":1,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[895556],"length":1,"stats":{"Line":1}},{"line":239,"address":[895596],"length":1,"stats":{"Line":1}},{"line":240,"address":[895626],"length":1,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[896409,896365,895712],"length":1,"stats":{"Line":0}},{"line":246,"address":[895747,895849,896374],"length":1,"stats":{"Line":0}},{"line":247,"address":[896090,896140],"length":1,"stats":{"Line":0}},{"line":248,"address":[896264,896128],"length":1,"stats":{"Line":0}},{"line":249,"address":[896160],"length":1,"stats":{"Line":0}},{"line":250,"address":[896276],"length":1,"stats":{"Line":0}},{"line":253,"address":[896448],"length":1,"stats":{"Line":1}},{"line":254,"address":[896453],"length":1,"stats":{"Line":1}},{"line":257,"address":[896695,896480,896720],"length":1,"stats":{"Line":0}},{"line":258,"address":[896503],"length":1,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[896576,896622],"length":1,"stats":{"Line":0}},{"line":265,"address":[896736],"length":1,"stats":{"Line":0}},{"line":266,"address":[896774],"length":1,"stats":{"Line":0}},{"line":267,"address":[896868],"length":1,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[896790],"length":1,"stats":{"Line":0}},{"line":278,"address":[896960],"length":1,"stats":{"Line":0}},{"line":279,"address":[896965],"length":1,"stats":{"Line":0}},{"line":285,"address":[897224,897024,897246],"length":1,"stats":{"Line":0}},{"line":286,"address":[897056],"length":1,"stats":{"Line":0}},{"line":287,"address":[897121],"length":1,"stats":{"Line":0}},{"line":288,"address":[897172],"length":1,"stats":{"Line":0}},{"line":291,"address":[897264,897765],"length":1,"stats":{"Line":0}},{"line":295,"address":[897444,897302],"length":1,"stats":{"Line":0}},{"line":296,"address":[897632,897509],"length":1,"stats":{"Line":0}},{"line":297,"address":[897699],"length":1,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[897548],"length":1,"stats":{"Line":0}},{"line":305,"address":[898211,897792],"length":1,"stats":{"Line":0}},{"line":306,"address":[897822,897949],"length":1,"stats":{"Line":0}},{"line":307,"address":[898088,898004],"length":1,"stats":{"Line":0}},{"line":308,"address":[898148],"length":1,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[898034],"length":1,"stats":{"Line":0}},{"line":316,"address":[898240,898672],"length":1,"stats":{"Line":0}},{"line":317,"address":[898400,898275],"length":1,"stats":{"Line":0}},{"line":318,"address":[898549,898455],"length":1,"stats":{"Line":0}},{"line":319,"address":[898609],"length":1,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[898490],"length":1,"stats":{"Line":0}}],"covered":78,"coverable":149},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","linearizer.rs"],"content":"use treewalk::TableWalk;\n\nuse crate::frontend::ast::TranslationUnitTree;\n\nuse super::symtab::SymbolTable;\n\nmod treewalk;\npub mod walkcontext;\n\npub fn linearize(symtab: \u0026mut SymbolTable, program: Vec\u003cTranslationUnitTree\u003e) {\n    for translation_unit in program {\n        translation_unit.walk(symtab);\n    }\n}\n","traces":[{"line":10,"address":[694480,694708],"length":1,"stats":{"Line":0}},{"line":11,"address":[694604,694500],"length":1,"stats":{"Line":0}},{"line":12,"address":[694678,694703],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","optimization","unused_blocks.rs"],"content":"// use std::collections::{BTreeSet, HashMap, HashSet};\n\n// use crate::midend::{\n//     ir::{self, ControlFlow},\n//     symtab::Function,\n// };\n\n// pub fn remove_unused_blocks(function: \u0026mut Function) {\n//     let mut block_references = HashMap::\u003cusize, usize\u003e::new();\n\n//     for label_num in 0..function.control_flow.blocks.len() {\n//         block_references.entry(label_num).or_insert(0);\n//         for target in \u0026function.control_flow.successors[label_num] {\n//             *block_references.entry(*target).or_insert(0) += 1;\n//         }\n//     }\n\n//     let mut block_labels_to_remove = BTreeSet::\u003cusize\u003e::new();\n\n//     for (block, rc) in block_references {\n//         println!(\"{}:{}\", block, rc);\n//         if rc == 0 {\n//             block_labels_to_remove.insert(block);\n//         }\n//     }\n\n//     let mut block_labels_to_rename = HashMap::\u003cusize, usize\u003e::new();\n//     for label_num in \u0026block_labels_to_remove {\n//         for affected in *label_num..function.control_flow.blocks.len() {\n//             if !block_labels_to_remove.contains(\u0026affected) {\n//                 *block_labels_to_rename.entry(affected).or_insert(affected) -= 1;\n//             }\n//         }\n//     }\n\n//     for (orig, renamed) in \u0026block_labels_to_rename {\n//         println!(\"{}-\u003e{}\", orig, renamed);\n//     }\n\n//     for block in \u0026mut function.control_flow.blocks {\n//         for statement in block.statements_mut() {\n//             match \u0026mut statement.operation {\n//                 ir::Operations::Jump(jump) =\u003e {\n//                     let original_destination = jump.destination_block;\n//                     jump.destination_block = match block_labels_to_rename.get(\u0026original_destination)\n//                     {\n//                         Some(new_label) =\u003e *new_label,\n//                         None =\u003e original_destination,\n//                     };\n//                 }\n//                 _ =\u003e {}\n//             }\n//         }\n//     }\n\n//     for (old_label, new_label) in \u0026block_labels_to_rename {\n//         function.control_flow.blocks[*old_label].label = *new_label;\n//         println!(\"Rename {}-\u003e{}\", old_label, new_label);\n//     }\n\n//     for remove in block_labels_to_remove.iter().rev() {\n//         println!(\"Remove unused block {}\", remove);\n//         function.control_flow.blocks.remove(*remove);\n//         function.control_flow.successors.remove(*remove);\n//         function.control_flow.predecessors.remove(*remove);\n//     }\n\n//     for predecessor_set in \u0026mut function.control_flow.predecessors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for predecessor in predecessor_set.iter() {\n//             let original_predecessor = predecessor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *predecessor,\n//             });\n//         }\n\n//         *predecessor_set = new_set;\n//     }\n\n//     for successor_set in \u0026mut function.control_flow.successors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for successor in successor_set.iter() {\n//             let original_predecessor = successor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *successor,\n//             });\n//         }\n\n//         *successor_set = new_set;\n//     }\n\n//     function.control_flow.to_graphviz();\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","optimization.rs"],"content":"use std::collections::HashMap;\n\nuse super::symtab::{Function, FunctionOrPrototype};\n\nmod unused_blocks;\n\nfn do_optimizations_on_function(_function: \u0026mut Function) {\n    // unused_blocks::remove_unused_blocks(function);\n}\n\npub fn optimize_functions(functions: \u0026mut HashMap\u003cString, FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            FunctionOrPrototype::Prototype(_) =\u003e {}\n            FunctionOrPrototype::Function(function) =\u003e do_optimizations_on_function(function),\n        };\n    }\n}\n","traces":[{"line":7,"address":[549680],"length":1,"stats":{"Line":0}},{"line":11,"address":[549696],"length":1,"stats":{"Line":0}},{"line":12,"address":[549711],"length":1,"stats":{"Line":0}},{"line":13,"address":[549804],"length":1,"stats":{"Line":0}},{"line":15,"address":[549851],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa.rs"],"content":"struct SsaBlock {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen","add_block_args.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse crate::midend::idfa::block_args::IdfaImplementor;\nuse crate::midend::{\n    idfa::{self},\n    ir, symtab,\n};\n\npub fn add_block_arguments(function: \u0026mut symtab::Function) {\n    let mut block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n\n    loop {\n        let mut args_by_block = HashMap::\u003cusize, BTreeSet\u003cir::OperandName\u003e\u003e::new();\n        for (label, block) in \u0026mut function.control_flow.blocks {\n            block.arguments = block_args.for_label(*label).out_facts.clone();\n            args_by_block.insert(*label, block.arguments.clone());\n        }\n\n        for block in function.control_flow.blocks.values_mut() {\n            for statement in \u0026mut block.statements {\n                match \u0026mut statement.operation {\n                    ir::Operations::Jump(jump) =\u003e {\n                        for target_arg in args_by_block.get(\u0026jump.destination_block).unwrap() {\n                            jump.block_args\n                                .insert(target_arg.clone(), target_arg.clone());\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        let new_block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n        if new_block_args != block_args {\n            block_args = new_block_args;\n        } else {\n            break;\n        }\n    }\n}\n","traces":[{"line":9,"address":[290788,291543,289808],"length":1,"stats":{"Line":0}},{"line":10,"address":[289834],"length":1,"stats":{"Line":0}},{"line":13,"address":[289899],"length":1,"stats":{"Line":0}},{"line":14,"address":[290013,289954],"length":1,"stats":{"Line":0}},{"line":15,"address":[290169,291324],"length":1,"stats":{"Line":0}},{"line":16,"address":[291468],"length":1,"stats":{"Line":0}},{"line":19,"address":[290203],"length":1,"stats":{"Line":0}},{"line":20,"address":[290354,290807],"length":1,"stats":{"Line":0}},{"line":21,"address":[290912],"length":1,"stats":{"Line":0}},{"line":22,"address":[290943],"length":1,"stats":{"Line":0}},{"line":23,"address":[290951],"length":1,"stats":{"Line":0}},{"line":24,"address":[291142,291236],"length":1,"stats":{"Line":0}},{"line":25,"address":[291159,291275],"length":1,"stats":{"Line":0}},{"line":33,"address":[290382],"length":1,"stats":{"Line":0}},{"line":34,"address":[290507,290451],"length":1,"stats":{"Line":0}},{"line":35,"address":[290528,290643],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen","convert_reads.rs"],"content":"use std::collections::BTreeMap;\n\nuse crate::midend::{ir, symtab};\n\npub fn convert_reads_to_ssa(function: \u0026mut symtab::Function) {\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        let mut highest_ssa_numbers = BTreeMap::\u003cir::OperandName, ir::OperandName\u003e::new();\n\n        for arg in \u0026block.arguments {\n            highest_ssa_numbers.insert(arg.clone().into_non_ssa(), arg.clone());\n        }\n\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = match highest_ssa_numbers.get(read) {\n                    Some(operand) =\u003e operand.ssa_number,\n                    None =\u003e {\n                        println!(\"{} has no ssa number (yet)\", read);\n                        None\n                    }\n                };\n            }\n\n            for write in statement.write_operand_names() {\n                match highest_ssa_numbers.get(\u0026write.clone().into_non_ssa()) {\n                    Some(existing_number) =\u003e {\n                        assert!(existing_number.ssa_number.unwrap() \u003c write.ssa_number.unwrap());\n                    }\n                    None =\u003e {}\n                }\n                highest_ssa_numbers.insert(write.clone().into_non_ssa(), write.clone());\n            }\n        }\n    }\n}\n","traces":[{"line":5,"address":[543003,540944,542590],"length":1,"stats":{"Line":0}},{"line":6,"address":[540962,541142],"length":1,"stats":{"Line":0}},{"line":7,"address":[541218],"length":1,"stats":{"Line":0}},{"line":9,"address":[541251,541310],"length":1,"stats":{"Line":0}},{"line":10,"address":[541429,542840],"length":1,"stats":{"Line":0}},{"line":13,"address":[541444],"length":1,"stats":{"Line":0}},{"line":14,"address":[542819,541580,541621,541757],"length":1,"stats":{"Line":0}},{"line":15,"address":[541812,542604,542788],"length":1,"stats":{"Line":0}},{"line":16,"address":[542643],"length":1,"stats":{"Line":0}},{"line":18,"address":[542700],"length":1,"stats":{"Line":0}},{"line":19,"address":[542776],"length":1,"stats":{"Line":0}},{"line":24,"address":[542030,541871],"length":1,"stats":{"Line":0}},{"line":25,"address":[542098,542139,542219],"length":1,"stats":{"Line":0}},{"line":26,"address":[542258],"length":1,"stats":{"Line":0}},{"line":27,"address":[542274,542320],"length":1,"stats":{"Line":0}},{"line":31,"address":[542404],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen","convert_writes.rs"],"content":"use std::{collections::HashMap, fmt::Display};\n\nuse crate::midend::{ir, symtab};\n\n#[derive(Debug)]\nstruct SsaWriteConversionMetadata {\n    variables: HashMap\u003cString, usize\u003e,\n}\n\nimpl Display for SsaWriteConversionMetadata {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut result: std::fmt::Result = write!(f, \"Variables: {{\");\n\n        for (variable, ssa_number) in \u0026self.variables {\n            result = result.and(writeln!(f, \"{}:{}\", variable, ssa_number));\n        }\n\n        result\n    }\n}\n\nimpl SsaWriteConversionMetadata {\n    pub fn new() -\u003e Self {\n        Self {\n            variables: HashMap::new(),\n        }\n    }\n\n    pub fn next_number_for_variable(\u0026mut self, operand_name: \u0026ir::OperandName) -\u003e usize {\n        let entry = self\n            .variables\n            .entry(operand_name.base_name.clone())\n            .or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n\n    pub fn next_number_for_string(\u0026mut self, string: String) -\u003e usize {\n        let entry = self.variables.entry(string).or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n}\n\nfn convert_block_writes_to_ssa(\n    block: \u0026mut ir::BasicBlock,\n    metadata: \u0026mut SsaWriteConversionMetadata,\n) {\n    let old_args = block.arguments.clone();\n    block.arguments.clear();\n\n    for argument in old_args.iter() {\n        let mut new_argument = argument.clone();\n        new_argument.ssa_number = Some(metadata.next_number_for_variable(argument));\n        block.arguments.insert(new_argument);\n    }\n\n    for statement in \u0026mut block.statements {\n        for write in statement.write_operand_names_mut() {\n            write.ssa_number = Some(metadata.next_number_for_variable(write));\n        }\n    }\n}\n\npub fn convert_writes_to_ssa(function: \u0026mut symtab::Function) {\n    let mut write_conversion_metadata = SsaWriteConversionMetadata::new();\n    for argument in \u0026function.prototype.arguments {\n        write_conversion_metadata.next_number_for_string(argument.name());\n    }\n\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        convert_block_writes_to_ssa(block, \u0026mut write_conversion_metadata)\n    }\n}\n","traces":[{"line":11,"address":[409552],"length":1,"stats":{"Line":0}},{"line":12,"address":[409585],"length":1,"stats":{"Line":0}},{"line":14,"address":[409945,409628],"length":1,"stats":{"Line":0}},{"line":15,"address":[409757],"length":1,"stats":{"Line":0}},{"line":18,"address":[409950],"length":1,"stats":{"Line":0}},{"line":23,"address":[409968],"length":1,"stats":{"Line":0}},{"line":25,"address":[409982],"length":1,"stats":{"Line":0}},{"line":29,"address":[410032],"length":1,"stats":{"Line":0}},{"line":30,"address":[410074],"length":1,"stats":{"Line":0}},{"line":32,"address":[410054],"length":1,"stats":{"Line":0}},{"line":34,"address":[410113],"length":1,"stats":{"Line":0}},{"line":35,"address":[410129,410172],"length":1,"stats":{"Line":0}},{"line":40,"address":[410192],"length":1,"stats":{"Line":0}},{"line":41,"address":[410207],"length":1,"stats":{"Line":0}},{"line":42,"address":[410240],"length":1,"stats":{"Line":0}},{"line":43,"address":[410253,410292],"length":1,"stats":{"Line":0}},{"line":49,"address":[410320,411313,411067],"length":1,"stats":{"Line":0}},{"line":53,"address":[410359],"length":1,"stats":{"Line":0}},{"line":54,"address":[410391],"length":1,"stats":{"Line":0}},{"line":56,"address":[411290,410448],"length":1,"stats":{"Line":0}},{"line":57,"address":[410591,411086],"length":1,"stats":{"Line":0}},{"line":58,"address":[411155,411094],"length":1,"stats":{"Line":0}},{"line":59,"address":[411207],"length":1,"stats":{"Line":0}},{"line":62,"address":[410606],"length":1,"stats":{"Line":0}},{"line":63,"address":[410778,411062,410914,410737],"length":1,"stats":{"Line":0}},{"line":64,"address":[410979,411019],"length":1,"stats":{"Line":0}},{"line":69,"address":[411813,411847,411328],"length":1,"stats":{"Line":0}},{"line":70,"address":[411353],"length":1,"stats":{"Line":0}},{"line":71,"address":[411431,411363],"length":1,"stats":{"Line":0}},{"line":72,"address":[411517,411835],"length":1,"stats":{"Line":0}},{"line":75,"address":[411532,411700],"length":1,"stats":{"Line":0}},{"line":76,"address":[411768,411808],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse add_block_args::add_block_arguments;\nuse convert_reads::convert_reads_to_ssa;\nuse convert_writes::convert_writes_to_ssa;\n\nmod add_block_args;\nmod convert_reads;\nmod convert_writes;\n\nuse super::{ir, symtab};\n\nfn convert_function_to_ssa(function: \u0026mut symtab::Function) {\n    add_block_arguments(function);\n    convert_writes_to_ssa(function);\n    convert_reads_to_ssa(function);\n\n    function.control_flow.to_graphviz();\n}\n\npub fn convert_functions_to_ssa(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function_or_prototype) in functions {\n        match function_or_prototype {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e convert_function_to_ssa(function),\n        };\n    }\n}\n\nfn remove_ssa_from_function(function: \u0026mut symtab::Function) {\n    for block in \u0026mut function.control_flow.blocks.values_mut() {\n        let old_arguments = block.arguments.clone();\n        block.arguments.clear();\n        block.arguments = BTreeSet::\u003cir::OperandName\u003e::new();\n        for arg in old_arguments {\n            block.arguments.insert(arg.into_non_ssa());\n        }\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = None;\n            }\n\n            for write in statement.write_operand_names_mut() {\n                write.ssa_number = None;\n            }\n        }\n    }\n    function.control_flow.to_graphviz();\n}\n\npub fn remove_ssa_from_functions(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e remove_ssa_from_function(function),\n        };\n    }\n}\n","traces":[{"line":13,"address":[349952],"length":1,"stats":{"Line":0}},{"line":14,"address":[349966],"length":1,"stats":{"Line":0}},{"line":15,"address":[349976],"length":1,"stats":{"Line":0}},{"line":16,"address":[349986],"length":1,"stats":{"Line":0}},{"line":18,"address":[349996],"length":1,"stats":{"Line":0}},{"line":21,"address":[350016],"length":1,"stats":{"Line":0}},{"line":22,"address":[350031],"length":1,"stats":{"Line":0}},{"line":23,"address":[350124],"length":1,"stats":{"Line":0}},{"line":25,"address":[350171],"length":1,"stats":{"Line":0}},{"line":30,"address":[351547,351581,350192],"length":1,"stats":{"Line":0}},{"line":31,"address":[350215,350997],"length":1,"stats":{"Line":0}},{"line":32,"address":[350325],"length":1,"stats":{"Line":0}},{"line":33,"address":[350360],"length":1,"stats":{"Line":0}},{"line":34,"address":[350441],"length":1,"stats":{"Line":0}},{"line":35,"address":[350558,350710],"length":1,"stats":{"Line":0}},{"line":36,"address":[351569,350791],"length":1,"stats":{"Line":0}},{"line":38,"address":[350846],"length":1,"stats":{"Line":0}},{"line":39,"address":[350982,351154,351244,351018],"length":1,"stats":{"Line":0}},{"line":40,"address":[351209],"length":1,"stats":{"Line":0}},{"line":43,"address":[351277,351434,351524],"length":1,"stats":{"Line":0}},{"line":44,"address":[351489],"length":1,"stats":{"Line":0}},{"line":48,"address":[350372],"length":1,"stats":{"Line":0}},{"line":51,"address":[351616],"length":1,"stats":{"Line":0}},{"line":52,"address":[351631],"length":1,"stats":{"Line":0}},{"line":53,"address":[351724],"length":1,"stats":{"Line":0}},{"line":55,"address":[351771],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","errors.rs"],"content":"use crate::midend::types::Type;\n\npub enum UndefinedSymbolError {\n    Function(String),\n    Method(Type, String),\n    Variable(String),\n    Type(Type),\n    Struct(String),\n}\n\nimpl std::fmt::Display for UndefinedSymbolError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            UndefinedSymbolError::Function(function) =\u003e {\n                write!(f, \"Undefined function {}\", function)\n            }\n            UndefinedSymbolError::Method(receiver, method_name) =\u003e {\n                write!(f, \"{} has no method {}\", receiver, method_name)\n            }\n            UndefinedSymbolError::Variable(variable) =\u003e {\n                write!(f, \"Undeclared variable {}\", variable)\n            }\n            UndefinedSymbolError::Type(type_) =\u003e write!(f, \"Undeclared type {}\", type_),\n            UndefinedSymbolError::Struct(struct_) =\u003e write!(f, \"Undeclared struct {}\", struct_),\n        }\n    }\n}\n\nimpl std::fmt::Debug for UndefinedSymbolError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self)\n    }\n}\n\nimpl UndefinedSymbolError {\n    pub fn function(name: \u0026str) -\u003e Self {\n        Self::Function(name.into())\n    }\n\n    pub fn method(receiver: \u0026Type, method_name: \u0026str) -\u003e Self {\n        Self::Method(receiver.clone(), method_name.into())\n    }\n\n    pub fn variable(name: \u0026str) -\u003e Self {\n        Self::Variable(name.into())\n    }\n\n    pub fn type_(type_: \u0026Type) -\u003e Self {\n        Self::Type(type_.clone())\n    }\n\n    pub fn struct_(name: \u0026str) -\u003e Self {\n        Self::Struct(name.into())\n    }\n}\n","traces":[{"line":12,"address":[320912],"length":1,"stats":{"Line":0}},{"line":13,"address":[320945],"length":1,"stats":{"Line":0}},{"line":14,"address":[321010],"length":1,"stats":{"Line":0}},{"line":15,"address":[321019],"length":1,"stats":{"Line":0}},{"line":17,"address":[321108],"length":1,"stats":{"Line":0}},{"line":18,"address":[321131],"length":1,"stats":{"Line":0}},{"line":20,"address":[321300],"length":1,"stats":{"Line":0}},{"line":21,"address":[321312],"length":1,"stats":{"Line":0}},{"line":23,"address":[321428],"length":1,"stats":{"Line":0}},{"line":24,"address":[321553],"length":1,"stats":{"Line":0}},{"line":30,"address":[321696],"length":1,"stats":{"Line":0}},{"line":31,"address":[321714],"length":1,"stats":{"Line":0}},{"line":36,"address":[321808],"length":1,"stats":{"Line":0}},{"line":37,"address":[321831],"length":1,"stats":{"Line":0}},{"line":40,"address":[321904,322076],"length":1,"stats":{"Line":0}},{"line":41,"address":[321947],"length":1,"stats":{"Line":0}},{"line":44,"address":[322096],"length":1,"stats":{"Line":0}},{"line":45,"address":[322119],"length":1,"stats":{"Line":0}},{"line":48,"address":[322192],"length":1,"stats":{"Line":0}},{"line":49,"address":[322211],"length":1,"stats":{"Line":0}},{"line":52,"address":[322288],"length":1,"stats":{"Line":0}},{"line":53,"address":[322311],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","function.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::{ir, types::Type};\n\nuse super::{scope::Scope, variable::Variable};\n\n#[derive(Debug, Serialize)]\npub enum FunctionOrPrototype {\n    Function(Function),\n    Prototype(FunctionPrototype),\n}\n\nimpl FunctionOrPrototype {\n    pub fn prototype(\u0026self) -\u003e \u0026FunctionPrototype {\n        match self {\n            FunctionOrPrototype::Function(function) =\u003e \u0026function.prototype,\n            FunctionOrPrototype::Prototype(function_prototype) =\u003e function_prototype,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Function {\n    pub prototype: FunctionPrototype,\n    pub scope: Scope,\n    pub control_flow: ir::ControlFlow,\n}\n\nimpl Function {\n    pub fn new(prototype: FunctionPrototype, scope: Scope, control_flow: ir::ControlFlow) -\u003e Self {\n        Function {\n            prototype,\n            scope,\n            control_flow,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        self.prototype.name.clone()\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct FunctionPrototype {\n    pub name: String,\n    pub arguments: Vec\u003cVariable\u003e,\n    pub return_type: Type,\n}\n\nimpl Display for FunctionPrototype {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arguments_string = String::new();\n        for argument in \u0026self.arguments {\n            if arguments_string.len() \u003e 0 {\n                arguments_string = format!(\"{}, {}\", arguments_string, argument);\n            } else {\n                arguments_string = format!(\"{}\", argument);\n            }\n        }\n        match \u0026self.return_type {\n            Type::Unit =\u003e write!(f, \"fun {}({})\", self.name, arguments_string),\n            _ =\u003e write!(\n                f,\n                \"fun {}({}) -\u003e {}\",\n                self.name, arguments_string, self.return_type\n            ),\n        }\n    }\n}\n\nimpl FunctionPrototype {\n    pub fn new(name: String, arguments: Vec\u003cVariable\u003e, return_type: Type) -\u003e Self {\n        FunctionPrototype {\n            name,\n            arguments,\n            return_type,\n        }\n    }\n\n    pub fn create_argument_scope(\u0026mut self) -\u003e Scope {\n        let mut arg_names: Vec\u003cString\u003e = Vec::new();\n        let mut argument_scope = Scope::new();\n        for arg in \u0026self.arguments {\n            arg_names.push(arg.name().clone());\n            argument_scope.insert_variable(arg.clone())\n        }\n\n        argument_scope\n    }\n}\n","traces":[{"line":16,"address":[193936],"length":1,"stats":{"Line":0}},{"line":17,"address":[193946,194014],"length":1,"stats":{"Line":0}},{"line":18,"address":[194004],"length":1,"stats":{"Line":0}},{"line":19,"address":[193983],"length":1,"stats":{"Line":0}},{"line":32,"address":[194032],"length":1,"stats":{"Line":0}},{"line":40,"address":[194144],"length":1,"stats":{"Line":0}},{"line":41,"address":[194161],"length":1,"stats":{"Line":0}},{"line":53,"address":[195331,194192],"length":1,"stats":{"Line":0}},{"line":54,"address":[194230],"length":1,"stats":{"Line":0}},{"line":55,"address":[194240,194312],"length":1,"stats":{"Line":0}},{"line":56,"address":[194802,195068,194392,195326],"length":1,"stats":{"Line":0}},{"line":57,"address":[194841,195086],"length":1,"stats":{"Line":0}},{"line":59,"address":[194851,194821],"length":1,"stats":{"Line":0}},{"line":62,"address":[194412],"length":1,"stats":{"Line":0}},{"line":63,"address":[194504,194461],"length":1,"stats":{"Line":0}},{"line":64,"address":[194481,194649],"length":1,"stats":{"Line":0}},{"line":74,"address":[195360],"length":1,"stats":{"Line":0}},{"line":82,"address":[195440,195920],"length":1,"stats":{"Line":0}},{"line":83,"address":[195475],"length":1,"stats":{"Line":0}},{"line":84,"address":[195485],"length":1,"stats":{"Line":0}},{"line":85,"address":[195599,195534],"length":1,"stats":{"Line":0}},{"line":86,"address":[195758,195708],"length":1,"stats":{"Line":0}},{"line":87,"address":[195888],"length":1,"stats":{"Line":0}},{"line":90,"address":[195720],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","scope.rs"],"content":"use std::collections::HashMap;\n\nuse serde::Serialize;\n\nuse crate::midend::types::Type;\n\nuse super::{\n    errors::UndefinedSymbolError,\n    type_definitions::{StructRepr, TypeDefinition, TypeRepr},\n    variable::Variable,\n};\n\n#[derive(Debug, Serialize)]\npub struct Scope {\n    subscope_indices: Vec\u003cusize\u003e,\n    variables: HashMap\u003cString, Variable\u003e,\n    subscopes: Vec\u003cScope\u003e,\n    type_definitions: HashMap\u003cType, TypeDefinition\u003e,\n}\n\nimpl Scope {\n    pub fn new() -\u003e Self {\n        Scope {\n            subscope_indices: Vec::new(),\n            variables: HashMap::new(),\n            subscopes: Vec::new(),\n            type_definitions: HashMap::new(),\n        }\n    }\n\n    pub fn insert_variable(\u0026mut self, mut variable: Variable) {\n        variable.add_mangled_name(\u0026self.subscope_indices);\n        self.variables.insert(variable.name().clone(), variable);\n    }\n\n    pub fn lookup_declared_variable_by_name\u003c'a\u003e(\u0026'a self, name: \u0026str) -\u003e \u0026'a Variable {\n        self.variables\n            .get(name)\n            .expect(\u0026format!(\"Use of undeclared variable {}\", name))\n    }\n\n    pub fn lookup_variable_by_name(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026Variable, UndefinedSymbolError\u003e {\n        self.variables\n            .get(name)\n            .ok_or(UndefinedSymbolError::variable(name))\n    }\n\n    pub fn lookup_type\u003c'a\u003e(\n        \u0026'a self,\n        type_: \u0026Type,\n    ) -\u003e Result\u003c\u0026'a TypeDefinition, UndefinedSymbolError\u003e {\n        self.type_definitions\n            .get(type_)\n            .ok_or(UndefinedSymbolError::type_(type_))\n    }\n\n    pub fn lookup_type_mut\u003c'a\u003e(\n        \u0026'a mut self,\n        type_: \u0026Type,\n    ) -\u003e Result\u003c\u0026'a mut TypeDefinition, UndefinedSymbolError\u003e {\n        self.type_definitions\n            .get_mut(type_)\n            .ok_or(UndefinedSymbolError::type_(type_))\n    }\n\n    pub fn lookup_struct\u003c'a\u003e(\u0026'a self, name: \u0026str) -\u003e Result\u003c\u0026'a StructRepr, UndefinedSymbolError\u003e {\n        let struct_type = Type::UDT(name.into());\n\n        match self.type_definitions.get(\u0026struct_type) {\n            Some(definition) =\u003e match \u0026definition.repr {\n                TypeRepr::Struct(struct_definition) =\u003e return Ok(struct_definition),\n            },\n            None =\u003e {}\n        }\n\n        Err(UndefinedSymbolError::struct_(name))\n    }\n\n    pub fn insert_subscope(\u0026mut self, subscope: Scope) {\n        self.subscopes.push(subscope);\n    }\n\n    pub fn insert_struct_definition(\u0026mut self, defined_struct: StructRepr) {\n        let struct_type = Type::UDT(defined_struct.name.clone());\n        let def = TypeDefinition::new(struct_type.clone(), TypeRepr::Struct(defined_struct));\n        self.type_definitions.insert(struct_type, def);\n    }\n}\n","traces":[{"line":22,"address":[543306,543024],"length":1,"stats":{"Line":1}},{"line":24,"address":[543046],"length":1,"stats":{"Line":2}},{"line":25,"address":[543056],"length":1,"stats":{"Line":2}},{"line":26,"address":[543105],"length":1,"stats":{"Line":2}},{"line":27,"address":[543151],"length":1,"stats":{"Line":3}},{"line":31,"address":[543670,543328],"length":1,"stats":{"Line":0}},{"line":32,"address":[543366],"length":1,"stats":{"Line":0}},{"line":33,"address":[543440],"length":1,"stats":{"Line":0}},{"line":36,"address":[543994,543712],"length":1,"stats":{"Line":0}},{"line":37,"address":[543951,543737],"length":1,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[543761],"length":1,"stats":{"Line":0}},{"line":42,"address":[544016],"length":1,"stats":{"Line":0}},{"line":43,"address":[544126,544082],"length":1,"stats":{"Line":0}},{"line":45,"address":[544106],"length":1,"stats":{"Line":0}},{"line":48,"address":[544160],"length":1,"stats":{"Line":0}},{"line":52,"address":[544208,544247],"length":1,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[544227],"length":1,"stats":{"Line":0}},{"line":57,"address":[544272],"length":1,"stats":{"Line":0}},{"line":61,"address":[544359,544320],"length":1,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[544339],"length":1,"stats":{"Line":0}},{"line":66,"address":[544384,544711],"length":1,"stats":{"Line":0}},{"line":67,"address":[544454],"length":1,"stats":{"Line":0}},{"line":69,"address":[544559,544496],"length":1,"stats":{"Line":0}},{"line":70,"address":[544597],"length":1,"stats":{"Line":0}},{"line":71,"address":[544610],"length":1,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[544661],"length":1,"stats":{"Line":0}},{"line":79,"address":[544736],"length":1,"stats":{"Line":0}},{"line":80,"address":[544741],"length":1,"stats":{"Line":0}},{"line":83,"address":[544768,545283],"length":1,"stats":{"Line":0}},{"line":84,"address":[544873,544792],"length":1,"stats":{"Line":0}},{"line":85,"address":[544964,544914],"length":1,"stats":{"Line":0}},{"line":86,"address":[545171],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":36},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","type_definitions.rs"],"content":"use std::collections::HashMap;\n\nuse serde::Serialize;\n\nuse crate::midend::types::Type;\n\nuse super::{function::FunctionOrPrototype, variable::Variable, Function, UndefinedSymbolError};\n\n#[derive(Debug, Serialize)]\npub struct TypeDefinition {\n    type_: Type,\n    pub repr: TypeRepr,\n    methods: HashMap\u003cString, FunctionOrPrototype\u003e,\n    associated_functions: HashMap\u003cString, FunctionOrPrototype\u003e,\n}\n\nimpl TypeDefinition {\n    pub fn new(type_: Type, repr: TypeRepr) -\u003e Self {\n        TypeDefinition {\n            type_,\n            repr,\n            methods: HashMap::new(),\n            associated_functions: HashMap::new(),\n        }\n    }\n\n    pub fn lookup_method(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026FunctionOrPrototype, UndefinedSymbolError\u003e {\n        self.methods\n            .get(name)\n            .ok_or(UndefinedSymbolError::method(\u0026self.type_, name))\n    }\n\n    pub fn add_method(\u0026mut self, method: Function) {\n        self.methods\n            .insert(method.name(), FunctionOrPrototype::Function(method));\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub enum TypeRepr {\n    Struct(StructRepr),\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct StructRepr {\n    pub name: String,\n    fields: HashMap\u003cString, Variable\u003e,\n    field_order: Vec\u003cString\u003e,\n}\n\nimpl StructRepr {\n    pub fn new(name: String) -\u003e Self {\n        Self {\n            name,\n            fields: HashMap::new(),\n            field_order: Vec::new(),\n        }\n    }\n\n    pub fn add_field(\u0026mut self, name: String, type_: Type) {\n        self.fields\n            .insert(name.clone(), Variable::new(name.clone(), type_));\n        self.field_order.push(name);\n    }\n\n    pub fn get_field(\u0026self, name: \u0026String) -\u003e Option\u003c\u0026Variable\u003e {\n        self.fields.get(name)\n    }\n}\n","traces":[{"line":18,"address":[293648,293976,293955],"length":1,"stats":{"Line":0}},{"line":22,"address":[293745],"length":1,"stats":{"Line":0}},{"line":23,"address":[293797],"length":1,"stats":{"Line":0}},{"line":27,"address":[294000],"length":1,"stats":{"Line":0}},{"line":28,"address":[294066,294118],"length":1,"stats":{"Line":0}},{"line":30,"address":[294094],"length":1,"stats":{"Line":0}},{"line":33,"address":[294144,294373,294398],"length":1,"stats":{"Line":0}},{"line":34,"address":[294346,294164],"length":1,"stats":{"Line":0}},{"line":35,"address":[294358,294197,294250],"length":1,"stats":{"Line":0}},{"line":52,"address":[294416,294635],"length":1,"stats":{"Line":0}},{"line":55,"address":[294454],"length":1,"stats":{"Line":0}},{"line":56,"address":[294504],"length":1,"stats":{"Line":0}},{"line":60,"address":[294656,295112,295079],"length":1,"stats":{"Line":0}},{"line":61,"address":[294685,294933],"length":1,"stats":{"Line":0}},{"line":62,"address":[294796,294734,294966,295060],"length":1,"stats":{"Line":0}},{"line":63,"address":[294995],"length":1,"stats":{"Line":0}},{"line":66,"address":[295152],"length":1,"stats":{"Line":0}},{"line":67,"address":[295166],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","variable.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::types::Type;\n\n#[derive(Clone, Debug, Serialize)]\npub struct Variable {\n    name: String,\n    mangled_name: Option\u003cString\u003e,\n    type_: Type,\n}\n\nimpl Display for Variable {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}\", self.type_, self.name)\n    }\n}\n\nimpl Variable {\n    pub fn new(name: String, type_: Type) -\u003e Self {\n        Variable {\n            name,\n            mangled_name: None,\n            type_,\n        }\n    }\n\n    pub fn add_mangled_name(\u0026mut self, scope_indices: \u0026Vec\u003cusize\u003e) {\n        let mut mangled_name = String::new();\n        for scope in scope_indices {\n            mangled_name.push_str(\u0026(scope.to_string() + \u0026String::from(\"_\")));\n        }\n        mangled_name.push_str(\u0026self.name.clone());\n\n        match \u0026self.mangled_name {\n            Some(current_name) =\u003e {\n                panic!(\n                \"Variable {} already has mangled name {}, can't add_mangled_name with new name {}\",\n                self.name,\n                current_name,\n                mangled_name)\n            }\n            None =\u003e self.mangled_name.replace(mangled_name),\n        };\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        match \u0026self.mangled_name {\n            Some(mangled_name) =\u003e mangled_name.clone(),\n            None =\u003e self.name.clone(),\n        }\n    }\n\n    pub fn type_(\u0026self) -\u003e \u0026Type {\n        \u0026self.type_\n    }\n}\n","traces":[{"line":15,"address":[177792],"length":1,"stats":{"Line":0}},{"line":16,"address":[177831],"length":1,"stats":{"Line":0}},{"line":21,"address":[177952],"length":1,"stats":{"Line":0}},{"line":29,"address":[178759,179152,178048],"length":1,"stats":{"Line":0}},{"line":30,"address":[178081],"length":1,"stats":{"Line":0}},{"line":31,"address":[178188,178120],"length":1,"stats":{"Line":0}},{"line":32,"address":[178286,178768],"length":1,"stats":{"Line":0}},{"line":34,"address":[178301],"length":1,"stats":{"Line":0}},{"line":36,"address":[178435],"length":1,"stats":{"Line":0}},{"line":37,"address":[178490],"length":1,"stats":{"Line":0}},{"line":38,"address":[178626,178506],"length":1,"stats":{"Line":0}},{"line":44,"address":[178518],"length":1,"stats":{"Line":0}},{"line":48,"address":[179184],"length":1,"stats":{"Line":0}},{"line":49,"address":[179208],"length":1,"stats":{"Line":0}},{"line":50,"address":[179263],"length":1,"stats":{"Line":0}},{"line":51,"address":[179286],"length":1,"stats":{"Line":0}},{"line":55,"address":[179312],"length":1,"stats":{"Line":0}},{"line":56,"address":[179320],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab.rs"],"content":"use crate::midend::types::Type;\nuse std::collections::HashMap;\n\npub use errors::*;\npub use function::*;\npub use scope::Scope;\nuse serde::Serialize;\nuse std::fmt::Display;\npub use type_definitions::*;\npub use variable::*;\n\nuse super::ir;\n\nmod errors;\nmod function;\nmod scope;\nmod type_definitions;\nmod variable;\n\n#[derive(Debug, Serialize)]\npub struct SymbolTable {\n    pub global_scope: Scope,\n    pub functions: HashMap\u003cString, FunctionOrPrototype\u003e,\n}\n\nimpl SymbolTable {\n    pub fn new() -\u003e Self {\n        SymbolTable {\n            global_scope: Scope::new(),\n            functions: HashMap::new(),\n        }\n    }\n\n    pub fn assign_program_points(\u0026mut self) {\n        // TODO: re-enable this when SSA implemented\n        // for function in self.functions.values_mut() {\n        //     match function {\n        //         FunctionOrPrototype::Function(f) =\u003e {\n        //             f.control_flow_mut().assign_program_points();\n        //             let mut reaching_defs = ReachingDefs::new(f.control_flow());\n        //             reaching_defs.analyze();\n        //             reaching_defs.print();\n        //         }\n        //         FunctionOrPrototype::Prototype(_) =\u003e {}\n        //     }\n        // }\n    }\n\n    pub fn print_ir(\u0026self) {\n        for function in self.functions.values() {\n            match function {\n                FunctionOrPrototype::Function(f) =\u003e {\n                    println!(\"{}\", f.prototype);\n                    f.control_flow.to_graphviz();\n                    println!(\"\");\n                }\n                FunctionOrPrototype::Prototype(_) =\u003e {}\n            }\n        }\n    }\n\n    pub fn insert_function(\u0026mut self, function: Function) {\n        self.functions\n            .insert(function.name(), FunctionOrPrototype::Function(function));\n    }\n\n    pub fn insert_function_prototype(\u0026mut self, prototype: FunctionPrototype) {\n        self.functions.insert(\n            prototype.name.clone(),\n            FunctionOrPrototype::Prototype(prototype),\n        );\n    }\n}\n","traces":[{"line":27,"address":[168864,169003],"length":1,"stats":{"Line":0}},{"line":29,"address":[168886],"length":1,"stats":{"Line":0}},{"line":30,"address":[168899],"length":1,"stats":{"Line":0}},{"line":34,"address":[169040],"length":1,"stats":{"Line":0}},{"line":49,"address":[169056],"length":1,"stats":{"Line":0}},{"line":50,"address":[169074],"length":1,"stats":{"Line":0}},{"line":51,"address":[169196],"length":1,"stats":{"Line":0}},{"line":52,"address":[169243],"length":1,"stats":{"Line":0}},{"line":53,"address":[169251],"length":1,"stats":{"Line":0}},{"line":54,"address":[169344],"length":1,"stats":{"Line":0}},{"line":55,"address":[169356],"length":1,"stats":{"Line":0}},{"line":62,"address":[169640,169408,169665],"length":1,"stats":{"Line":0}},{"line":63,"address":[169428,169613],"length":1,"stats":{"Line":0}},{"line":64,"address":[169517,169625,169464],"length":1,"stats":{"Line":0}},{"line":67,"address":[170011,169680,170036],"length":1,"stats":{"Line":0}},{"line":68,"address":[169700,169984],"length":1,"stats":{"Line":0}},{"line":69,"address":[169728],"length":1,"stats":{"Line":0}},{"line":70,"address":[169798],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","types.rs"],"content":"use serde::Serialize;\nuse std::fmt::Display;\n\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Serialize, serde::Deserialize, Hash)]\npub enum Mutability {\n    Mutable,\n    Immutable,\n}\n\nimpl Display for Mutability {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Mutability::Mutable =\u003e write!(f, \"mut\"),\n            Mutability::Immutable =\u003e std::fmt::Result::Ok(()),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug, Serialize, serde::Deserialize, Hash)]\npub enum Type {\n    Unit,\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    UDT(String),\n    Self_,\n    Reference(Mutability, Box\u003cType\u003e),\n    Pointer(Mutability, Box\u003cType\u003e),\n}\n\nimpl Display for Type {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Unit =\u003e write!(f, \"()\"),\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::UDT(name) =\u003e write!(f, \"user-defined type {}\", name),\n            Self::Self_ =\u003e write!(f, \"Self\"),\n            Self::Reference(mutability, to) =\u003e write!(f, \"\u0026{} {}\", mutability, to),\n            Self::Pointer(mutability, to) =\u003e write!(f, \"*{} {}\", mutability, to),\n        }\n    }\n}\n","traces":[{"line":11,"address":[180144],"length":1,"stats":{"Line":0}},{"line":12,"address":[180163],"length":1,"stats":{"Line":0}},{"line":13,"address":[180185],"length":1,"stats":{"Line":0}},{"line":14,"address":[180178],"length":1,"stats":{"Line":0}},{"line":37,"address":[180240],"length":1,"stats":{"Line":0}},{"line":38,"address":[180272],"length":1,"stats":{"Line":0}},{"line":39,"address":[180332],"length":1,"stats":{"Line":0}},{"line":40,"address":[180375],"length":1,"stats":{"Line":0}},{"line":41,"address":[180418],"length":1,"stats":{"Line":0}},{"line":42,"address":[180467],"length":1,"stats":{"Line":0}},{"line":43,"address":[180516],"length":1,"stats":{"Line":0}},{"line":44,"address":[180565],"length":1,"stats":{"Line":0}},{"line":45,"address":[180614],"length":1,"stats":{"Line":0}},{"line":46,"address":[180663],"length":1,"stats":{"Line":0}},{"line":47,"address":[180712],"length":1,"stats":{"Line":0}},{"line":48,"address":[180765],"length":1,"stats":{"Line":0}},{"line":49,"address":[180884],"length":1,"stats":{"Line":0}},{"line":50,"address":[180937],"length":1,"stats":{"Line":0}},{"line":51,"address":[181132],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend.rs"],"content":"use symtab::SymbolTable;\n\nuse crate::frontend;\n\nmod idfa;\npub mod ir;\npub mod linearizer;\nmod optimization;\nmod ssa_gen;\npub mod symtab;\npub mod types;\n\npub fn symbol_table_from_program(\n    program: Vec\u003cfrontend::ast::TranslationUnitTree\u003e,\n) -\u003e symtab::SymbolTable {\n    let mut symtab = SymbolTable::new();\n    linearizer::linearize(\u0026mut symtab, program);\n\n    // ssa_gen::convert_functions_to_ssa(\u0026mut symtab.functions);\n\n    // optimization::optimize_functions(\u0026mut symtab.functions);\n\n    symtab\n}\n","traces":[{"line":13,"address":[1023632,1023846],"length":1,"stats":{"Line":0}},{"line":16,"address":[1023654],"length":1,"stats":{"Line":0}},{"line":17,"address":[1023728],"length":1,"stats":{"Line":0}},{"line":23,"address":[1023818],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4}]};
        var previousData = {"files":[{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc","block_depths.rs"],"content":"use std::{\n    collections::{BTreeMap, VecDeque},\n    usize,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\nstruct BlockDepthMetadata\u003c'a\u003e {\n    depths: BTreeMap\u003cusize, usize\u003e,\n    control_flow: \u0026'a ir::ControlFlow,\n    unknown_predecessors_worklist: VecDeque\u003cusize\u003e,\n}\nimpl\u003c'a\u003e BlockDepthMetadata\u003c'a\u003e {\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            depths: BTreeMap::new(),\n            control_flow,\n            unknown_predecessors_worklist: VecDeque::new(),\n        }\n    }\n\n    fn set_block_depth(\u0026mut self, block_label: usize, depth: usize) {\n        self.depths.insert(block_label, depth);\n    }\n\n    fn max_of_predecessors(\u0026mut self, block_label: usize) -\u003e usize {\n        let mut max = usize::MIN;\n\n        for predecessor_label in \u0026self.control_flow.block_for_label(\u0026block_label).predecessors {\n            let predecessor_depth = match self.depths.get(predecessor_label) {\n                Some(depth) =\u003e *depth,\n                None =\u003e {\n                    self.unknown_predecessors_worklist\n                        .push_back(*predecessor_label);\n                    usize::MIN\n                }\n            };\n\n            max = usize::max(predecessor_depth, max);\n        }\n\n        max\n    }\n\n    fn visit(\u0026mut self, block_label: usize) {\n        let max_predecessor_depth = self.max_of_predecessors(block_label);\n        self.set_block_depth(block_label, max_predecessor_depth + 1);\n    }\n}\n\npub fn find_block_depths(control_flow: \u0026ir::ControlFlow) -\u003e BTreeMap\u003cusize, usize\u003e {\n    let mut metadata = BlockDepthMetadata::new(control_flow);\n\n    for (label, _) in control_flow.blocks_postorder() {\n        metadata.visit(label);\n    }\n\n    while let Some(unvisited) = metadata.unknown_predecessors_worklist.pop_front() {\n        metadata.visit(unvisited);\n    }\n\n    metadata.depths\n}\n","traces":[{"line":15,"address":[252992,253150],"length":1,"stats":{"Line":0}},{"line":17,"address":[253020],"length":1,"stats":{"Line":0}},{"line":19,"address":[253030],"length":1,"stats":{"Line":0}},{"line":23,"address":[253184],"length":1,"stats":{"Line":0}},{"line":24,"address":[253202],"length":1,"stats":{"Line":0}},{"line":27,"address":[253216],"length":1,"stats":{"Line":0}},{"line":28,"address":[253241],"length":1,"stats":{"Line":0}},{"line":30,"address":[253529,253250],"length":1,"stats":{"Line":0}},{"line":31,"address":[253376],"length":1,"stats":{"Line":0}},{"line":32,"address":[253439],"length":1,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[253481],"length":1,"stats":{"Line":0}},{"line":35,"address":[253478],"length":1,"stats":{"Line":0}},{"line":36,"address":[253493],"length":1,"stats":{"Line":0}},{"line":40,"address":[253505],"length":1,"stats":{"Line":0}},{"line":43,"address":[253426],"length":1,"stats":{"Line":0}},{"line":46,"address":[253536],"length":1,"stats":{"Line":0}},{"line":47,"address":[253560],"length":1,"stats":{"Line":0}},{"line":48,"address":[253609,253570],"length":1,"stats":{"Line":0}},{"line":52,"address":[254114,253632],"length":1,"stats":{"Line":0}},{"line":53,"address":[253667],"length":1,"stats":{"Line":0}},{"line":55,"address":[253742,253869,253685],"length":1,"stats":{"Line":0}},{"line":56,"address":[254109,253937],"length":1,"stats":{"Line":0}},{"line":59,"address":[253967],"length":1,"stats":{"Line":0}},{"line":60,"address":[254043,254104],"length":1,"stats":{"Line":0}},{"line":63,"address":[254055],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc","lifetime.rs"],"content":"use std::{collections::HashMap, fmt};\n\nuse crate::midend;\n\n#[derive(Clone, PartialOrd, Ord, PartialEq, Eq, Debug)]\npub struct Lifetime {\n    pub name: midend::ir::OperandName,\n    pub start: usize,\n    pub end: usize,\n    pub n_reads: usize,\n    pub n_writes: usize,\n}\n\nimpl Lifetime {\n    pub fn new(name: midend::ir::OperandName) -\u003e Self {\n        Lifetime {\n            name: name,\n            start: usize::MAX,\n            end: usize::MIN,\n            n_reads: 0,\n            n_writes: 0,\n        }\n    }\n\n    fn update_range(\u0026mut self, potential_range_limit: \u0026usize) {\n        if *potential_range_limit \u003c self.start {\n            self.start = *potential_range_limit;\n        }\n        if self.end \u003c *potential_range_limit {\n            self.end = *potential_range_limit;\n        }\n    }\n\n    pub fn record_read(\u0026mut self, at_index: \u0026usize) {\n        self.n_reads += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn record_write(\u0026mut self, at_index: \u0026usize) {\n        self.n_writes += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn live_at(\u0026self, at_index: \u0026usize) -\u003e bool {\n        (self.start \u003c= *at_index) \u0026\u0026 (self.end \u003e= *at_index)\n    }\n}\n\nimpl std::fmt::Display for Lifetime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{}: {}-{}]\", self.name, self.start, self.end)\n    }\n}\n\npub struct LifetimeSet {\n    pub lifetimes: HashMap\u003cmidend::ir::OperandName, Lifetime\u003e,\n}\n\nimpl LifetimeSet {\n    fn new() -\u003e Self {\n        LifetimeSet {\n            lifetimes: HashMap::\u003cmidend::ir::OperandName, Lifetime\u003e::new(),\n        }\n    }\n\n    pub fn from_block(block: \u0026midend::ir::BasicBlock) -\u003e Self {\n        let mut lifetimes = Self::new();\n\n        for (index, line) in block.statements.iter().enumerate() {\n            for read_operand in line.read_operand_names() {\n                lifetimes.record_read_at_index(read_operand, \u0026index);\n            }\n\n            for write_operand in line.write_operand_names() {\n                lifetimes.record_write_at_index(write_operand, \u0026index);\n            }\n        }\n\n        lifetimes\n    }\n\n    fn lookup_or_create_lifetime_by_name(\n        \u0026mut self,\n        name: \u0026midend::ir::OperandName,\n    ) -\u003e \u0026mut Lifetime {\n        if !self.lifetimes.contains_key(name) {\n            self.lifetimes\n                .insert(name.clone(), Lifetime::new(name.clone()));\n        }\n\n        self.lifetimes.get_mut(name).unwrap()\n    }\n\n    pub fn record_read_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_read(index);\n    }\n\n    pub fn record_write_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_write(index);\n    }\n\n    pub fn print_numerical(\u0026self) {\n        for lifetime in self.lifetimes.values() {\n            println!(\n                \"{:\u003e20}: [{}-{}]\",\n                lifetime.name, lifetime.start, lifetime.end\n            );\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use crate::midend;\n\n    use super::Lifetime;\n\n    #[test]\n    fn test_lifetime_range() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        dummy_lifetime.record_read(\u00261);\n\n        assert!(dummy_lifetime.start == 1);\n        assert!(dummy_lifetime.start == dummy_lifetime.end);\n\n        dummy_lifetime.record_write(\u00260);\n\n        assert!(dummy_lifetime.start == 0);\n        assert!(dummy_lifetime.end == 1);\n    }\n\n    #[test]\n    fn test_lifetime_format() {\n        let mut dummy_lifetime =\n            Lifetime::new(midend::ir::OperandName::new_basic(\"my_variable\".into()));\n\n        let start_point = 2;\n        let end_point = 4;\n\n        dummy_lifetime.record_write(\u0026start_point);\n        dummy_lifetime.record_write(\u0026end_point);\n\n        assert_eq!(\n            format!(\"{}\", dummy_lifetime),\n            format!(\"[my_variable: {}-{}]\", start_point, end_point)\n        );\n    }\n\n    #[test]\n    fn test_lifetime_live_at() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        assert!(!dummy_lifetime.live_at(\u00260));\n        dummy_lifetime.record_write(\u00260);\n        dummy_lifetime.record_write(\u00265);\n\n        for index in 0..5 {\n            assert!(dummy_lifetime.live_at(\u0026index));\n        }\n    }\n}\n","traces":[{"line":15,"address":[279472],"length":1,"stats":{"Line":3}},{"line":25,"address":[279552],"length":1,"stats":{"Line":3}},{"line":26,"address":[279572,279619],"length":1,"stats":{"Line":6}},{"line":27,"address":[279612],"length":1,"stats":{"Line":3}},{"line":29,"address":[279591,279639],"length":1,"stats":{"Line":6}},{"line":30,"address":[279632],"length":1,"stats":{"Line":3}},{"line":34,"address":[279648],"length":1,"stats":{"Line":1}},{"line":35,"address":[279671,279717],"length":1,"stats":{"Line":1}},{"line":36,"address":[279707],"length":1,"stats":{"Line":1}},{"line":39,"address":[279744],"length":1,"stats":{"Line":1}},{"line":40,"address":[279767,279813],"length":1,"stats":{"Line":1}},{"line":41,"address":[279803],"length":1,"stats":{"Line":2}},{"line":44,"address":[279840],"length":1,"stats":{"Line":1}},{"line":45,"address":[279860],"length":1,"stats":{"Line":1}},{"line":50,"address":[279920],"length":1,"stats":{"Line":1}},{"line":51,"address":[279959],"length":1,"stats":{"Line":1}},{"line":60,"address":[280144],"length":1,"stats":{"Line":0}},{"line":62,"address":[280158],"length":1,"stats":{"Line":0}},{"line":66,"address":[281126,280208,281112],"length":1,"stats":{"Line":0}},{"line":67,"address":[280243],"length":1,"stats":{"Line":0}},{"line":69,"address":[280253,280317],"length":1,"stats":{"Line":0}},{"line":70,"address":[280749,280557,280613],"length":1,"stats":{"Line":0}},{"line":71,"address":[280817,281121],"length":1,"stats":{"Line":0}},{"line":74,"address":[281014,280855],"length":1,"stats":{"Line":0}},{"line":75,"address":[281107,281082],"length":1,"stats":{"Line":0}},{"line":79,"address":[280569],"length":1,"stats":{"Line":0}},{"line":82,"address":[281398,281423,281152],"length":1,"stats":{"Line":0}},{"line":86,"address":[281192],"length":1,"stats":{"Line":0}},{"line":87,"address":[281342],"length":1,"stats":{"Line":0}},{"line":88,"address":[281375,281206,281281,281416],"length":1,"stats":{"Line":0}},{"line":91,"address":[281184,281253],"length":1,"stats":{"Line":0}},{"line":94,"address":[281440],"length":1,"stats":{"Line":0}},{"line":95,"address":[281464],"length":1,"stats":{"Line":0}},{"line":99,"address":[281488],"length":1,"stats":{"Line":0}},{"line":100,"address":[281512],"length":1,"stats":{"Line":0}},{"line":104,"address":[281536],"length":1,"stats":{"Line":0}},{"line":105,"address":[281554],"length":1,"stats":{"Line":0}},{"line":106,"address":[281673],"length":1,"stats":{"Line":0}}],"covered":16,"coverable":38},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc","program_point.rs"],"content":"use core::fmt;\n\nuse serde::Serialize;\n\n#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Serialize, Hash)]\npub struct ProgramPoint {\n    pub depth: usize, // depth in the DFS traversal of control flow\n    pub index: usize, // index within a basic block\n}\n\nimpl ProgramPoint {\n    pub fn default() -\u003e Self {\n        Self::new(0, 0)\n    }\n\n    pub fn new(depth: usize, index: usize) -\u003e Self {\n        ProgramPoint { depth, index }\n    }\n}\n\nimpl std::fmt::Display for ProgramPoint {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:\u003e2x}:{:\u003c2x}\", self.depth, self.index)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::backend::regalloc::program_point::ProgramPoint;\n\n    #[test]\n    fn test_default() {\n        let default_point = ProgramPoint::default();\n\n        assert_eq!(default_point.depth, 0);\n        assert_eq!(default_point.index, 0);\n    }\n\n    #[test]\n    fn test_partial_ord_eq() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.partial_cmp(\u0026point_2), Some(Ordering::Greater));\n        assert_eq!(point_1.partial_cmp(\u0026point_3), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_ord() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.cmp(\u0026point_2), Ordering::Greater);\n        assert_eq!(point_1.cmp(\u0026point_3), Ordering::Equal);\n    }\n}\n","traces":[{"line":12,"address":[866976],"length":1,"stats":{"Line":1}},{"line":13,"address":[866981],"length":1,"stats":{"Line":1}},{"line":16,"address":[866992],"length":1,"stats":{"Line":2}},{"line":22,"address":[867024],"length":1,"stats":{"Line":0}},{"line":23,"address":[867063],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend","regalloc.rs"],"content":"use std::collections::{BTreeMap, BTreeSet};\n\nuse lifetime::LifetimeSet;\n\nuse crate::midend::{self, ir::ControlFlow, symtab};\n\nmod block_depths;\nmod lifetime;\nmod program_point;\n\nfn record_interference_graph(\n    graph: \u0026mut BTreeMap\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e,\n    lifetime_a: \u0026midend::ir::OperandName,\n    lifetime_b: \u0026midend::ir::OperandName,\n) {\n    graph\n        .entry(lifetime_a.clone())\n        .or_default()\n        .insert(lifetime_b.clone());\n}\n\npub fn allocate_registers(_scope: \u0026symtab::Scope, control_flow: \u0026ControlFlow) {\n    println!(\"Allocate registers for scope\");\n\n    // let depths = find_block_depths(control_flow);\n\n    let mut graph = BTreeMap::\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e::new();\n\n    for (_, block) in \u0026control_flow.blocks {\n        let block_lifetimes = LifetimeSet::from_block(block);\n\n        for index in 0..block.statements.len() {\n            let mut first_iter = block_lifetimes.lifetimes.iter();\n\n            while let Some((first_name, first_lt)) = first_iter.next() {\n                if first_lt.live_at(\u0026index) {\n                    let mut second_iter = first_iter.clone();\n                    while let Some((second_name, second_lt)) = second_iter.next() {\n                        if second_lt.live_at(\u0026index) {\n                            record_interference_graph(\u0026mut graph, first_name, second_name);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[553376],"length":1,"stats":{"Line":0}},{"line":16,"address":[553430,553483],"length":1,"stats":{"Line":0}},{"line":17,"address":[553416],"length":1,"stats":{"Line":0}},{"line":19,"address":[553465],"length":1,"stats":{"Line":0}},{"line":22,"address":[554417,553504],"length":1,"stats":{"Line":0}},{"line":23,"address":[553535],"length":1,"stats":{"Line":0}},{"line":27,"address":[553588],"length":1,"stats":{"Line":0}},{"line":29,"address":[553609,553656],"length":1,"stats":{"Line":0}},{"line":30,"address":[553793],"length":1,"stats":{"Line":0}},{"line":32,"address":[553887,553826],"length":1,"stats":{"Line":0}},{"line":33,"address":[554052,554027],"length":1,"stats":{"Line":0}},{"line":35,"address":[554062],"length":1,"stats":{"Line":0}},{"line":36,"address":[554185],"length":1,"stats":{"Line":0}},{"line":37,"address":[554225],"length":1,"stats":{"Line":0}},{"line":38,"address":[554242],"length":1,"stats":{"Line":0}},{"line":39,"address":[554364],"length":1,"stats":{"Line":0}},{"line":40,"address":[554405],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","backend.rs"],"content":"mod regalloc;\n\nuse crate::midend;\n\npub fn generate_code_for_function(function: \u0026mut midend::symtab::Function) {\n    println!(\"generate code for {}\", function.prototype);\n    regalloc::allocate_registers(\u0026function.scope, \u0026function.control_flow);\n}\n\npub fn generate_code(mut symbol_table: midend::symtab::SymbolTable) {\n    for (_, member) in \u0026mut symbol_table.functions {\n        match member {\n            midend::symtab::FunctionOrPrototype::Function(f) =\u003e generate_code_for_function(f),\n            midend::symtab::FunctionOrPrototype::Prototype(p) =\u003e println!(\"{}\", p),\n        }\n    }\n}\n","traces":[{"line":5,"address":[768576],"length":1,"stats":{"Line":0}},{"line":6,"address":[768593],"length":1,"stats":{"Line":0}},{"line":7,"address":[768662],"length":1,"stats":{"Line":0}},{"line":10,"address":[768688,769064],"length":1,"stats":{"Line":0}},{"line":11,"address":[768703,768759],"length":1,"stats":{"Line":0}},{"line":12,"address":[768873],"length":1,"stats":{"Line":0}},{"line":13,"address":[768970],"length":1,"stats":{"Line":0}},{"line":14,"address":[768990,768930],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","ast.rs"],"content":"use crate::{frontend::sourceloc::SourceLoc, midend};\nuse std::fmt::Display;\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum TranslationUnit {\n    FunctionDeclaration(FunctionDeclarationTree),\n    FunctionDefinition(FunctionDefinitionTree),\n    StructDefinition(StructDefinitionTree),\n    Implementation(ImplementationTree),\n}\n\nimpl Display for TranslationUnit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::FunctionDeclaration(function_declaration) =\u003e {\n                write!(f, \"Function Declaration: {}\", function_declaration)\n            }\n            Self::FunctionDefinition(function_definition) =\u003e {\n                write!(f, \"Function Definition: {}\", function_definition)\n            }\n            Self::StructDefinition(struct_definition) =\u003e {\n                write!(f, \"Struct Definition: {}\", struct_definition)\n            }\n            Self::Implementation(implementation) =\u003e {\n                write!(f, \"Implementation: {}\", implementation)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TranslationUnitTree {\n    pub loc: SourceLoc,\n    pub contents: TranslationUnit,\n}\nimpl Display for TranslationUnitTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Translation Unit: {}\", self.contents)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub arguments: Vec\u003cVariableDeclarationTree\u003e,\n    pub return_type: Option\u003cTypenameTree\u003e,\n}\nimpl Display for FunctionDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arg_string = String::from(\"\");\n        for argument in \u0026self.arguments {\n            arg_string.push_str(format!(\"{}\\n\", argument).as_str());\n        }\n\n        match \u0026self.return_type {\n            Some(typename_tree) =\u003e write!(\n                f,\n                \"Function Declaration: {}({})-\u003e{}\",\n                self.name, arg_string, typename_tree\n            ),\n            None =\u003e write!(f, \"Function Declaration: {}({})\", self.name, arg_string),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDefinitionTree {\n    pub prototype: FunctionDeclarationTree,\n    pub body: CompoundExpressionTree,\n}\nimpl Display for FunctionDefinitionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Function Definition: {}, {}\", self.prototype, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct StructDefinitionTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub fields: Vec\u003cVariableDeclarationTree\u003e,\n}\nimpl Display for StructDefinitionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut fields = String::new();\n        for field in \u0026self.fields {\n            fields += \u0026field.to_string();\n            fields += \" \";\n        }\n        write!(f, \"Struct Definition: {}: {}\", self.name, fields)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ImplementationTree {\n    pub loc: SourceLoc,\n    pub type_name: TypenameTree,\n    pub items: Vec\u003cFunctionDefinitionTree\u003e,\n}\nimpl Display for ImplementationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Impl {}\", self.type_name).and_then(|_| {\n            for item in \u0026self.items {\n                write!(f, \"{}\", item)?\n            }\n            Ok(())\n        })\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct CompoundExpressionTree {\n    pub loc: SourceLoc,\n    pub statements: Vec\u003cStatementTree\u003e,\n}\nimpl Display for CompoundExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut statement_string = String::from(\"\");\n        for statement in \u0026self.statements {\n            statement_string.push_str(format!(\"{}\\n\", statement).as_str());\n        }\n        write!(f, \"Compound Expression: {}\", statement_string)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct IfExpressionTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub true_block: CompoundExpressionTree,\n    pub false_block: Option\u003cCompoundExpressionTree\u003e,\n}\nimpl Display for IfExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match \u0026self.false_block {\n            Some(false_block) =\u003e write!(\n                f,\n                \"if {}\\n\\t{{{}}} else {{{}}}\",\n                self.condition, self.true_block, false_block\n            ),\n            None =\u003e write!(f, \"if {}\\n\\t{{{}}}\", self.condition, self.true_block),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct WhileExpressionTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub body: CompoundExpressionTree,\n}\nimpl Display for WhileExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"while ({}) {}\", self.condition, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\n\npub struct CallParamsTree {\n    pub loc: SourceLoc,\n    pub params: Vec\u003cExpressionTree\u003e,\n}\nimpl Display for CallParamsTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut params = String::new();\n        for p in \u0026self.params {\n            if params.len() \u003e 0 {\n                params += \u0026\", \";\n            }\n            params += \u0026format!(\"{}\", p);\n        }\n        write!(f, \"{}\", params)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct MethodCallExpressionTree {\n    pub loc: SourceLoc,\n    pub receiver: ExpressionTree,\n    pub called_method: String,\n    pub params: CallParamsTree,\n}\nimpl Display for MethodCallExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}.{}({})\",\n            self.receiver, self.called_method, self.params\n        )\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FieldExpressionTree {\n    pub loc: SourceLoc,\n    pub receiver: ExpressionTree,\n    pub field: String,\n}\nimpl Display for FieldExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}.{}\", self.receiver, self.field)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Statement {\n    VariableDeclaration(VariableDeclarationTree),\n    Expression(ExpressionTree),\n}\n\nimpl Display for Statement {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::VariableDeclaration(variable_declaration) =\u003e {\n                write!(f, \"{}\", variable_declaration)\n            }\n            Self::Expression(expression) =\u003e {\n                write!(f, \"{}\", expression)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct StatementTree {\n    pub loc: SourceLoc,\n    pub statement: Statement,\n}\nimpl Display for StatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.statement)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct VariableDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub typename: TypenameTree,\n}\nimpl Display for VariableDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}: {}\", self.name, self.typename)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct AssignmentTree {\n    pub loc: SourceLoc,\n    pub assignee: Box\u003cExpressionTree\u003e,\n    pub value: Box\u003cExpressionTree\u003e,\n}\nimpl Display for AssignmentTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} = {}\", self.assignee, self.value)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ArithmeticDualOperands {\n    pub e1: Box\u003cExpressionTree\u003e,\n    pub e2: Box\u003cExpressionTree\u003e,\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ArithmeticExpressionTree {\n    Add(ArithmeticDualOperands),\n    Subtract(ArithmeticDualOperands),\n    Multiply(ArithmeticDualOperands),\n    Divide(ArithmeticDualOperands),\n}\nimpl Display for ArithmeticExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e write!(f, \"({} + {})\", operands.e1, operands.e2),\n            Self::Subtract(operands) =\u003e write!(f, \"({} - {})\", operands.e1, operands.e2),\n            Self::Multiply(operands) =\u003e write!(f, \"({} * {})\", operands.e1, operands.e2),\n            Self::Divide(operands) =\u003e write!(f, \"({} / {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ComparisonExpressionTree {\n    LThan(ArithmeticDualOperands),\n    GThan(ArithmeticDualOperands),\n    LThanE(ArithmeticDualOperands),\n    GThanE(ArithmeticDualOperands),\n    Equals(ArithmeticDualOperands),\n    NotEquals(ArithmeticDualOperands),\n}\nimpl Display for ComparisonExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::LThan(operands) =\u003e write!(f, \"({} \u003c {})\", operands.e1, operands.e2),\n            Self::GThan(operands) =\u003e write!(f, \"({} \u003e {})\", operands.e1, operands.e2),\n            Self::LThanE(operands) =\u003e write!(f, \"({} \u003c= {})\", operands.e1, operands.e2),\n            Self::GThanE(operands) =\u003e write!(f, \"({} \u003e= {})\", operands.e1, operands.e2),\n            Self::Equals(operands) =\u003e write!(f, \"({} == {})\", operands.e1, operands.e2),\n            Self::NotEquals(operands) =\u003e write!(f, \"({} != {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Expression {\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Arithmetic(ArithmeticExpressionTree),\n    Comparison(ComparisonExpressionTree),\n    Assignment(AssignmentTree),\n    If(Box\u003cIfExpressionTree\u003e),\n    While(Box\u003cWhileExpressionTree\u003e),\n    FieldExpression(Box\u003cFieldExpressionTree\u003e),\n    MethodCall(Box\u003cMethodCallExpressionTree\u003e),\n}\nimpl Display for Expression {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Identifier(identifier) =\u003e write!(f, \"{}\", identifier),\n            Self::UnsignedDecimalConstant(constant) =\u003e write!(f, \"{}\", constant),\n            Self::Arithmetic(arithmetic_expression) =\u003e write!(f, \"{}\", arithmetic_expression),\n            Self::Comparison(comparison_expression) =\u003e write!(f, \"{}\", comparison_expression),\n            Self::Assignment(assignment_expression) =\u003e write!(f, \"{}\", assignment_expression),\n            Self::If(if_expression) =\u003e write!(f, \"{}\", if_expression),\n            Self::While(while_expression) =\u003e write!(f, \"{}\", while_expression),\n            Self::FieldExpression(field_expression) =\u003e write!(f, \"{}\", field_expression),\n            Self::MethodCall(method_call) =\u003e write!(f, \"{}\", method_call),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ExpressionTree {\n    pub loc: SourceLoc,\n    pub expression: Expression,\n}\nimpl Display for ExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.expression)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TypenameTree {\n    pub loc: SourceLoc,\n    pub type_: midend::types::Type,\n}\n\nimpl Display for TypenameTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.type_)\n    }\n}\n","traces":[{"line":13,"address":[713136],"length":1,"stats":{"Line":0}},{"line":14,"address":[713169],"length":1,"stats":{"Line":0}},{"line":15,"address":[713234],"length":1,"stats":{"Line":0}},{"line":16,"address":[713243],"length":1,"stats":{"Line":0}},{"line":18,"address":[713332],"length":1,"stats":{"Line":0}},{"line":19,"address":[713340],"length":1,"stats":{"Line":0}},{"line":21,"address":[713456],"length":1,"stats":{"Line":0}},{"line":22,"address":[713468],"length":1,"stats":{"Line":0}},{"line":24,"address":[713581],"length":1,"stats":{"Line":0}},{"line":25,"address":[713593],"length":1,"stats":{"Line":0}},{"line":37,"address":[713728],"length":1,"stats":{"Line":0}},{"line":38,"address":[713752],"length":1,"stats":{"Line":0}},{"line":50,"address":[714702,713840],"length":1,"stats":{"Line":0}},{"line":51,"address":[713887],"length":1,"stats":{"Line":0}},{"line":52,"address":[713969,713897],"length":1,"stats":{"Line":0}},{"line":53,"address":[714072,714493],"length":1,"stats":{"Line":0}},{"line":56,"address":[714087],"length":1,"stats":{"Line":0}},{"line":57,"address":[714142,714346],"length":1,"stats":{"Line":0}},{"line":62,"address":[714181],"length":1,"stats":{"Line":0}},{"line":73,"address":[714736],"length":1,"stats":{"Line":0}},{"line":74,"address":[714775],"length":1,"stats":{"Line":0}},{"line":85,"address":[715394,714896],"length":1,"stats":{"Line":0}},{"line":86,"address":[714934],"length":1,"stats":{"Line":0}},{"line":87,"address":[715016,714944],"length":1,"stats":{"Line":0}},{"line":88,"address":[715099,715269],"length":1,"stats":{"Line":0}},{"line":89,"address":[715365],"length":1,"stats":{"Line":0}},{"line":91,"address":[715122],"length":1,"stats":{"Line":0}},{"line":102,"address":[715424],"length":1,"stats":{"Line":0}},{"line":103,"address":[659264],"length":1,"stats":{"Line":0}},{"line":104,"address":[659281],"length":1,"stats":{"Line":0}},{"line":105,"address":[659496,659358],"length":1,"stats":{"Line":0}},{"line":107,"address":[659477],"length":1,"stats":{"Line":0}},{"line":118,"address":[716116,715568],"length":1,"stats":{"Line":0}},{"line":119,"address":[715615],"length":1,"stats":{"Line":0}},{"line":120,"address":[715693,715625],"length":1,"stats":{"Line":0}},{"line":121,"address":[715907,715781],"length":1,"stats":{"Line":0}},{"line":123,"address":[715801],"length":1,"stats":{"Line":0}},{"line":135,"address":[716144],"length":1,"stats":{"Line":0}},{"line":136,"address":[716176],"length":1,"stats":{"Line":0}},{"line":137,"address":[716234],"length":1,"stats":{"Line":0}},{"line":142,"address":[716424],"length":1,"stats":{"Line":0}},{"line":154,"address":[716592],"length":1,"stats":{"Line":0}},{"line":155,"address":[716631],"length":1,"stats":{"Line":0}},{"line":166,"address":[717345,716752],"length":1,"stats":{"Line":0}},{"line":167,"address":[716790],"length":1,"stats":{"Line":0}},{"line":168,"address":[716800,716868],"length":1,"stats":{"Line":0}},{"line":169,"address":[716948,717084],"length":1,"stats":{"Line":0}},{"line":170,"address":[717110],"length":1,"stats":{"Line":0}},{"line":172,"address":[717103,717138],"length":1,"stats":{"Line":0}},{"line":174,"address":[716973],"length":1,"stats":{"Line":0}},{"line":186,"address":[717376],"length":1,"stats":{"Line":0}},{"line":187,"address":[717415],"length":1,"stats":{"Line":0}},{"line":202,"address":[717600],"length":1,"stats":{"Line":0}},{"line":203,"address":[717639],"length":1,"stats":{"Line":0}},{"line":214,"address":[717760],"length":1,"stats":{"Line":0}},{"line":215,"address":[717792],"length":1,"stats":{"Line":0}},{"line":216,"address":[717940],"length":1,"stats":{"Line":0}},{"line":217,"address":[717945],"length":1,"stats":{"Line":0}},{"line":219,"address":[717828],"length":1,"stats":{"Line":0}},{"line":220,"address":[717837],"length":1,"stats":{"Line":0}},{"line":232,"address":[718048],"length":1,"stats":{"Line":0}},{"line":233,"address":[718072],"length":1,"stats":{"Line":0}},{"line":244,"address":[718160],"length":1,"stats":{"Line":0}},{"line":245,"address":[718199],"length":1,"stats":{"Line":0}},{"line":256,"address":[718320],"length":1,"stats":{"Line":0}},{"line":257,"address":[718359],"length":1,"stats":{"Line":0}},{"line":275,"address":[718480],"length":1,"stats":{"Line":0}},{"line":276,"address":[718513],"length":1,"stats":{"Line":0}},{"line":277,"address":[718549],"length":1,"stats":{"Line":0}},{"line":278,"address":[718716],"length":1,"stats":{"Line":0}},{"line":279,"address":[718895],"length":1,"stats":{"Line":0}},{"line":280,"address":[719074],"length":1,"stats":{"Line":0}},{"line":295,"address":[719264],"length":1,"stats":{"Line":0}},{"line":296,"address":[719297],"length":1,"stats":{"Line":0}},{"line":297,"address":[719333],"length":1,"stats":{"Line":0}},{"line":298,"address":[719506],"length":1,"stats":{"Line":0}},{"line":299,"address":[719685],"length":1,"stats":{"Line":0}},{"line":300,"address":[719864],"length":1,"stats":{"Line":0}},{"line":301,"address":[720043],"length":1,"stats":{"Line":0}},{"line":302,"address":[720222],"length":1,"stats":{"Line":0}},{"line":320,"address":[720416],"length":1,"stats":{"Line":0}},{"line":321,"address":[720448],"length":1,"stats":{"Line":0}},{"line":322,"address":[720483],"length":1,"stats":{"Line":0}},{"line":323,"address":[720580],"length":1,"stats":{"Line":0}},{"line":324,"address":[720701],"length":1,"stats":{"Line":0}},{"line":325,"address":[720828],"length":1,"stats":{"Line":0}},{"line":326,"address":[720955],"length":1,"stats":{"Line":0}},{"line":327,"address":[721082],"length":1,"stats":{"Line":0}},{"line":328,"address":[721209],"length":1,"stats":{"Line":0}},{"line":329,"address":[721336],"length":1,"stats":{"Line":0}},{"line":330,"address":[721460],"length":1,"stats":{"Line":0}},{"line":341,"address":[721600],"length":1,"stats":{"Line":0}},{"line":342,"address":[721624],"length":1,"stats":{"Line":0}},{"line":353,"address":[721712],"length":1,"stats":{"Line":0}},{"line":354,"address":[721736],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":95},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","char_source.rs"],"content":"use std::{\n    fs::File,\n    io::{BufRead, BufReader},\n};\n\npub trait ReadChar {\n    fn read_char(\u0026mut self) -\u003e Option\u003cchar\u003e;\n}\n\npub trait ReadLine {\n    fn read_line(\u0026mut self) -\u003e Option\u003cVec\u003cchar\u003e\u003e;\n}\n\n#[derive(Debug)]\npub struct CharReader\u003cT\u003e\nwhere\n    T: ReadLine,\n{\n    line: Option\u003cVec\u003cchar\u003e\u003e,\n    line_source: T,\n}\n\nimpl\u003cT\u003e CharReader\u003cT\u003e\nwhere\n    T: ReadLine,\n{\n    fn new(mut line_source: T) -\u003e Self {\n        Self {\n            line: line_source.read_line(),\n            line_source,\n        }\n    }\n\n    fn next_line(\u0026mut self) {\n        self.line = self.line_source.read_line();\n    }\n}\n\nimpl\u003cT\u003e ReadChar for CharReader\u003cT\u003e\nwhere\n    T: ReadLine,\n{\n    fn read_char(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        loop {\n            if let Some(line) = \u0026mut self.line {\n                if !line.is_empty() {\n                    return line.pop();\n                } else {\n                    self.next_line();\n                }\n            } else {\n                // First call or exhausted previous line\n                self.next_line();\n\n                if self.line.is_none() {\n                    return None;\n                }\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct FileLineReader {\n    lines: std::io::Lines\u003cBufReader\u003cFile\u003e\u003e,\n}\n\nimpl FileLineReader {\n    pub fn new(f: File) -\u003e Self {\n        let reader = BufReader::new(f);\n        FileLineReader {\n            lines: reader.lines(),\n        }\n    }\n}\n\nimpl ReadLine for FileLineReader {\n    fn read_line(\u0026mut self) -\u003e Option\u003cVec\u003cchar\u003e\u003e {\n        let line_option = match self.lines.next() {\n            Some(result) =\u003e match result {\n                Ok(line) =\u003e Some(line),\n                Err(e) =\u003e panic!(\"Couldn't read next line from file: {}\", e),\n            },\n            None =\u003e None,\n        };\n\n        match line_option {\n            Some(string) =\u003e Some(string.chars().rev().collect()),\n            None =\u003e None,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct StrLineReader\u003c'a\u003e {\n    lines: std::str::SplitInclusive\u003c'a, char\u003e,\n}\n\nimpl\u003c'a\u003e StrLineReader\u003c'a\u003e {\n    pub fn new(s: \u0026'a str) -\u003e Self {\n        Self {\n            lines: s.split_inclusive('\\n').to_owned(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e ReadLine for StrLineReader\u003c'a\u003e {\n    fn read_line(\u0026mut self) -\u003e Option\u003cVec\u003cchar\u003e\u003e {\n        let line_option = self.lines.next();\n        match line_option {\n            Some(string) =\u003e Some(string.chars().rev().collect()),\n            None =\u003e None,\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum CharSource\u003c'a\u003e {\n    File(CharReader\u003cFileLineReader\u003e),\n    String(CharReader\u003cStrLineReader\u003c'a\u003e\u003e),\n}\n\nimpl\u003c'a\u003e CharSource\u003c'a\u003e {\n    pub fn from_file(f: File) -\u003e Self {\n        Self::File(CharReader::\u003cFileLineReader\u003e::new(FileLineReader::new(f)))\n    }\n\n    pub fn from_str(s: \u0026'a str) -\u003e Self {\n        Self::String(CharReader::\u003cStrLineReader\u003e::new(StrLineReader::new(s)))\n    }\n}\n\nimpl\u003c'a\u003e ReadChar for CharSource\u003c'a\u003e {\n    fn read_char(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        match self {\n            Self::File(f) =\u003e f.read_char(),\n            Self::String(s) =\u003e s.read_char(),\n        }\n    }\n}\n\nimpl\u003c'a\u003e Iterator for CharSource\u003c'a\u003e {\n    type Item = char;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.read_char()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::frontend::lexer::CharSource;\n\n    #[test]\n    fn string() {\n        let char_source = CharSource::from_str(\n            \"the quick brown\nfox jumps\nover\nthe\nlazy\ndog\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"the quick brown\nfox jumps\nover\nthe\nlazy\ndog\"\n        );\n    }\n\n    #[test]\n    fn string_multiple_newline() {\n        let char_source = CharSource::from_str(\n            \"the quick brown\n\nfox jumps\nover\n\nthe\nlazy\ndog\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"the quick brown\n\nfox jumps\nover\n\nthe\nlazy\ndog\"\n        );\n    }\n\n    #[test]\n    fn string_newline_at_end() {\n        let char_source = CharSource::from_str(\n            \"text\n\n\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"text\n\n\"\n        );\n    }\n\n    #[test]\n    fn string_newline_in_middle_and_at_end() {\n        let char_source = CharSource::from_str(\n            \"some text\n\n\nmore text\n\n\neven more text\n\n\",\n        );\n\n        assert_eq!(\n            char_source.into_iter().collect::\u003cString\u003e(),\n            \"some text\n\n\nmore text\n\n\neven more text\n\n\"\n        );\n    }\n\n    #[test]\n    fn empty_string() {\n        let char_source = CharSource::from_str(\"\");\n\n        assert_eq!(char_source.into_iter().collect::\u003cString\u003e(), \"\");\n    }\n\n    #[test]\n    fn only_newline() {\n        let char_source = CharSource::from_str(\"\\n\");\n\n        assert_eq!(char_source.into_iter().collect::\u003cString\u003e(), \"\\n\");\n    }\n}\n","traces":[{"line":27,"address":[271136,271419,271280,271169],"length":1,"stats":{"Line":16}},{"line":29,"address":[271162,271304],"length":1,"stats":{"Line":17}},{"line":34,"address":[271630,271568,271440,271502],"length":1,"stats":{"Line":1}},{"line":35,"address":[271584,271660,271532,271456],"length":1,"stats":{"Line":7}},{"line":43,"address":[271856,271696],"length":1,"stats":{"Line":21}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[271875,271715],"length":1,"stats":{"Line":22}},{"line":46,"address":[271757,271917],"length":1,"stats":{"Line":22}},{"line":47,"address":[271959,271799],"length":1,"stats":{"Line":22}},{"line":49,"address":[271815,271975],"length":1,"stats":{"Line":5}},{"line":53,"address":[271933,271773],"length":1,"stats":{"Line":1}},{"line":55,"address":[271783,271943],"length":1,"stats":{"Line":6}},{"line":56,"address":[271831,271991],"length":1,"stats":{"Line":6}},{"line":69,"address":[303168],"length":1,"stats":{"Line":0}},{"line":70,"address":[303185],"length":1,"stats":{"Line":0}},{"line":72,"address":[303195],"length":1,"stats":{"Line":0}},{"line":78,"address":[303929,303248,303948],"length":1,"stats":{"Line":0}},{"line":79,"address":[303273],"length":1,"stats":{"Line":0}},{"line":80,"address":[303325],"length":1,"stats":{"Line":0}},{"line":81,"address":[303505],"length":1,"stats":{"Line":0}},{"line":82,"address":[303985,303463],"length":1,"stats":{"Line":0}},{"line":84,"address":[303397],"length":1,"stats":{"Line":0}},{"line":87,"address":[303420],"length":1,"stats":{"Line":0}},{"line":88,"address":[303700,303602],"length":1,"stats":{"Line":0}},{"line":89,"address":[303666],"length":1,"stats":{"Line":0}},{"line":100,"address":[304096],"length":1,"stats":{"Line":15}},{"line":102,"address":[304129],"length":1,"stats":{"Line":16}},{"line":108,"address":[304192],"length":1,"stats":{"Line":17}},{"line":109,"address":[304222],"length":1,"stats":{"Line":21}},{"line":110,"address":[304237],"length":1,"stats":{"Line":21}},{"line":111,"address":[304265],"length":1,"stats":{"Line":20}},{"line":112,"address":[304352],"length":1,"stats":{"Line":1}},{"line":124,"address":[304384],"length":1,"stats":{"Line":0}},{"line":125,"address":[304408],"length":1,"stats":{"Line":0}},{"line":128,"address":[304496],"length":1,"stats":{"Line":6}},{"line":129,"address":[304528],"length":1,"stats":{"Line":6}},{"line":134,"address":[304592],"length":1,"stats":{"Line":6}},{"line":135,"address":[304605],"length":1,"stats":{"Line":21}},{"line":136,"address":[304661],"length":1,"stats":{"Line":0}},{"line":137,"address":[304641],"length":1,"stats":{"Line":21}},{"line":145,"address":[304688],"length":1,"stats":{"Line":6}},{"line":146,"address":[304697],"length":1,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":43},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","errors.rs"],"content":"use crate::frontend::sourceloc::SourceLoc;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum LexError {\n    InvalidChar(InvalidCharError),\n    UnexpectedEof(UnexpectedEofError),\n}\n\nimpl std::fmt::Display for LexError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::InvalidChar(invalid_char) =\u003e {\n                write!(f, \"Invalid char {} at {}\", invalid_char.c, invalid_char.pos)\n            }\n            Self::UnexpectedEof(unexpected_eof) =\u003e {\n                write!(f, \"Unexpected EOF at {}\", unexpected_eof.pos)\n            }\n        }\n    }\n}\n\nimpl LexError {\n    pub fn invalid_char(c: char, pos: SourceLoc) -\u003e Self {\n        Self::InvalidChar(InvalidCharError { c, pos })\n    }\n\n    pub fn unexpected_eof(pos: SourceLoc) -\u003e Self {\n        Self::UnexpectedEof(UnexpectedEofError { pos })\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct InvalidCharError {\n    c: char,\n    pos: SourceLoc,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct UnexpectedEofError {\n    pos: SourceLoc,\n}\n","traces":[{"line":10,"address":[874368],"length":1,"stats":{"Line":0}},{"line":11,"address":[874400],"length":1,"stats":{"Line":0}},{"line":12,"address":[874545],"length":1,"stats":{"Line":0}},{"line":13,"address":[874553],"length":1,"stats":{"Line":0}},{"line":15,"address":[874430],"length":1,"stats":{"Line":0}},{"line":16,"address":[874438],"length":1,"stats":{"Line":0}},{"line":23,"address":[874688],"length":1,"stats":{"Line":0}},{"line":24,"address":[874705],"length":1,"stats":{"Line":0}},{"line":27,"address":[874752],"length":1,"stats":{"Line":0}},{"line":28,"address":[874765],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","integration_tests.rs"],"content":"use super::token::*;\n\n#[cfg(test)]\nfn assert_single_tokenization(input_str: \u0026str, expected_token: Token) {\n    use crate::frontend::lexer::*;\n\n    println!(\n        \"Assert single tokenization against {} == {}\",\n        input_str, expected_token\n    );\n    let result = Lexer::from_string(input_str).lex_all().expect(\"\");\n    assert_eq!(\n        result,\n        vec! {(expected_token, SourceLoc::new(1, 1)), (Token::Eof, SourceLoc::new(1, 1 + input_str.len()))}\n    );\n}\n\n#[test]\nfn tokenize_l_curly() {\n    assert_single_tokenization(\"{\", Token::LCurly);\n}\n\n#[test]\nfn tokenize_r_curly() {\n    assert_single_tokenization(\"}\", Token::RCurly);\n}\n\n#[test]\nfn tokenize_identifier() {\n    assert_single_tokenization(\"abc\", Token::Identifier(String::from(\"abc\")));\n    assert_single_tokenization(\"abc123\", Token::Identifier(String::from(\"abc123\")));\n    assert_single_tokenization(\"abc123def\", Token::Identifier(String::from(\"abc123def\")));\n    assert_single_tokenization(\n        \"unsignedOrSomething_123\",\n        Token::Identifier(String::from(\"unsignedOrSomething_123\")),\n    );\n    assert_single_tokenization(\n        \"u16_named_fred\",\n        Token::Identifier(String::from(\"u16_named_fred\")),\n    );\n}\n\n#[test]\nfn tokenize_unsigned_decimal_constant() {\n    assert_single_tokenization(\"123\", Token::UnsignedDecimalConstant(123));\n    assert_single_tokenization(\n        \u0026usize::MAX.to_string(),\n        Token::UnsignedDecimalConstant(usize::MAX),\n    );\n    assert_single_tokenization(\n        \u0026usize::MIN.to_string(),\n        Token::UnsignedDecimalConstant(usize::MIN),\n    );\n}\n","traces":[{"line":4,"address":[178752,179988,179944],"length":1,"stats":{"Line":4}},{"line":7,"address":[178868,178774],"length":1,"stats":{"Line":8}},{"line":11,"address":[178954],"length":1,"stats":{"Line":3}},{"line":12,"address":[179752],"length":1,"stats":{"Line":3}}],"covered":4,"coverable":4},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","tests.rs"],"content":"use crate::frontend::lexer::Lexer;\n\nuse super::token::Token;\n\n#[test]\nfn peek_none() {\n    let lexer = Lexer::from_string(\u0026\"\");\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn peek() {\n    let lexer = Lexer::from_string(\u0026\"qwerty\");\n    assert!(lexer.peek_char() == Some('q'));\n}\n\n#[test]\nfn advance_char() {\n    let mut lexer = Lexer::from_string(\u0026\"ab\");\n    assert_eq!(lexer.peek_char(), Some('a'));\n    lexer.advance_char();\n    assert_eq!(lexer.peek_char(), Some('b'));\n}\n\n#[test]\nfn advance_to_end() {\n    let mut lexer = Lexer::from_string(\u0026\"a\");\n    lexer.advance_char();\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn test_loc_chars() {\n    let mut lexer = Lexer::from_string(\u0026\"the quick brown\\nfox jumps\\nover the lazy\\ndog\\n\\n\");\n\n    let mut line_lengths = Vec::new();\n    let mut cols = 0;\n\n    while lexer.peek_char().is_some() {\n        let examined = lexer.peek_char().unwrap();\n        lexer.advance_char();\n        match examined {\n            '\\n' =\u003e {\n                line_lengths.push(cols);\n                cols = 0;\n            }\n            _ =\u003e {\n                cols += 1;\n            }\n        }\n    }\n\n    assert_eq!(line_lengths, vec![15, 9, 13, 3, 0]);\n}\n\n// helper function - do some basic prefixing and suffixing\n// ensure keyword matching behaves as expected with alpha/num pre/suffixes\nfn kw_or_ident(string: \u0026str, expected_token: Token) {\n    let mut positive_match = Lexer::from_string(\u0026string);\n\n    let matched = positive_match.match_kw_or_ident();\n    assert_eq!(matched, Some(expected_token.clone()));\n\n    let prefix_alpha = \"a\".to_owned() + string;\n    let mut negative_match = Lexer::from_string(\u0026\u0026prefix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(prefix_alpha))\n    );\n\n    let prefix_num = \"1\".to_owned() + string;\n    negative_match = Lexer::from_string(\u0026\u0026prefix_num);\n    assert_ne!(negative_match.match_kw_or_ident(), Some(expected_token));\n\n    let suffix_alpha = string.to_owned() + \"a\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(suffix_alpha))\n    );\n\n    let suffix_num = string.to_owned() + \"1\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_num);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(suffix_num))\n    );\n}\n\n// test every keyword\n#[test]\nfn keywords() {\n    let keyword_pairings = vec![\n        (\"u8\", Token::U8),\n        (\"u16\", Token::U16),\n        (\"u32\", Token::U32),\n        (\"u64\", Token::U64),\n        (\"i8\", Token::I8),\n        (\"i16\", Token::I16),\n        (\"i32\", Token::I32),\n        (\"i64\", Token::I64),\n        (\"fun\", Token::Fun),\n        (\"if\", Token::If),\n        (\"else\", Token::Else),\n        (\"pub\", Token::Pub),\n        (\"while\", Token::While),\n        (\"struct\", Token::Struct),\n        (\"impl\", Token::Impl),\n        (\"Self\", Token::SelfUpper),\n        (\"self\", Token::SelfLower),\n        (\"mut\", Token::Mut)];\n\n    for (string, token) in keyword_pairings {\n        kw_or_ident(string, token);\n    }\n}\n\n#[test]\nfn ident() {\n    // test out some basic identifiers - such as ones containing keywords\n    kw_or_ident(\"foobar\", Token::Identifier(\"foobar\".to_owned()));\n    kw_or_ident(\"the_u8\", Token::Identifier(\"the_u8\".to_owned()));\n    kw_or_ident(\"big_if_true\", Token::Identifier(\"big_if_true\".to_owned()));\n\n    // make sure that we can correctly parse the end of identifiers\n    let space_after = \"space_after abcde\";\n    let space_after_ident = Token::Identifier(String::from(\"space_after\"));\n    let mut positive_match = Lexer::from_string(\u0026space_after);\n    assert_eq!(\n        positive_match.match_kw_or_ident(),\n        Some(space_after_ident.clone())\n    );\n\n    let prefix_alpha = \"a\".to_owned() + space_after;\n    let mut negative_match = Lexer::from_string(\u0026\u0026prefix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(Token::Identifier(String::from(\"aspace_after\")))\n    );\n\n    let prefix_num = \"1\".to_owned() + space_after;\n    negative_match = Lexer::from_string(\u0026\u0026prefix_num);\n    assert_ne!(\n        negative_match.match_kw_or_ident(),\n        Some(space_after_ident.clone())\n    );\n\n    let suffix_alpha = space_after.to_owned() + \"a\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_alpha);\n    assert_eq!(\n        negative_match.match_kw_or_ident(),\n        Some(space_after_ident.clone())\n    );\n\n    let suffix_num = space_after.to_owned() + \"1\";\n    negative_match = Lexer::from_string(\u0026\u0026suffix_num);\n    assert_eq!(negative_match.match_kw_or_ident(), Some(space_after_ident));\n}\n\n#[test]\nfn token_display_to_token() {\n    let tokens = vec![\n        Token::U8,\n        Token::U16,\n        Token::U32,\n        Token::U64,\n        Token::I8,\n        Token::I16,\n        Token::I32,\n        Token::I64,\n        Token::Plus,\n        Token::Minus,\n        Token::Star,\n        Token::FSlash,\n        Token::GThan,\n        Token::GThanE,\n        Token::LThan,\n        Token::LThanE,\n        Token::Equals,\n        Token::NotEquals,\n        Token::Assign,\n        Token::Fun,\n        Token::If,\n        Token::Else,\n        Token::While,\n        Token::Pub,\n        Token::Struct,\n        Token::Impl,\n        Token::SelfUpper,\n        Token::SelfLower,\n        Token::Mut,\n        Token::Reference,\n        Token::LParen,\n        Token::RParen,\n        Token::Arrow,\n        Token::LCurly,\n        Token::RCurly,\n        Token::Comma,\n        Token::Dot,\n        Token::Semicolon,\n        Token::Colon,\n    ];\n\n    for token in tokens {\n        let lex_result = Lexer::from_string(\u0026format!(\"{}\", token))\n            .lex_all()\n            .expect(\"\");\n        assert_eq!(lex_result.len(), 2);\n        assert_eq!(token, lex_result[0].0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer","token.rs"],"content":"use std::fmt::Display;\n\n#[derive(Clone, Debug)]\npub enum Token {\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    Plus,\n    Minus,\n    Star,\n    FSlash,\n    LThan,\n    GThan,\n    LThanE,\n    GThanE,\n    Equals,\n    NotEquals,\n    Assign,\n    Fun,\n    If,\n    Else,\n    Pub,\n    While,\n    Struct,\n    Impl,\n    SelfUpper,\n    SelfLower,\n    Mut,\n    Reference,\n    LParen,\n    RParen,\n    Arrow,\n    LCurly,\n    RCurly,\n    Comma,\n    Dot,\n    Semicolon,\n    Colon,\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Eof,\n}\n\nimpl PartialEq for Token {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Token::U8, Token::U8) =\u003e true,\n            (Token::U16, Token::U16) =\u003e true,\n            (Token::U32, Token::U32) =\u003e true,\n            (Token::U64, Token::U64) =\u003e true,\n            (Token::I8, Token::I8) =\u003e true,\n            (Token::I16, Token::I16) =\u003e true,\n            (Token::I32, Token::I32) =\u003e true,\n            (Token::I64, Token::I64) =\u003e true,\n            (Token::Plus, Token::Plus) =\u003e true,\n            (Token::Minus, Token::Minus) =\u003e true,\n            (Token::Star, Token::Star) =\u003e true,\n            (Token::FSlash, Token::FSlash) =\u003e true,\n            (Token::LThan, Token::LThan) =\u003e true,\n            (Token::GThan, Token::GThan) =\u003e true,\n            (Token::LThanE, Token::LThanE) =\u003e true,\n            (Token::GThanE, Token::GThanE) =\u003e true,\n            (Token::Equals, Token::Equals) =\u003e true,\n            (Token::NotEquals, Token::NotEquals) =\u003e true,\n            (Token::Assign, Token::Assign) =\u003e true,\n            (Token::Fun, Token::Fun) =\u003e true,\n            (Token::If, Token::If) =\u003e true,\n            (Token::Else, Token::Else) =\u003e true,\n            (Token::While, Token::While) =\u003e true,\n            (Token::Pub, Token::Pub) =\u003e true,\n            (Token::Struct, Token::Struct) =\u003e true,\n            (Token::Impl, Token::Impl) =\u003e true,\n            (Token::SelfUpper, Token::SelfUpper) =\u003e true,\n            (Token::SelfLower, Token::SelfLower) =\u003e true,\n            (Token::Mut, Token::Mut) =\u003e true,\n            (Token::Reference, Token::Reference) =\u003e true,\n            (Token::LParen, Token::LParen) =\u003e true,\n            (Token::RParen, Token::RParen) =\u003e true,\n            (Token::Arrow, Token::Arrow) =\u003e true,\n            (Token::LCurly, Token::LCurly) =\u003e true,\n            (Token::RCurly, Token::RCurly) =\u003e true,\n            (Token::Comma, Token::Comma) =\u003e true,\n            (Token::Dot, Token::Dot) =\u003e true,\n            (Token::Semicolon, Token::Semicolon) =\u003e true,\n            (Token::Colon, Token::Colon) =\u003e true,\n            (Token::Identifier(_), Token::Identifier(_)) =\u003e true,\n            (Token::UnsignedDecimalConstant(_), Token::UnsignedDecimalConstant(_)) =\u003e true,\n            (Token::Eof, Token::Eof) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl Eq for Token {}\n\nimpl Token {\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            Self::U8 =\u003e \"u8\",\n            Self::U16 =\u003e \"u16\",\n            Self::U32 =\u003e \"u32\",\n            Self::U64 =\u003e \"u64\",\n            Self::I8 =\u003e \"i8\",\n            Self::I16 =\u003e \"i16\",\n            Self::I32 =\u003e \"i32\",\n            Self::I64 =\u003e \"i64\",\n            Self::Plus =\u003e \"+\",\n            Self::Minus =\u003e \"-\",\n            Self::Star =\u003e \"*\",\n            Self::FSlash =\u003e \"/\",\n            Self::GThan =\u003e \"\u003e\",\n            Self::GThanE =\u003e \"\u003e=\",\n            Self::LThan =\u003e \"\u003c\",\n            Self::LThanE =\u003e \"\u003c=\",\n            Self::Equals =\u003e \"==\",\n            Self::NotEquals =\u003e \"!=\",\n            Self::Assign =\u003e \"=\",\n            Self::Fun =\u003e \"fun\",\n            Self::If =\u003e \"if\",\n            Self::Else =\u003e \"else\",\n            Self::While =\u003e \"while\",\n            Self::Pub =\u003e \"pub\",\n            Self::Struct =\u003e \"struct\",\n            Self::Impl =\u003e \"impl\",\n            Self::SelfUpper =\u003e \"Self\",\n            Self::SelfLower =\u003e \"self\",\n            Self::Mut =\u003e \"mut\",\n            Self::Reference =\u003e \"\u0026\",\n            Self::LParen =\u003e \"(\",\n            Self::RParen =\u003e \")\",\n            Self::Arrow =\u003e \"-\u003e\",\n            Self::LCurly =\u003e \"{\",\n            Self::RCurly =\u003e \"}\",\n            Self::Comma =\u003e \",\",\n            Self::Dot =\u003e \".\",\n            Self::Semicolon =\u003e \";\",\n            Self::Colon =\u003e \":\",\n            Self::Identifier(_) =\u003e \"identifier\",\n            Self::UnsignedDecimalConstant(_) =\u003e \"unsigned decimal constant\",\n            Self::Eof =\u003e \"EOF\",\n        }\n    }\n}\n\nimpl Display for Token {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::Plus =\u003e write!(f, \"+\"),\n            Self::Minus =\u003e write!(f, \"-\"),\n            Self::Star =\u003e write!(f, \"*\"),\n            Self::FSlash =\u003e write!(f, \"/\"),\n            Self::GThan =\u003e write!(f, \"\u003e\"),\n            Self::GThanE =\u003e write!(f, \"\u003e=\"),\n            Self::LThan =\u003e write!(f, \"\u003c\"),\n            Self::LThanE =\u003e write!(f, \"\u003c=\"),\n            Self::Equals =\u003e write!(f, \"==\"),\n            Self::NotEquals =\u003e write!(f, \"!=\"),\n            Self::Assign =\u003e write!(f, \"=\"),\n            Self::Fun =\u003e write!(f, \"fun\"),\n            Self::If =\u003e write!(f, \"if\"),\n            Self::Else =\u003e write!(f, \"else\"),\n            Self::While =\u003e write!(f, \"while\"),\n            Self::Pub =\u003e write!(f, \"pub\"),\n            Self::Struct =\u003e write!(f, \"struct\"),\n            Self::Impl =\u003e write!(f, \"impl\"),\n            Self::SelfUpper =\u003e write!(f, \"Self\"),\n            Self::SelfLower =\u003e write!(f, \"self\"),\n            Self::Mut =\u003e write!(f, \"mut\"),\n            Self::Reference =\u003e write!(f, \"\u0026\"),\n            Self::LParen =\u003e write!(f, \"(\"),\n            Self::RParen =\u003e write!(f, \")\"),\n            Self::Arrow =\u003e write!(f, \"-\u003e\"),\n            Self::LCurly =\u003e write!(f, \"{{\"),\n            Self::RCurly =\u003e write!(f, \"}}\"),\n            Self::Comma =\u003e write!(f, \",\"),\n            Self::Dot =\u003e write!(f, \".\"),\n            Self::Semicolon =\u003e write!(f, \";\"),\n            Self::Colon =\u003e write!(f, \":\"),\n            Self::Identifier(string) =\u003e write!(f, \"Identifier({})\", string),\n            Self::UnsignedDecimalConstant(constant) =\u003e {\n                write!(f, \"UnsignedDecimalConstant({})\", constant)\n            }\n            Self::Eof =\u003e write!(f, \"EOF\"),\n        }\n    }\n}\n","traces":[{"line":50,"address":[316819,316736],"length":1,"stats":{"Line":1}},{"line":51,"address":[316746,316821],"length":1,"stats":{"Line":3}},{"line":102,"address":[319008],"length":1,"stats":{"Line":0}},{"line":103,"address":[319013],"length":1,"stats":{"Line":0}},{"line":104,"address":[319073],"length":1,"stats":{"Line":0}},{"line":105,"address":[319099],"length":1,"stats":{"Line":0}},{"line":106,"address":[319125],"length":1,"stats":{"Line":0}},{"line":107,"address":[319151],"length":1,"stats":{"Line":0}},{"line":108,"address":[319177],"length":1,"stats":{"Line":0}},{"line":109,"address":[319203],"length":1,"stats":{"Line":0}},{"line":110,"address":[319229],"length":1,"stats":{"Line":0}},{"line":111,"address":[319255],"length":1,"stats":{"Line":0}},{"line":112,"address":[319281],"length":1,"stats":{"Line":0}},{"line":113,"address":[319307],"length":1,"stats":{"Line":0}},{"line":114,"address":[319333],"length":1,"stats":{"Line":0}},{"line":115,"address":[319359],"length":1,"stats":{"Line":0}},{"line":116,"address":[319411],"length":1,"stats":{"Line":0}},{"line":117,"address":[319463],"length":1,"stats":{"Line":0}},{"line":118,"address":[319385],"length":1,"stats":{"Line":0}},{"line":119,"address":[319437],"length":1,"stats":{"Line":0}},{"line":120,"address":[319489],"length":1,"stats":{"Line":0}},{"line":121,"address":[319515],"length":1,"stats":{"Line":0}},{"line":122,"address":[319541],"length":1,"stats":{"Line":0}},{"line":123,"address":[319567],"length":1,"stats":{"Line":0}},{"line":124,"address":[319593],"length":1,"stats":{"Line":0}},{"line":125,"address":[319619],"length":1,"stats":{"Line":0}},{"line":126,"address":[319671],"length":1,"stats":{"Line":0}},{"line":127,"address":[319645],"length":1,"stats":{"Line":0}},{"line":128,"address":[319697],"length":1,"stats":{"Line":0}},{"line":129,"address":[319723],"length":1,"stats":{"Line":0}},{"line":130,"address":[319749],"length":1,"stats":{"Line":0}},{"line":131,"address":[319775],"length":1,"stats":{"Line":0}},{"line":132,"address":[319801],"length":1,"stats":{"Line":0}},{"line":133,"address":[319827],"length":1,"stats":{"Line":0}},{"line":134,"address":[319853],"length":1,"stats":{"Line":0}},{"line":135,"address":[319879],"length":1,"stats":{"Line":0}},{"line":136,"address":[319905],"length":1,"stats":{"Line":0}},{"line":137,"address":[319931],"length":1,"stats":{"Line":0}},{"line":138,"address":[319957],"length":1,"stats":{"Line":0}},{"line":139,"address":[319983],"length":1,"stats":{"Line":0}},{"line":140,"address":[320009],"length":1,"stats":{"Line":0}},{"line":141,"address":[320032],"length":1,"stats":{"Line":0}},{"line":142,"address":[320055],"length":1,"stats":{"Line":0}},{"line":143,"address":[320078],"length":1,"stats":{"Line":0}},{"line":144,"address":[320101],"length":1,"stats":{"Line":0}},{"line":145,"address":[320124],"length":1,"stats":{"Line":0}},{"line":151,"address":[320160],"length":1,"stats":{"Line":4}},{"line":152,"address":[320193],"length":1,"stats":{"Line":4}},{"line":153,"address":[320253],"length":1,"stats":{"Line":1}},{"line":154,"address":[320296],"length":1,"stats":{"Line":1}},{"line":155,"address":[320339],"length":1,"stats":{"Line":1}},{"line":156,"address":[320388],"length":1,"stats":{"Line":1}},{"line":157,"address":[320437],"length":1,"stats":{"Line":1}},{"line":158,"address":[320486],"length":1,"stats":{"Line":1}},{"line":159,"address":[320535],"length":1,"stats":{"Line":1}},{"line":160,"address":[320584],"length":1,"stats":{"Line":1}},{"line":161,"address":[320633],"length":1,"stats":{"Line":1}},{"line":162,"address":[320682],"length":1,"stats":{"Line":1}},{"line":163,"address":[320731],"length":1,"stats":{"Line":1}},{"line":164,"address":[320780],"length":1,"stats":{"Line":1}},{"line":165,"address":[320878],"length":1,"stats":{"Line":1}},{"line":166,"address":[320976],"length":1,"stats":{"Line":1}},{"line":167,"address":[320829],"length":1,"stats":{"Line":1}},{"line":168,"address":[320927],"length":1,"stats":{"Line":1}},{"line":169,"address":[321025],"length":1,"stats":{"Line":1}},{"line":170,"address":[321074],"length":1,"stats":{"Line":1}},{"line":171,"address":[321123],"length":1,"stats":{"Line":1}},{"line":172,"address":[321172],"length":1,"stats":{"Line":1}},{"line":173,"address":[321221],"length":1,"stats":{"Line":1}},{"line":174,"address":[321270],"length":1,"stats":{"Line":1}},{"line":175,"address":[321368],"length":1,"stats":{"Line":1}},{"line":176,"address":[321319],"length":1,"stats":{"Line":1}},{"line":177,"address":[321417],"length":1,"stats":{"Line":1}},{"line":178,"address":[321466],"length":1,"stats":{"Line":1}},{"line":179,"address":[321515],"length":1,"stats":{"Line":0}},{"line":180,"address":[321564],"length":1,"stats":{"Line":0}},{"line":181,"address":[321613],"length":1,"stats":{"Line":0}},{"line":182,"address":[321662],"length":1,"stats":{"Line":0}},{"line":183,"address":[321711],"length":1,"stats":{"Line":1}},{"line":184,"address":[321760],"length":1,"stats":{"Line":1}},{"line":185,"address":[321809],"length":1,"stats":{"Line":1}},{"line":186,"address":[321858],"length":1,"stats":{"Line":1}},{"line":187,"address":[321907],"length":1,"stats":{"Line":1}},{"line":188,"address":[321956],"length":1,"stats":{"Line":1}},{"line":189,"address":[322005],"length":1,"stats":{"Line":0}},{"line":190,"address":[322054],"length":1,"stats":{"Line":1}},{"line":191,"address":[322103],"length":1,"stats":{"Line":1}},{"line":192,"address":[322157],"length":1,"stats":{"Line":1}},{"line":193,"address":[322281],"length":1,"stats":{"Line":1}},{"line":194,"address":[322293],"length":1,"stats":{"Line":1}},{"line":196,"address":[322401],"length":1,"stats":{"Line":0}}],"covered":41,"coverable":91},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","lexer.rs"],"content":"use token::Token;\n\nuse super::sourceloc::SourceLoc;\n\npub use char_source::CharSource;\n\nmod char_source;\npub mod errors;\n#[cfg(test)]\nmod integration_tests;\n#[cfg(test)]\nmod tests;\npub mod token;\n\npub use errors::LexError;\n\n#[derive(Debug)]\npub struct Lexer\u003c'a\u003e {\n    cur_line: usize,\n    cur_col: usize,\n    current_char: Option\u003cchar\u003e,\n    current_token: Option\u003c(Token, SourceLoc)\u003e,\n    char_source: CharSource\u003c'a\u003e,\n}\n\n// public methods:\nimpl\u003c'a\u003e Lexer\u003c'a\u003e {\n    pub fn from_char_source(mut char_source: CharSource\u003c'a\u003e) -\u003e Self {\n        let first_char = char_source.next();\n\n        let start_line = if first_char == Some('\\n') { 2 } else { 1 };\n        let start_col = 1;\n\n        let created = Self {\n            cur_line: start_line,\n            cur_col: start_col,\n            current_char: first_char,\n            current_token: None,\n            char_source,\n        };\n\n        created\n    }\n\n    pub fn from_file(f: std::fs::File) -\u003e Self {\n        Self::from_char_source(CharSource::from_file(f))\n    }\n\n    pub fn from_string(s: \u0026'a str) -\u003e Self {\n        Self::from_char_source(CharSource::from_str(s))\n    }\n\n    pub fn peek(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        if self.current_token.is_none() {\n            self.current_token = Some(self.lex()?);\n        }\n\n        let peeked = self\n            .current_token\n            .clone()\n            .unwrap_or((Token::Eof, SourceLoc::new(self.cur_line, self.cur_col)));\n\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::peek() -\u003e {:?}\", peeked);\n\n        Ok(peeked)\n    }\n\n    // returns the position to which the input has been read\n    pub fn current_loc(\u0026self) -\u003e SourceLoc {\n        SourceLoc::new(self.cur_line, self.cur_col)\n    }\n\n    pub fn next(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        let next_token = self.lex()?;\n        Ok(self\n            .current_token\n            .replace(next_token)\n            .unwrap_or((Token::Eof, SourceLoc::new(self.cur_line, self.cur_col))))\n    }\n\n    pub fn lex_all(\u0026mut self) -\u003e Result\u003cVec\u003c(Token, SourceLoc)\u003e, LexError\u003e {\n        println!(\"Lexer::lex_all()\");\n        let mut tokens: Vec\u003c(Token, SourceLoc)\u003e = Vec::new();\n        if self.current_token.is_none() {\n            tokens.push(self.lex()?);\n        }\n\n        loop {\n            let next_token = self.next()?;\n            println!(\"next_token: {:?}\", next_token);\n            match next_token.0 {\n                Token::Eof =\u003e {\n                    tokens.push(next_token);\n                    break;\n                }\n                _ =\u003e {\n                    tokens.push(next_token);\n                }\n            }\n        }\n\n        println!(\"Lexer::lex_all(): {:?}\", tokens);\n\n        Ok(tokens)\n    }\n}\n\n// private methods\nimpl\u003c'a\u003e Lexer\u003c'a\u003e {\n    fn peek_char(\u0026self) -\u003e Option\u003cchar\u003e {\n        // #[cfg(feature = \"loud_lexing\")]\n        // println!(\"Lexer::peek_char: {:?}\", self.current_char);\n\n        self.current_char\n    }\n\n    fn advance_char(\u0026mut self) {\n        // #[cfg(feature = \"loud_lexing\")]\n        // println!(\"Lexer::advance_char: {:?}\", self.current_char);\n        if let Some(consumed) = self.current_char {\n            if consumed == '\\n' {\n                self.cur_line += 1;\n                self.cur_col = 1;\n            } else {\n                self.cur_col += 1;\n            }\n        }\n        self.current_char = self.char_source.next();\n    }\n\n    fn match_kw_or_ident(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::match_kw_or_ident\");\n\n        let mut identifier = String::new();\n\n        if let Some(first_char) = self.peek_char() {\n            if first_char.is_alphabetic() || first_char == '_' {\n                identifier.push(first_char);\n                self.advance_char();\n                while let Some(c) = self.peek_char() {\n                    if c.is_alphanumeric() || c == '_' {\n                        identifier.push(c);\n                        self.advance_char();\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        let matched = match identifier.as_str() {\n            \"u8\" =\u003e Some(Token::U8),\n            \"u16\" =\u003e Some(Token::U16),\n            \"u32\" =\u003e Some(Token::U32),\n            \"u64\" =\u003e Some(Token::U64),\n            \"i8\" =\u003e Some(Token::I8),\n            \"i16\" =\u003e Some(Token::I16),\n            \"i32\" =\u003e Some(Token::I32),\n            \"i64\" =\u003e Some(Token::I64),\n            \"fun\" =\u003e Some(Token::Fun),\n            \"if\" =\u003e Some(Token::If),\n            \"else\" =\u003e Some(Token::Else),\n            \"while\" =\u003e Some(Token::While),\n            \"pub\" =\u003e Some(Token::Pub),\n            \"struct\" =\u003e Some(Token::Struct),\n            \"impl\" =\u003e Some(Token::Impl),\n            \"Self\" =\u003e Some(Token::SelfUpper),\n            \"self\" =\u003e Some(Token::SelfLower),\n            \"mut\" =\u003e Some(Token::Mut),\n            _ =\u003e {\n                if identifier.len() \u003e 0 {\n                    Some(Token::Identifier(identifier))\n                } else {\n                    None\n                }\n            }\n        };\n\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::match_kw_or_ident: matched {:?}\", matched);\n\n        matched\n    }\n\n    fn match_next_char_for_token_or(\n        \u0026mut self,\n        expected: char,\n        tok_true: Token,\n        tok_false: Token,\n    ) -\u003e Token {\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\n            \"Lexer::match_next_char_for_token_or: expected: {}, true: {}, false: {}\",\n            expected, tok_true, tok_false\n        );\n\n        match self.peek_char() {\n            None =\u003e tok_false,\n            Some(peeked_char) =\u003e {\n                if peeked_char == expected {\n                    self.advance_char();\n                    tok_true\n                } else {\n                    tok_false\n                }\n            }\n        }\n    }\n\n    fn trim_whitespace(\u0026mut self) {\n        while self.peek_char().is_some() \u0026\u0026 self.peek_char().unwrap().is_whitespace() {\n            self.advance_char();\n        }\n    }\n\n    fn lex(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        #[cfg(feature = \"loud_lexing\")]\n        println!(\"Lexer::lex()\");\n\n        self.trim_whitespace();\n        let match_start = SourceLoc::new(self.cur_line, self.cur_col);\n\n        let token = if let Some(peeked_char) = self.peek_char() {\n            match peeked_char {\n                '{' =\u003e {\n                    self.advance_char();\n                    Ok(Token::LCurly)\n                }\n                '}' =\u003e {\n                    self.advance_char();\n                    Ok(Token::RCurly)\n                }\n                '(' =\u003e {\n                    self.advance_char();\n                    Ok(Token::LParen)\n                }\n                ')' =\u003e {\n                    self.advance_char();\n                    Ok(Token::RParen)\n                }\n                '+' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Plus)\n                }\n                '-' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('\u003e', Token::Arrow, Token::Minus))\n                }\n                '*' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Star)\n                }\n                '/' =\u003e {\n                    self.advance_char();\n                    Ok(Token::FSlash)\n                }\n                '\u003e' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('=', Token::GThanE, Token::GThan))\n                }\n                '\u003c' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('=', Token::LThanE, Token::LThan))\n                }\n                '!' =\u003e {\n                    self.advance_char();\n                    match self.peek_char() {\n                        None =\u003e Err(LexError::unexpected_eof(self.current_loc())),\n                        Some(character) =\u003e {\n                            if character == '=' {\n                                self.advance_char();\n                                Ok(Token::NotEquals)\n                            } else {\n                                Err(LexError::invalid_char(character, self.current_loc()))\n                            }\n                        }\n                    }\n                }\n                '=' =\u003e {\n                    self.advance_char();\n                    Ok(self.match_next_char_for_token_or('=', Token::Equals, Token::Assign))\n                }\n                ',' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Comma)\n                }\n                '.' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Dot)\n                }\n                ';' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Semicolon)\n                }\n                ':' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Colon)\n                }\n                '\u0026' =\u003e {\n                    self.advance_char();\n                    Ok(Token::Reference)\n                }\n                '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' =\u003e {\n                    let mut constant_string = String::new();\n                    while self.peek_char().is_some() {\n                        let char: char = self.peek_char().unwrap();\n                        if char.is_numeric() {\n                            self.advance_char();\n                            constant_string.push(char);\n                        } else {\n                            break;\n                        }\n                    }\n                    Ok(Token::UnsignedDecimalConstant(\n                        usize::from_str_radix(\u0026constant_string, 10)\n                            .expect(\"Couldn't convert unsigned decimal constant\"),\n                    ))\n                }\n                _ =\u003e match self.match_kw_or_ident() {\n                    Some(token) =\u003e Ok(token),\n                    None =\u003e Err(LexError::invalid_char(\n                        self.peek_char().unwrap(),\n                        self.current_loc(),\n                    )),\n                },\n            }\n        } else {\n            Ok(Token::Eof)\n        };\n\n        self.trim_whitespace();\n\n        match token {\n            Ok(tok) =\u003e {\n                #[cfg(feature = \"loud_lexing\")]\n                println!(\"Lexer::lex(): lexed '{}'@{}\", tok.name(), match_start);\n                Ok((tok, match_start))\n            }\n            Err(e) =\u003e {\n                #[cfg(feature = \"loud_lexing\")]\n                println!(\"Lexer::lex(): lexing error {}\", e);\n                Err(e)\n            }\n        }\n    }\n}\n","traces":[{"line":28,"address":[362700,362416],"length":1,"stats":{"Line":15}},{"line":29,"address":[362510,362458],"length":1,"stats":{"Line":32}},{"line":31,"address":[362514],"length":1,"stats":{"Line":17}},{"line":32,"address":[362446],"length":1,"stats":{"Line":15}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[362736],"length":1,"stats":{"Line":0}},{"line":46,"address":[362753],"length":1,"stats":{"Line":0}},{"line":49,"address":[362800],"length":1,"stats":{"Line":8}},{"line":50,"address":[362830],"length":1,"stats":{"Line":8}},{"line":53,"address":[363551,362880],"length":1,"stats":{"Line":4}},{"line":54,"address":[362918,363334],"length":1,"stats":{"Line":5}},{"line":55,"address":[363031],"length":1,"stats":{"Line":4}},{"line":58,"address":[362944,363434],"length":1,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[362984,363473,363581,363347],"length":1,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[363520],"length":1,"stats":{"Line":1}},{"line":70,"address":[363600],"length":1,"stats":{"Line":3}},{"line":71,"address":[363608],"length":1,"stats":{"Line":3}},{"line":74,"address":[364338,363632,364311],"length":1,"stats":{"Line":3}},{"line":75,"address":[363825,363662],"length":1,"stats":{"Line":7}},{"line":76,"address":[364183,363978,364272,363911],"length":1,"stats":{"Line":16}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[364031,363915],"length":1,"stats":{"Line":8}},{"line":79,"address":[364222,364328,364049],"length":1,"stats":{"Line":4}},{"line":82,"address":[365575,365544,364368],"length":1,"stats":{"Line":4}},{"line":83,"address":[364397],"length":1,"stats":{"Line":4}},{"line":84,"address":[364446],"length":1,"stats":{"Line":4}},{"line":85,"address":[364512,364456],"length":1,"stats":{"Line":8}},{"line":86,"address":[365573,364554],"length":1,"stats":{"Line":4}},{"line":89,"address":[365521],"length":1,"stats":{"Line":0}},{"line":90,"address":[364766,364531],"length":1,"stats":{"Line":7}},{"line":91,"address":[365039,364991],"length":1,"stats":{"Line":8}},{"line":92,"address":[365108],"length":1,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[365148],"length":1,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[365231],"length":1,"stats":{"Line":0}},{"line":103,"address":[365338],"length":1,"stats":{"Line":4}},{"line":105,"address":[365418],"length":1,"stats":{"Line":4}},{"line":111,"address":[365600],"length":1,"stats":{"Line":1}},{"line":115,"address":[365605],"length":1,"stats":{"Line":1}},{"line":118,"address":[365616],"length":1,"stats":{"Line":1}},{"line":121,"address":[365630],"length":1,"stats":{"Line":1}},{"line":122,"address":[365674,365792,365826],"length":1,"stats":{"Line":5}},{"line":123,"address":[365774,365794,365714],"length":1,"stats":{"Line":2}},{"line":124,"address":[365781],"length":1,"stats":{"Line":1}},{"line":126,"address":[365831,365819,365742],"length":1,"stats":{"Line":4}},{"line":129,"address":[365686],"length":1,"stats":{"Line":2}},{"line":132,"address":[368609,365856],"length":1,"stats":{"Line":11}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[365886],"length":1,"stats":{"Line":11}},{"line":138,"address":[365973,365917],"length":1,"stats":{"Line":25}},{"line":139,"address":[366068,366028],"length":1,"stats":{"Line":29}},{"line":140,"address":[366092],"length":1,"stats":{"Line":15}},{"line":141,"address":[366104],"length":1,"stats":{"Line":15}},{"line":142,"address":[366118],"length":1,"stats":{"Line":15}},{"line":143,"address":[366192],"length":1,"stats":{"Line":15}},{"line":144,"address":[366235],"length":1,"stats":{"Line":15}},{"line":145,"address":[366247],"length":1,"stats":{"Line":15}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[366044,366269],"length":1,"stats":{"Line":30}},{"line":154,"address":[366351,366285],"length":1,"stats":{"Line":16}},{"line":155,"address":[366426,366465,366328],"length":1,"stats":{"Line":29}},{"line":156,"address":[366579,366540,366442],"length":1,"stats":{"Line":29}},{"line":157,"address":[366654,366556,366693],"length":1,"stats":{"Line":31}},{"line":158,"address":[366768,366807,366670],"length":1,"stats":{"Line":32}},{"line":159,"address":[366921,366882,366784],"length":1,"stats":{"Line":32}},{"line":160,"address":[366898,366996,367035],"length":1,"stats":{"Line":32}},{"line":161,"address":[367149,367110,367012],"length":1,"stats":{"Line":32}},{"line":162,"address":[367263,367126,367224],"length":1,"stats":{"Line":38}},{"line":163,"address":[367240,367377,367338],"length":1,"stats":{"Line":38}},{"line":164,"address":[367491,367354,367452],"length":1,"stats":{"Line":38}},{"line":165,"address":[367468,367605,367566],"length":1,"stats":{"Line":38}},{"line":166,"address":[367582,367680,367719],"length":1,"stats":{"Line":38}},{"line":167,"address":[367833,367696,367794],"length":1,"stats":{"Line":39}},{"line":168,"address":[367908,367947,367810],"length":1,"stats":{"Line":36}},{"line":169,"address":[368061,368022,367924],"length":1,"stats":{"Line":35}},{"line":170,"address":[368175,368136,368038],"length":1,"stats":{"Line":34}},{"line":171,"address":[368250,368152,368272],"length":1,"stats":{"Line":36}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[368261,368347,368371],"length":1,"stats":{"Line":51}},{"line":174,"address":[368376],"length":1,"stats":{"Line":18}},{"line":176,"address":[368353],"length":1,"stats":{"Line":15}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[368530],"length":1,"stats":{"Line":1}},{"line":187,"address":[369004,368640],"length":1,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[368689,368754],"length":1,"stats":{"Line":2}},{"line":200,"address":[368812],"length":1,"stats":{"Line":1}},{"line":201,"address":[368789],"length":1,"stats":{"Line":1}},{"line":202,"address":[368884,368797,368935],"length":1,"stats":{"Line":2}},{"line":203,"address":[368891],"length":1,"stats":{"Line":1}},{"line":204,"address":[368908],"length":1,"stats":{"Line":1}},{"line":206,"address":[368857],"length":1,"stats":{"Line":0}},{"line":212,"address":[369040],"length":1,"stats":{"Line":4}},{"line":213,"address":[369089,369057],"length":1,"stats":{"Line":10}},{"line":214,"address":[369125],"length":1,"stats":{"Line":2}},{"line":218,"address":[369136,372015],"length":1,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[369174],"length":1,"stats":{"Line":4}},{"line":223,"address":[369184],"length":1,"stats":{"Line":5}},{"line":225,"address":[369237,369407],"length":1,"stats":{"Line":5}},{"line":226,"address":[369293],"length":1,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[369481],"length":1,"stats":{"Line":1}},{"line":229,"address":[369486],"length":1,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[369574],"length":1,"stats":{"Line":1}},{"line":233,"address":[369579],"length":1,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[369667],"length":1,"stats":{"Line":1}},{"line":237,"address":[369672],"length":1,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[369760],"length":1,"stats":{"Line":1}},{"line":241,"address":[369765],"length":1,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[369853],"length":1,"stats":{"Line":1}},{"line":245,"address":[369858],"length":1,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[369946],"length":1,"stats":{"Line":1}},{"line":249,"address":[369956],"length":1,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[370096],"length":1,"stats":{"Line":1}},{"line":253,"address":[370101],"length":1,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[370189],"length":1,"stats":{"Line":1}},{"line":257,"address":[370194],"length":1,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[370282],"length":1,"stats":{"Line":1}},{"line":261,"address":[370292],"length":1,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[370432],"length":1,"stats":{"Line":1}},{"line":265,"address":[370442],"length":1,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[370582],"length":1,"stats":{"Line":1}},{"line":269,"address":[370592],"length":1,"stats":{"Line":1}},{"line":270,"address":[371318],"length":1,"stats":{"Line":0}},{"line":271,"address":[371285],"length":1,"stats":{"Line":1}},{"line":272,"address":[371303,371492,371597],"length":1,"stats":{"Line":2}},{"line":273,"address":[371409],"length":1,"stats":{"Line":1}},{"line":274,"address":[371414],"length":1,"stats":{"Line":1}},{"line":276,"address":[371502],"length":1,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[370648],"length":1,"stats":{"Line":1}},{"line":283,"address":[370658],"length":1,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[370798],"length":1,"stats":{"Line":1}},{"line":287,"address":[370803],"length":1,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[370891],"length":1,"stats":{"Line":0}},{"line":291,"address":[370896],"length":1,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[370984],"length":1,"stats":{"Line":1}},{"line":295,"address":[370989],"length":1,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[371077],"length":1,"stats":{"Line":1}},{"line":299,"address":[371082],"length":1,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[371167],"length":1,"stats":{"Line":0}},{"line":303,"address":[371172],"length":1,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[371252],"length":1,"stats":{"Line":1}},{"line":307,"address":[371607,371666],"length":1,"stats":{"Line":2}},{"line":308,"address":[371732],"length":1,"stats":{"Line":1}},{"line":309,"address":[371776],"length":1,"stats":{"Line":1}},{"line":310,"address":[371802],"length":1,"stats":{"Line":1}},{"line":311,"address":[372003],"length":1,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[371886],"length":1,"stats":{"Line":1}},{"line":317,"address":[371835,371710],"length":1,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[369417],"length":1,"stats":{"Line":2}},{"line":322,"address":[372037],"length":1,"stats":{"Line":1}},{"line":323,"address":[372205],"length":1,"stats":{"Line":0}},{"line":324,"address":[372155],"length":1,"stats":{"Line":0}},{"line":325,"address":[372183],"length":1,"stats":{"Line":0}},{"line":330,"address":[369329],"length":1,"stats":{"Line":3}},{"line":333,"address":[371275],"length":1,"stats":{"Line":3}},{"line":335,"address":[372323],"length":1,"stats":{"Line":3}},{"line":336,"address":[372462],"length":1,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[372510],"length":1,"stats":{"Line":3}},{"line":341,"address":[372342],"length":1,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[372390],"length":1,"stats":{"Line":0}}],"covered":136,"coverable":189},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","declarations.rs"],"content":"use crate::frontend::{ast::*, lexer::token::Token};\n\nuse super::{ParseError, Parser};\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    // TODO: pass loc of string to get true start loc of declaration\n    pub fn parse_variable_declaration(\u0026mut self) -\u003e Result\u003cVariableDeclarationTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"variable declaration\")?;\n\n        let declaration = VariableDeclarationTree {\n            loc: start_loc,\n            name: self.parse_identifier()?,\n            typename: {\n                self.expect_token(Token::Colon)?;\n                self.parse_typename()?\n            },\n        };\n\n        self.finish_parsing(\u0026declaration)?;\n\n        Ok(declaration)\n    }\n\n    pub fn parse_function_declaration_or_definition(\n        \u0026mut self,\n    ) -\u003e Result\u003cTranslationUnit, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"function declaration/definition\")?;\n\n        let prototype = self.parse_function_prototype()?;\n\n        let decl_or_def = match self.parse_function_definition(prototype.clone()) {\n            Ok(definition) =\u003e Ok(TranslationUnit::FunctionDefinition(definition)),\n            Err(_) =\u003e Ok(TranslationUnit::FunctionDeclaration(prototype)),\n        };\n\n        self.finish_parsing(decl_or_def.as_ref().unwrap())?;\n\n        decl_or_def\n    }\n\n    pub fn parse_function_definition(\n        \u0026mut self,\n        prototype: FunctionDeclarationTree,\n    ) -\u003e Result\u003cFunctionDefinitionTree, ParseError\u003e {\n        self.start_parsing(\"function definition\")?;\n\n        let parsed_definition = FunctionDefinitionTree {\n            prototype,\n            body: self.parse_block_expression()?,\n        };\n\n        self.finish_parsing(\u0026parsed_definition)?;\n\n        Ok(parsed_definition)\n    }\n\n    pub fn parse_struct_definition(\u0026mut self) -\u003e Result\u003cTranslationUnit, ParseError\u003e {\n        let start_loc = self.start_parsing(\"struct definition\")?;\n\n        self.expect_token(Token::Struct)?;\n        let struct_name = self.parse_identifier()?;\n        self.expect_token(Token::LCurly)?;\n\n        let mut struct_fields = Vec::new();\n\n        loop {\n            match self.peek_token()? {\n                Token::Identifier(_) =\u003e {\n                    struct_fields.push(self.parse_variable_declaration()?);\n\n                    if matches!(self.peek_token()?, Token::Comma) {\n                        self.next_token()?;\n                    }\n                }\n                Token::RCurly =\u003e {\n                    self.next_token()?;\n                    break;\n                }\n                _ =\u003e {\n                    self.unexpected_token::\u003cTranslationUnit\u003e(\u0026[Token::Identifier(\"\".into())])?;\n                }\n            }\n        }\n\n        let struct_definition = TranslationUnit::StructDefinition(StructDefinitionTree {\n            loc: start_loc,\n            name: struct_name,\n            fields: struct_fields,\n        });\n\n        self.finish_parsing(\u0026struct_definition)?;\n\n        Ok(struct_definition)\n    }\n\n    pub fn parse_implementation(\u0026mut self) -\u003e Result\u003cTranslationUnit, ParseError\u003e {\n        let start_loc = self.start_parsing(\"impl block\")?;\n\n        self.expect_token(Token::Impl)?;\n        let implemented_for = self.parse_typename()?;\n        self.expect_token(Token::LCurly);\n\n        let mut items: Vec\u003cFunctionDefinitionTree\u003e = Vec::new();\n\n        while self.peek_token()? != Token::RCurly {\n            let prototype = self.parse_function_prototype()?;\n            items.push(self.parse_function_definition(prototype)?);\n        }\n\n        let implementation = TranslationUnit::Implementation(ImplementationTree {\n            loc: start_loc,\n            type_name: implemented_for,\n            items,\n        });\n\n        self.finish_parsing(\u0026implementation);\n        Ok(implementation)\n    }\n}\n","traces":[{"line":7,"address":[581248,582581],"length":1,"stats":{"Line":0}},{"line":8,"address":[581278],"length":1,"stats":{"Line":0}},{"line":12,"address":[581443],"length":1,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[582306,582369],"length":1,"stats":{"Line":0}},{"line":21,"address":[582504],"length":1,"stats":{"Line":0}},{"line":24,"address":[584002,582688],"length":1,"stats":{"Line":0}},{"line":27,"address":[582718],"length":1,"stats":{"Line":0}},{"line":29,"address":[582881],"length":1,"stats":{"Line":0}},{"line":31,"address":[583329,583260],"length":1,"stats":{"Line":0}},{"line":32,"address":[583483],"length":1,"stats":{"Line":0}},{"line":33,"address":[583373],"length":1,"stats":{"Line":0}},{"line":36,"address":[583688,583621],"length":1,"stats":{"Line":0}},{"line":38,"address":[583886],"length":1,"stats":{"Line":0}},{"line":41,"address":[585224,585147,584048],"length":1,"stats":{"Line":0}},{"line":45,"address":[585211,584173,584082],"length":1,"stats":{"Line":0}},{"line":49,"address":[584430,584493],"length":1,"stats":{"Line":0}},{"line":52,"address":[584860,584923],"length":1,"stats":{"Line":0}},{"line":54,"address":[585058],"length":1,"stats":{"Line":0}},{"line":57,"address":[587509,588872,585248],"length":1,"stats":{"Line":0}},{"line":58,"address":[585278],"length":1,"stats":{"Line":0}},{"line":60,"address":[585465],"length":1,"stats":{"Line":0}},{"line":61,"address":[585732],"length":1,"stats":{"Line":0}},{"line":62,"address":[588841,586034,585946],"length":1,"stats":{"Line":0}},{"line":64,"address":[586259],"length":1,"stats":{"Line":0}},{"line":66,"address":[586266],"length":1,"stats":{"Line":0}},{"line":67,"address":[586287,588781,586351],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[588365,586628,587551],"length":1,"stats":{"Line":0}},{"line":71,"address":[587812,588360],"length":1,"stats":{"Line":0}},{"line":72,"address":[588100,588355],"length":1,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[587518,586694,586608],"length":1,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[586561,588375],"length":1,"stats":{"Line":0}},{"line":85,"address":[587021],"length":1,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[586941],"length":1,"stats":{"Line":0}},{"line":88,"address":[586981],"length":1,"stats":{"Line":0}},{"line":91,"address":[587262,587199],"length":1,"stats":{"Line":0}},{"line":93,"address":[587397],"length":1,"stats":{"Line":0}},{"line":96,"address":[591474,588912,590545],"length":1,"stats":{"Line":0}},{"line":97,"address":[588942],"length":1,"stats":{"Line":0}},{"line":99,"address":[589131],"length":1,"stats":{"Line":0}},{"line":100,"address":[589398],"length":1,"stats":{"Line":0}},{"line":101,"address":[589724,589644],"length":1,"stats":{"Line":0}},{"line":103,"address":[589739],"length":1,"stats":{"Line":0}},{"line":105,"address":[589746,591420,589828,591368],"length":1,"stats":{"Line":0}},{"line":106,"address":[591403,590567],"length":1,"stats":{"Line":0}},{"line":107,"address":[590965,591165,591373],"length":1,"stats":{"Line":0}},{"line":110,"address":[590195],"length":1,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[590099],"length":1,"stats":{"Line":0}},{"line":113,"address":[590155],"length":1,"stats":{"Line":0}},{"line":116,"address":[590460,590405],"length":1,"stats":{"Line":0}},{"line":117,"address":[590467],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","errors.rs"],"content":"use crate::frontend::{\n    lexer::{token::Token, LexError},\n    sourceloc::SourceLoc,\n};\n\n#[derive(Clone, PartialEq, Eq)]\npub enum ParseError {\n    LexError(LexError),\n    UnexpectedToken(UnexpectedTokenError),\n}\n\nimpl std::fmt::Display for ParseError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::LexError(lex_error) =\u003e write!(f, \"{}\", lex_error),\n            Self::UnexpectedToken(unexpected_token) =\u003e {\n                let mut expected_tokens = String::new();\n                for tok in \u0026unexpected_token.expected {\n                    if expected_tokens.len() \u003e 0 {\n                        expected_tokens += \", \";\n                    }\n\n                    expected_tokens += \u0026format!(\"'{}'\", tok.name());\n                }\n                write!(\n                    f,\n                    \"Unexpected token '{}' at {}, expected one of [{}]\",\n                    unexpected_token.got, unexpected_token.loc, expected_tokens\n                )\n            }\n        }\n    }\n}\n\nimpl std::fmt::Debug for ParseError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct UnexpectedTokenError {\n    pub loc: SourceLoc,\n    pub got: Token,\n    pub expected: Vec\u003cToken\u003e,\n}\n\nimpl ParseError {\n    pub fn unexpected_token(loc: SourceLoc, got: Token, expected: \u0026[Token]) -\u003e Self {\n        Self::UnexpectedToken(UnexpectedTokenError {\n            loc,\n            got,\n            expected: expected.to_vec(),\n        })\n    }\n}\n\nimpl From\u003cLexError\u003e for ParseError {\n    fn from(value: LexError) -\u003e Self {\n        Self::LexError(value)\n    }\n}\n","traces":[{"line":13,"address":[877472,878418],"length":1,"stats":{"Line":0}},{"line":14,"address":[877505],"length":1,"stats":{"Line":0}},{"line":15,"address":[877593],"length":1,"stats":{"Line":0}},{"line":16,"address":[877542],"length":1,"stats":{"Line":0}},{"line":17,"address":[877558],"length":1,"stats":{"Line":0}},{"line":18,"address":[877767,877568],"length":1,"stats":{"Line":0}},{"line":19,"address":[878098,877876],"length":1,"stats":{"Line":0}},{"line":20,"address":[878126],"length":1,"stats":{"Line":0}},{"line":23,"address":[878165,878109],"length":1,"stats":{"Line":0}},{"line":25,"address":[877896],"length":1,"stats":{"Line":0}},{"line":36,"address":[878448],"length":1,"stats":{"Line":0}},{"line":37,"address":[878466],"length":1,"stats":{"Line":0}},{"line":49,"address":[878848,878560],"length":1,"stats":{"Line":1}},{"line":50,"address":[878738],"length":1,"stats":{"Line":3}},{"line":52,"address":[878651],"length":1,"stats":{"Line":1}},{"line":53,"address":[878679],"length":1,"stats":{"Line":2}},{"line":59,"address":[878880],"length":1,"stats":{"Line":0}},{"line":60,"address":[878883],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","expressions.rs"],"content":"use crate::{\n    frontend::{ast::*, lexer::token::Token},\n    midend::ir,\n};\n\nuse super::{ParseError, Parser};\n\n// parsing functions which yield an ExpressionTree\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn parse_block_expression(\u0026mut self) -\u003e Result\u003cCompoundExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"compound statement\")?;\n\n        self.expect_token(Token::LCurly)?;\n        let mut statements: Vec\u003cStatementTree\u003e = Vec::new();\n        loop {\n            match self.peek_token()? {\n                Token::RCurly =\u003e break,\n                _ =\u003e statements.push(self.parse_statement()?),\n            }\n        }\n        self.expect_token(Token::RCurly)?;\n\n        let compound_statement = CompoundExpressionTree {\n            loc: start_loc,\n            statements: statements,\n        };\n\n        self.finish_parsing(\u0026compound_statement)?;\n\n        Ok(compound_statement)\n    }\n\n    pub fn expression_starters() -\u003e [Token; 5] {\n        [\n            Token::If,\n            Token::While,\n            Token::Identifier(\"\".into()),\n            Token::UnsignedDecimalConstant(0),\n            Token::LParen,\n        ]\n    }\n\n    pub fn token_starts_expression(t: Token) -\u003e bool {\n        match t {\n            Token::If\n            | Token::While\n            | Token::Identifier(_)\n            | Token::UnsignedDecimalConstant(0)\n            | Token::LParen =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn parse_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"expression\")?;\n\n        assert!(Self::token_starts_expression(self.peek_token()?)); // sanity-check this method call to self-validate\n\n        let mut expr = match self.peek_token()? {\n            Token::If =\u003e self.parse_if_expression()?,\n            Token::While =\u003e self.parse_while_expression()?,\n            Token::Identifier(_) =\u003e self.parse_identifier_expression()?,\n            Token::UnsignedDecimalConstant(_) =\u003e self.parse_literal_expression()?,\n            Token::LParen =\u003e self.parse_parenthesized_expression()?,\n            _ =\u003e self.unexpected_token(\u0026[\n                Token::If,\n                Token::While,\n                Token::Identifier(\"\".into()),\n                Token::UnsignedDecimalConstant(0),\n                Token::LParen,\n            ])?,\n        };\n\n        match self.peek_token()? {\n            Token::Dot =\u003e {\n                if matches!(self.lookahead_token(2)?, Token::LParen) {\n                    expr = self.parse_method_call_expression(expr)?;\n                } else {\n                    expr = self.parse_field_expression(expr)?;\n                }\n            }\n            _ =\u003e {}\n        }\n\n        let peeked = self.peek_token()?;\n        match peeked {\n            Token::Plus\n            | Token::Minus\n            | Token::Star\n            | Token::FSlash\n            | Token::LThan\n            | Token::GThan\n            | Token::LThanE\n            | Token::GThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e {\n                let lhs = expr;\n                expr = self.parse_binary_expression_min_precedence(lhs, 0)?\n            }\n\n            _ =\u003e {\n                #[cfg(feature = \"loud_parsing\")]\n                println!(\"Peeked {} after lhs {} of expression\", peeked, expr);\n            }\n        }\n\n        match self.peek_token()? {\n            Token::Assign =\u003e {\n                expr = self.parse_assignment_expression(expr)?;\n            }\n            _ =\u003e {}\n        }\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_parenthesized_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"parenthesized expression\")?;\n\n        self.expect_token(Token::LParen)?;\n        let parenthesized_expr = self.parse_expression()?;\n        self.expect_token(Token::RParen)?;\n\n        self.finish_parsing(\u0026parenthesized_expr)?;\n        Ok(parenthesized_expr)\n    }\n\n    pub fn parse_if_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"if statement\")?;\n\n        self.expect_token(Token::If)?;\n\n        self.expect_token(Token::LParen)?;\n        let condition: ExpressionTree = self.parse_expression()?;\n        self.expect_token(Token::RParen)?;\n\n        let true_block = self.parse_block_expression()?;\n        let false_block = match self.peek_token()? {\n            Token::Else =\u003e {\n                self.next_token()?;\n                Some(self.parse_block_expression()?)\n            }\n            _ =\u003e None,\n        };\n\n        let if_expression = ExpressionTree {\n            loc: start_loc,\n            expression: Expression::If(Box::new(IfExpressionTree {\n                loc: start_loc,\n                condition,\n                true_block,\n                false_block,\n            })),\n        };\n\n        self.finish_parsing(\u0026if_expression)?;\n\n        Ok(if_expression)\n    }\n\n    pub fn parse_while_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"while loop\")?;\n\n        self.expect_token(Token::While)?;\n\n        self.expect_token(Token::LParen)?;\n        let condition = self.parse_expression()?;\n        self.expect_token(Token::RParen)?;\n\n        let body = self.parse_block_expression()?;\n\n        let while_loop = WhileExpressionTree {\n            loc: start_loc,\n            condition,\n            body,\n        };\n\n        self.finish_parsing(\u0026while_loop)?;\n\n        Ok(ExpressionTree {\n            loc: start_loc,\n            expression: Expression::While(Box::from(while_loop)),\n        })\n    }\n\n    pub fn parse_method_call_expression(\n        \u0026mut self,\n        lhs: ExpressionTree,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\"method call expression\")?;\n        self.expect_token(Token::Dot)?;\n\n        let expr = ExpressionTree {\n            loc: lhs.loc,\n            expression: Expression::MethodCall(Box::from(MethodCallExpressionTree {\n                loc: lhs.loc,\n                receiver: lhs,\n                called_method: self.parse_identifier()?,\n                params: self.parse_call_params(true)?,\n            })),\n        };\n\n        self.finish_parsing(\u0026expr)?;\n        Ok(expr)\n    }\n\n    pub fn parse_field_expression(\n        \u0026mut self,\n        lhs: ExpressionTree,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\"field expression\")?;\n\n        self.expect_token(Token::Dot)?;\n        let expr = ExpressionTree {\n            loc: lhs.loc,\n            expression: Expression::FieldExpression(Box::from(FieldExpressionTree {\n                loc: lhs.loc,\n                receiver: lhs,\n                field: self.parse_identifier()?,\n            })),\n        };\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_call_params(\u0026mut self, allow_self: bool) -\u003e Result\u003cCallParamsTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"call params\")?;\n\n        let mut params = Vec::new();\n\n        self.expect_token(Token::LParen)?;\n        while !matches!(self.peek_token()?, Token::RParen) {\n            if Self::token_starts_expression(self.peek_token()?) {\n                params.push(self.parse_expression()?);\n            } else {\n                self.unexpected_token(\u0026Self::expression_starters())?;\n            }\n        }\n        self.expect_token(Token::RParen)?;\n\n        let params_tree = CallParamsTree {\n            loc: start_loc,\n            params,\n        };\n\n        self.finish_parsing(\u0026params_tree)?;\n\n        Ok(params_tree)\n    }\n\n    pub fn parse_assignment_expression(\n        \u0026mut self,\n        lhs: ExpressionTree,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\"assignment (rhs)\")?;\n\n        self.expect_token(Token::Assign)?;\n\n        let rhs = self.parse_expression()?;\n\n        let assignment = ExpressionTree {\n            loc: lhs.loc.clone(),\n            expression: Expression::Assignment(AssignmentTree {\n                loc: lhs.loc.clone(),\n                assignee: Box::from(lhs),\n                value: Box::from(rhs),\n            }),\n        };\n\n        self.finish_parsing(\u0026assignment)?;\n\n        Ok(assignment)\n    }\n\n    pub fn parse_binary_expression_min_precedence(\n        \u0026mut self,\n        lhs: ExpressionTree,\n        min_precedence: usize,\n    ) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        self.start_parsing(\u0026format!(\"expression (min precedence: {})\", min_precedence))?;\n        let start_loc = lhs.loc;\n\n        let mut expr = lhs;\n        while Self::token_is_operator_of_at_least_precedence(\u0026self.peek_token()?, min_precedence) {\n            let operation = self.next_token()?;\n            let mut rhs = self.parse_primary_expression()?;\n\n            while Self::token_is_operator_of_at_least_precedence(\n                \u0026self.peek_token()?,\n                ir::BinaryOperations::precedence_of_token(\u0026operation),\n            ) {\n                rhs = self.parse_binary_expression_min_precedence(\n                    rhs,\n                    ir::BinaryOperations::precedence_of_token(\u0026operation),\n                )?;\n            }\n\n            let operands = ArithmeticDualOperands {\n                e1: Box::new(expr),\n                e2: Box::new(rhs),\n            };\n            expr = ExpressionTree {\n                loc: start_loc,\n                expression: match operation {\n                    Token::Plus =\u003e Expression::Arithmetic(ArithmeticExpressionTree::Add(operands)),\n                    Token::Minus =\u003e {\n                        Expression::Arithmetic(ArithmeticExpressionTree::Subtract(operands))\n                    }\n                    Token::Star =\u003e {\n                        Expression::Arithmetic(ArithmeticExpressionTree::Multiply(operands))\n                    }\n                    Token::FSlash =\u003e {\n                        Expression::Arithmetic(ArithmeticExpressionTree::Divide(operands))\n                    }\n                    Token::LThan =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::LThan(operands))\n                    }\n                    Token::GThan =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::GThan(operands))\n                    }\n                    Token::LThanE =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::LThanE(operands))\n                    }\n                    Token::GThanE =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::GThanE(operands))\n                    }\n                    Token::Equals =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::Equals(operands))\n                    }\n                    Token::NotEquals =\u003e {\n                        Expression::Comparison(ComparisonExpressionTree::NotEquals(operands))\n                    }\n                    _ =\u003e self.unexpected_token(\u0026[\n                        Token::Plus,\n                        Token::Minus,\n                        Token::Star,\n                        Token::FSlash,\n                        Token::LThan,\n                        Token::GThan,\n                        Token::LThanE,\n                        Token::GThanE,\n                        Token::Equals,\n                        Token::NotEquals,\n                    ])?,\n                },\n            };\n        }\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_primary_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"primary expression\")?;\n\n        let primary_expression = ExpressionTree {\n            loc: start_loc,\n            expression: {\n                match self.peek_token()? {\n                    Token::Identifier(value) =\u003e {\n                        self.next_token()?;\n                        Expression::Identifier(value)\n                    }\n                    Token::UnsignedDecimalConstant(value) =\u003e {\n                        self.next_token()?;\n                        Expression::UnsignedDecimalConstant(value)\n                    }\n                    Token::LParen =\u003e {\n                        self.next_token()?;\n                        let expr = self.parse_expression()?;\n                        self.expect_token(Token::RParen)?;\n                        expr.expression\n                    } // TODO: don't duplciate ExpressionTree here\n                    _ =\u003e self.unexpected_token(\u0026[\n                        Token::Identifier(\"\".into()),\n                        Token::UnsignedDecimalConstant(0),\n                        Token::LParen,\n                    ])?,\n                }\n            },\n        };\n\n        self.finish_parsing(\u0026primary_expression)?;\n\n        Ok(primary_expression)\n    }\n\n    pub fn parse_identifier_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"identifier expression\")?;\n\n        let expr = ExpressionTree {\n            loc: start_loc,\n            expression: Expression::Identifier(self.parse_identifier()?),\n        };\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n\n    pub fn parse_literal_expression(\u0026mut self) -\u003e Result\u003cExpressionTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"literal expression\")?;\n\n        let expr = ExpressionTree {\n            loc: start_loc,\n            expression: match self.peek_token()? {\n                Token::UnsignedDecimalConstant(value) =\u003e {\n                    self.next_token()?;\n                    Expression::UnsignedDecimalConstant(value)\n                }\n                _ =\u003e self.unexpected_token(\u0026[Token::UnsignedDecimalConstant(0)])?,\n            },\n        };\n\n        self.finish_parsing(\u0026expr)?;\n\n        Ok(expr)\n    }\n}\n","traces":[{"line":10,"address":[591504,593444,593044],"length":1,"stats":{"Line":0}},{"line":11,"address":[591534],"length":1,"stats":{"Line":0}},{"line":13,"address":[591706],"length":1,"stats":{"Line":0}},{"line":14,"address":[591968],"length":1,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[592002,592066,593411],"length":1,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[592313,593111],"length":1,"stats":{"Line":0}},{"line":21,"address":[593053,592338],"length":1,"stats":{"Line":0}},{"line":28,"address":[592720,592783],"length":1,"stats":{"Line":0}},{"line":30,"address":[592918],"length":1,"stats":{"Line":0}},{"line":33,"address":[593472,593847,593826],"length":1,"stats":{"Line":0}},{"line":35,"address":[593499],"length":1,"stats":{"Line":0}},{"line":36,"address":[593514],"length":1,"stats":{"Line":0}},{"line":37,"address":[593594,593519],"length":1,"stats":{"Line":0}},{"line":38,"address":[593624],"length":1,"stats":{"Line":0}},{"line":39,"address":[593651],"length":1,"stats":{"Line":0}},{"line":43,"address":[593872],"length":1,"stats":{"Line":0}},{"line":44,"address":[593880,593995],"length":1,"stats":{"Line":0}},{"line":45,"address":[593984],"length":1,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[593977],"length":1,"stats":{"Line":0}},{"line":54,"address":[599780,594032,598100],"length":1,"stats":{"Line":0}},{"line":55,"address":[594077],"length":1,"stats":{"Line":0}},{"line":57,"address":[594240],"length":1,"stats":{"Line":0}},{"line":59,"address":[594464],"length":1,"stats":{"Line":0}},{"line":60,"address":[595183,594808,594966],"length":1,"stats":{"Line":0}},{"line":61,"address":[594831,595219],"length":1,"stats":{"Line":0}},{"line":62,"address":[594877,595669],"length":1,"stats":{"Line":0}},{"line":63,"address":[594900,595894],"length":1,"stats":{"Line":0}},{"line":64,"address":[594854,595444],"length":1,"stats":{"Line":0}},{"line":65,"address":[596472,596228,596585],"length":1,"stats":{"Line":0}},{"line":66,"address":[594735],"length":1,"stats":{"Line":0}},{"line":67,"address":[594753],"length":1,"stats":{"Line":0}},{"line":68,"address":[596148,594761],"length":1,"stats":{"Line":0}},{"line":69,"address":[596180],"length":1,"stats":{"Line":0}},{"line":70,"address":[596220],"length":1,"stats":{"Line":0}},{"line":74,"address":[599750,596818],"length":1,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[597159,598076,597078,598066,597726],"length":1,"stats":{"Line":0}},{"line":77,"address":[597731,597416],"length":1,"stats":{"Line":0}},{"line":79,"address":[597756,598071],"length":1,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[599745,598122],"length":1,"stats":{"Line":0}},{"line":86,"address":[598292],"length":1,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[598369],"length":1,"stats":{"Line":0}},{"line":98,"address":[598524,598461,598728],"length":1,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[599740,598354,598764],"length":1,"stats":{"Line":0}},{"line":108,"address":[599356],"length":1,"stats":{"Line":0}},{"line":109,"address":[599157,598988],"length":1,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[599400,599735],"length":1,"stats":{"Line":0}},{"line":116,"address":[599566],"length":1,"stats":{"Line":0}},{"line":119,"address":[601159,599856],"length":1,"stats":{"Line":0}},{"line":120,"address":[599885],"length":1,"stats":{"Line":0}},{"line":122,"address":[600039],"length":1,"stats":{"Line":0}},{"line":123,"address":[600305],"length":1,"stats":{"Line":0}},{"line":124,"address":[600574,601157,600661],"length":1,"stats":{"Line":0}},{"line":126,"address":[600898,601140],"length":1,"stats":{"Line":0}},{"line":127,"address":[601056],"length":1,"stats":{"Line":0}},{"line":130,"address":[603714,604703,601184],"length":1,"stats":{"Line":0}},{"line":131,"address":[601214],"length":1,"stats":{"Line":0}},{"line":133,"address":[601403],"length":1,"stats":{"Line":0}},{"line":135,"address":[601670],"length":1,"stats":{"Line":0}},{"line":136,"address":[601937],"length":1,"stats":{"Line":0}},{"line":137,"address":[602303,602215,604676],"length":1,"stats":{"Line":0}},{"line":139,"address":[604662,602533],"length":1,"stats":{"Line":0}},{"line":140,"address":[604614,602875,602811],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[603685,603107,603201],"length":1,"stats":{"Line":0}},{"line":143,"address":[603668,603431],"length":1,"stats":{"Line":0}},{"line":145,"address":[603114],"length":1,"stats":{"Line":0}},{"line":150,"address":[603958],"length":1,"stats":{"Line":0}},{"line":158,"address":[604335,604272],"length":1,"stats":{"Line":0}},{"line":160,"address":[604470],"length":1,"stats":{"Line":0}},{"line":163,"address":[607300,604736,607229],"length":1,"stats":{"Line":0}},{"line":164,"address":[604766],"length":1,"stats":{"Line":0}},{"line":166,"address":[604955],"length":1,"stats":{"Line":0}},{"line":168,"address":[605222],"length":1,"stats":{"Line":0}},{"line":169,"address":[605489],"length":1,"stats":{"Line":0}},{"line":170,"address":[605767,607270,605855],"length":1,"stats":{"Line":0}},{"line":172,"address":[606085,607256],"length":1,"stats":{"Line":0}},{"line":180,"address":[606709,606645],"length":1,"stats":{"Line":0}},{"line":182,"address":[607020],"length":1,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[606847],"length":1,"stats":{"Line":0}},{"line":188,"address":[609151,609361,607328],"length":1,"stats":{"Line":0}},{"line":192,"address":[607363,607460,609341],"length":1,"stats":{"Line":0}},{"line":193,"address":[609336,607627],"length":1,"stats":{"Line":0}},{"line":196,"address":[607901],"length":1,"stats":{"Line":0}},{"line":197,"address":[608538],"length":1,"stats":{"Line":0}},{"line":205,"address":[608901,608838],"length":1,"stats":{"Line":0}},{"line":206,"address":[609036],"length":1,"stats":{"Line":0}},{"line":209,"address":[610860,610940,609392],"length":1,"stats":{"Line":0}},{"line":213,"address":[610926,609427,609524],"length":1,"stats":{"Line":0}},{"line":215,"address":[609691,610924],"length":1,"stats":{"Line":0}},{"line":217,"address":[609965],"length":1,"stats":{"Line":0}},{"line":218,"address":[610299],"length":1,"stats":{"Line":0}},{"line":225,"address":[610614,610551],"length":1,"stats":{"Line":0}},{"line":227,"address":[610749],"length":1,"stats":{"Line":0}},{"line":230,"address":[610976,613323,612536],"length":1,"stats":{"Line":0}},{"line":231,"address":[611017],"length":1,"stats":{"Line":0}},{"line":233,"address":[611185],"length":1,"stats":{"Line":0}},{"line":235,"address":[611221,611309,613290],"length":1,"stats":{"Line":0}},{"line":236,"address":[611539,613285],"length":1,"stats":{"Line":0}},{"line":237,"address":[613280,612560],"length":1,"stats":{"Line":0}},{"line":238,"address":[612755,613041],"length":1,"stats":{"Line":0}},{"line":240,"address":[612735,612791],"length":1,"stats":{"Line":0}},{"line":243,"address":[612545,611829],"length":1,"stats":{"Line":0}},{"line":250,"address":[612275,612212],"length":1,"stats":{"Line":0}},{"line":252,"address":[612410],"length":1,"stats":{"Line":0}},{"line":255,"address":[615172,613360,615115],"length":1,"stats":{"Line":0}},{"line":259,"address":[615158,613395,613500],"length":1,"stats":{"Line":0}},{"line":261,"address":[613676,615156],"length":1,"stats":{"Line":0}},{"line":263,"address":[615142,613953],"length":1,"stats":{"Line":0}},{"line":266,"address":[614255],"length":1,"stats":{"Line":0}},{"line":267,"address":[614636],"length":1,"stats":{"Line":0}},{"line":274,"address":[614800,614863],"length":1,"stats":{"Line":0}},{"line":276,"address":[614998],"length":1,"stats":{"Line":0}},{"line":279,"address":[619924,615200,619316],"length":1,"stats":{"Line":0}},{"line":284,"address":[619890,615353,615240],"length":1,"stats":{"Line":0}},{"line":285,"address":[615758],"length":1,"stats":{"Line":0}},{"line":287,"address":[615792],"length":1,"stats":{"Line":0}},{"line":288,"address":[615903,615839,619827],"length":1,"stats":{"Line":0}},{"line":289,"address":[616470,619822],"length":1,"stats":{"Line":0}},{"line":290,"address":[619820,616771,616708],"length":1,"stats":{"Line":0}},{"line":292,"address":[619728,617270],"length":1,"stats":{"Line":0}},{"line":293,"address":[616986,617050,619756],"length":1,"stats":{"Line":0}},{"line":294,"address":[617205],"length":1,"stats":{"Line":0}},{"line":296,"address":[619529,619733,619474,619642],"length":1,"stats":{"Line":0}},{"line":297,"address":[619325],"length":1,"stats":{"Line":0}},{"line":298,"address":[619413],"length":1,"stats":{"Line":0}},{"line":303,"address":[617324],"length":1,"stats":{"Line":0}},{"line":304,"address":[617429],"length":1,"stats":{"Line":0}},{"line":306,"address":[618878],"length":1,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[617598],"length":1,"stats":{"Line":0}},{"line":309,"address":[617706],"length":1,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[617823],"length":1,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[617940],"length":1,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[618057],"length":1,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[618174],"length":1,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[618291],"length":1,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[618408],"length":1,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[618525],"length":1,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[618642],"length":1,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[618756],"length":1,"stats":{"Line":0}},{"line":337,"address":[619029,619142,617676],"length":1,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[616178,616436],"length":1,"stats":{"Line":0}},{"line":355,"address":[616336],"length":1,"stats":{"Line":0}},{"line":358,"address":[619952,621708,623269],"length":1,"stats":{"Line":0}},{"line":359,"address":[619982],"length":1,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[622953,623035],"length":1,"stats":{"Line":0}},{"line":390,"address":[623170],"length":1,"stats":{"Line":0}},{"line":393,"address":[624166,623376],"length":1,"stats":{"Line":0}},{"line":394,"address":[623406],"length":1,"stats":{"Line":0}},{"line":398,"address":[623571],"length":1,"stats":{"Line":0}},{"line":401,"address":[623932,623869],"length":1,"stats":{"Line":0}},{"line":403,"address":[624067],"length":1,"stats":{"Line":0}},{"line":406,"address":[625666,624192],"length":1,"stats":{"Line":0}},{"line":407,"address":[624222],"length":1,"stats":{"Line":0}},{"line":411,"address":[624387],"length":1,"stats":{"Line":0}},{"line":420,"address":[625409],"length":1,"stats":{"Line":0}},{"line":422,"address":[625567],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":199},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","single_token.rs"],"content":"use crate::{\n    frontend::{ast::*, lexer::token::Token},\n    midend::types::{Mutability, Type},\n};\n\nuse super::{ParseError, Parser};\n\n// parsing functions which only consume a single token\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn parse_identifier(\u0026mut self) -\u003e Result\u003cString, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"identifier\")?;\n\n        let identifier = match self.expect_token(Token::Identifier(String::from(\"\")))? {\n            Token::Identifier(value) =\u003e value,\n            _ =\u003e self.unexpected_token::\u003cString\u003e(\u0026[Token::Identifier(\"\".into())])?,\n        };\n\n        self.finish_parsing(\u0026identifier)?;\n\n        Ok(identifier)\n    }\n\n    pub fn parse_typename(\u0026mut self) -\u003e Result\u003cTypenameTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"typename\")?;\n\n        let typename = TypenameTree {\n            loc: start_loc,\n            type_: self.parse_type()?,\n        };\n\n        self.finish_parsing(\u0026typename)?;\n\n        Ok(typename)\n    }\n\n    pub fn parse_type(\u0026mut self) -\u003e Result\u003cType, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"type\")?;\n\n        let type_ = match self.peek_token()? {\n            Token::U8 =\u003e {\n                self.next_token()?;\n                Type::U8\n            }\n            Token::U16 =\u003e {\n                self.next_token()?;\n                Type::U16\n            }\n            Token::U32 =\u003e {\n                self.next_token()?;\n                Type::U32\n            }\n            Token::U64 =\u003e {\n                self.next_token()?;\n                Type::U64\n            }\n            Token::I8 =\u003e {\n                self.next_token()?;\n                Type::I8\n            }\n            Token::I16 =\u003e {\n                self.next_token()?;\n                Type::I16\n            }\n            Token::I32 =\u003e {\n                self.next_token()?;\n                Type::I32\n            }\n            Token::I64 =\u003e {\n                self.next_token()?;\n                Type::I64\n            }\n            Token::Identifier(name) =\u003e {\n                self.next_token()?;\n                Type::UDT(name)\n            }\n            Token::SelfUpper =\u003e {\n                self.next_token()?;\n                Type::Self_\n            }\n            Token::Reference =\u003e {\n                self.next_token()?;\n                Type::Reference(\n                    match self.peek_token()? {\n                        Token::Mut =\u003e {\n                            self.expect_token(Token::Mut)?;\n                            Mutability::Mutable\n                        }\n                        _ =\u003e Mutability::Immutable,\n                    },\n                    Box::from(self.parse_type()?),\n                )\n            }\n            _ =\u003e self.unexpected_token(\u0026[\n                Token::U8,\n                Token::U16,\n                Token::U32,\n                Token::U64,\n                Token::I8,\n                Token::I16,\n                Token::I32,\n                Token::I64,\n                Token::Identifier(\"\".into()),\n                Token::SelfUpper,\n            ])?,\n        };\n        self.finish_parsing(\u0026type_);\n\n        Ok(type_)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::frontend::{\n        lexer::{token::Token, Lexer},\n        parser::{ParseError, Parser},\n        sourceloc::SourceLoc,\n    };\n\n    #[test]\n    fn parse_identifier() {\n        let mut p = Parser::new(Lexer::from_string(\"my_identifier\"));\n        assert_eq!(p.parse_identifier(), Ok(\"my_identifier\".into()));\n    }\n\n    #[test]\n    fn parse_identifier_error() {\n        let mut p = Parser::new(Lexer::from_string(\"struct\"));\n        assert_eq!(\n            p.parse_identifier(),\n            Err(ParseError::unexpected_token(\n                SourceLoc::new(1, 1),\n                Token::Struct,\n                \u0026[Token::Identifier(\"\".into())]\n            ))\n        );\n    }\n}\n","traces":[{"line":10,"address":[627228,625696],"length":1,"stats":{"Line":2}},{"line":11,"address":[625726],"length":1,"stats":{"Line":2}},{"line":13,"address":[625884],"length":1,"stats":{"Line":1}},{"line":14,"address":[626238],"length":1,"stats":{"Line":1}},{"line":15,"address":[626469,626344,627258],"length":1,"stats":{"Line":0}},{"line":18,"address":[626962,626876],"length":1,"stats":{"Line":2}},{"line":20,"address":[627102],"length":1,"stats":{"Line":1}},{"line":23,"address":[628026,627296],"length":1,"stats":{"Line":0}},{"line":24,"address":[627326],"length":1,"stats":{"Line":0}},{"line":28,"address":[627491],"length":1,"stats":{"Line":0}},{"line":31,"address":[627792,627729],"length":1,"stats":{"Line":0}},{"line":33,"address":[627927],"length":1,"stats":{"Line":0}},{"line":36,"address":[632619,633992,628048],"length":1,"stats":{"Line":0}},{"line":37,"address":[628093],"length":1,"stats":{"Line":0}},{"line":39,"address":[628256],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[629365,629081,628714],"length":1,"stats":{"Line":0}},{"line":42,"address":[629298],"length":1,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[629669,628737,629432],"length":1,"stats":{"Line":0}},{"line":46,"address":[629646],"length":1,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[628760,629927,629690],"length":1,"stats":{"Line":0}},{"line":50,"address":[629904],"length":1,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[628783,629948,630185],"length":1,"stats":{"Line":0}},{"line":54,"address":[630162],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[628806,630443,630206],"length":1,"stats":{"Line":0}},{"line":58,"address":[630420],"length":1,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[630464,628829,630701],"length":1,"stats":{"Line":0}},{"line":62,"address":[630678],"length":1,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[628852,630722,630959],"length":1,"stats":{"Line":0}},{"line":66,"address":[630936],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[628875,630980,631217],"length":1,"stats":{"Line":0}},{"line":70,"address":[631194],"length":1,"stats":{"Line":0}},{"line":72,"address":[628936],"length":1,"stats":{"Line":0}},{"line":73,"address":[628984,632698],"length":1,"stats":{"Line":0}},{"line":74,"address":[632915],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[628898,631238,631475],"length":1,"stats":{"Line":0}},{"line":78,"address":[631452],"length":1,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[632633,631496,628921],"length":1,"stats":{"Line":0}},{"line":83,"address":[631726,632628],"length":1,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[631983,632083,632325],"length":1,"stats":{"Line":0}},{"line":86,"address":[632297],"length":1,"stats":{"Line":0}},{"line":88,"address":[632014],"length":1,"stats":{"Line":0}},{"line":90,"address":[632361,632614,632318],"length":1,"stats":{"Line":0}},{"line":93,"address":[633133,633650,633537],"length":1,"stats":{"Line":0}},{"line":94,"address":[628533],"length":1,"stats":{"Line":0}},{"line":95,"address":[628551],"length":1,"stats":{"Line":0}},{"line":96,"address":[628569],"length":1,"stats":{"Line":0}},{"line":97,"address":[628587],"length":1,"stats":{"Line":0}},{"line":98,"address":[628605],"length":1,"stats":{"Line":0}},{"line":99,"address":[628623],"length":1,"stats":{"Line":0}},{"line":100,"address":[628641],"length":1,"stats":{"Line":0}},{"line":101,"address":[628659],"length":1,"stats":{"Line":0}},{"line":102,"address":[628667,633083],"length":1,"stats":{"Line":0}},{"line":103,"address":[633125],"length":1,"stats":{"Line":0}},{"line":106,"address":[633796,633870],"length":1,"stats":{"Line":0}},{"line":108,"address":[633882],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":66},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser","tests_old.rs"],"content":"use crate::frontend::ast::*;\nuse crate::frontend::lexer::{token::Token, *};\nuse crate::frontend::sourceloc::SourceLoc;\nuse crate::midend::types::Type;\nuse crate::Parser;\n\n#[cfg(test)]\nfn parser_from_string\u003c'a\u003e(input: \u0026'a str) -\u003e Parser\u003c'a\u003e {\n    Parser::new(Lexer::from_string(input))\n}\n\n/// Expressions\n#[cfg(test)]\nfn parse_and_print_expression(input: \u0026str) -\u003e String {\n    let mut parser = parser_from_string(input);\n    let expr_string = parser.parse_expression().expect(\"\").to_string();\n    let _ = parser.expect_token(Token::Eof);\n    expr_string\n}\n\n#[test]\nfn basic_expression() {\n    assert_eq!(\n        parse_and_print_expression(\"123 + 456 + 789\"),\n        \"(123 + (456 + 789))\"\n    );\n}\n\n#[test]\nfn addition_and_multiplication() {\n    assert_eq!(\n        parse_and_print_expression(\"123 + 456 * 789\"),\n        \"(123 + (456 * 789))\"\n    );\n}\n\n#[test]\nfn parentheses_override_precedence() {\n    assert_eq!(\n        parse_and_print_expression(\"(123 + 456) * 789\"),\n        \"((123 + 456) * 789)\"\n    );\n}\n\n#[test]\nfn mixed_arithmetic_operations() {\n    assert_eq!(\n        parse_and_print_expression(\"1 + 2 * 3 - 4 / 5\"),\n        \"(1 + ((2 * 3) - (4 / 5)))\"\n    );\n}\n\n#[test]\nfn nested_parentheses() {\n    assert_eq!(\n        parse_and_print_expression(\"((1 + 2) * (3 - 4)) / 5\"),\n        \"(((1 + 2) * (3 - 4)) / 5)\"\n    );\n}\n\n#[test]\nfn single_number() {\n    assert_eq!(parse_and_print_expression(\"42\"), \"42\");\n}\n\n#[test]\nfn single_number_parenthesized() {\n    assert_eq!(parse_and_print_expression(\"(42)\"), \"42\");\n}\n\n#[test]\nfn multiple_additions() {\n    assert_eq!(parse_and_print_expression(\"1 + 2 + 3\"), \"(1 + (2 + 3))\");\n}\n\n#[test]\nfn complex_arithmetic_expression() {\n    assert_eq!(\n        parse_and_print_expression(\"3 + 4 * 2 / (1 - 5)\"),\n        \"(3 + (4 * (2 / (1 - 5))))\"\n    );\n}\n\n/// variable declarations\n#[cfg(test)]\nfn parse_and_print_variable_declaration(input: \u0026str) -\u003e String {\n    let mut parser = parser_from_string(input);\n    let expr_string = parser.parse_variable_declaration().expect(\"\").to_string();\n    let _ = parser.expect_token(Token::Eof);\n    expr_string\n}\n\n#[test]\nfn u8_declaration() {\n    assert_eq!(parse_and_print_variable_declaration(\"abc: u8\"), \"abc: u8\");\n}\n\n#[test]\nfn if_expression() {\n    let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;}\");\n    assert_eq!(\n        format!(\"{}\", p.parse_if_expression().expect(\"\")),\n        \"if (a \u003e b)\n\\t{Compound Expression: a = (a + b)\n}\"\n    );\n}\n\n#[test]\nfn if_else_expression() {\n    let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;} else {b = b + a;}\");\n    assert_eq!(\n        format!(\"{}\", p.parse_if_expression().expect(\"\")),\n        \"if (a \u003e b)\n\\t{Compound Expression: a = (a + b)\n} else {Compound Expression: b = (b + a)\n}\"\n    );\n}\n\n#[test]\nfn while_loop() {\n    let mut p = parser_from_string(\"while (a \u003e b) {b = b + a; count = count + 1;} a = a + count;\");\n    assert_eq!(\n        format!(\"{}\", p.parse_while_expression().expect(\"\")),\n        \"while ((a \u003e b)) Compound Expression: b = (b + a)\ncount = (count + 1)\n\"\n    );\n}\n\n#[test]\nfn struct_definition() {\n    let mut p = parser_from_string(\"struct money{\\ndollars: u64,\\ncents: u8\\n}\");\n\n    assert_eq!(\n        p.parse_struct_definition().expect(\"\"),\n        TranslationUnit::StructDefinition(StructDefinitionTree {\n            loc: SourceLoc::new(1, 1),\n            name: \"money\".into(),\n            fields: vec![\n                VariableDeclarationTree {\n                    loc: SourceLoc::new(2, 1),\n                    name: \"dollars\".into(),\n                    typename: TypenameTree {\n                        loc: SourceLoc::new(2, 10),\n                        type_: Type::U64\n                    }\n                },\n                VariableDeclarationTree {\n                    loc: SourceLoc::new(3, 1),\n                    name: \"cents\".into(),\n                    typename: TypenameTree {\n                        loc: SourceLoc::new(3, 8),\n                        type_: Type::U8\n                    }\n                }\n            ]\n        })\n    )\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","parser.rs"],"content":"// #[cfg(test)]\n// mod tests_old;\n\nuse std::collections::VecDeque;\n\nuse crate::midend::ir;\nuse crate::midend::types::Type;\n\nuse super::{\n    ast::*,\n    lexer::{token::Token, *},\n    sourceloc::SourceLoc,\n};\n\nmod declarations;\nmod errors;\nmod expressions;\nmod single_token;\n\npub use errors::ParseError;\n\npub struct Parser\u003c'a\u003e {\n    lexer: Lexer\u003c'a\u003e,\n    last_match: SourceLoc,\n    upcoming_tokens: VecDeque\u003c(Token, SourceLoc)\u003e,\n    parsing_stack: Vec\u003c(SourceLoc, String)\u003e,\n}\n\nimpl ir::BinaryOperations {\n    pub fn get_precedence(\u0026self) -\u003e usize {\n        match self {\n            Self::Add(_) =\u003e 1,\n            Self::Subtract(_) =\u003e 1,\n            Self::Multiply(_) =\u003e 2,\n            Self::Divide(_) =\u003e 2,\n            Self::LThan(_) =\u003e 3,\n            Self::GThan(_) =\u003e 3,\n            Self::LThanE(_) =\u003e 3,\n            Self::GThanE(_) =\u003e 3,\n            Self::Equals(_) =\u003e 4,\n            Self::NotEquals(_) =\u003e 4,\n        }\n    }\n\n    pub fn precedence_of_token(token: \u0026Token) -\u003e usize {\n        match token {\n            Token::Plus =\u003e 1,\n            Token::Minus =\u003e 1,\n            Token::Star =\u003e 2,\n            Token::FSlash =\u003e 2,\n            Token::LThan =\u003e 3,\n            Token::GThan =\u003e 3,\n            Token::LThanE =\u003e 3,\n            Token::GThanE =\u003e 3,\n            Token::Equals =\u003e 4,\n            Token::NotEquals =\u003e 4,\n            _ =\u003e {\n                panic!(\n                    \"Invalid token {} passed to BinaryOperations::precedence_of_token\",\n                    token\n                );\n            }\n        }\n    }\n}\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn new(lexer: Lexer\u003c'a\u003e) -\u003e Self {\n        let lexer_start_pos = lexer.current_loc();\n        Parser {\n            lexer: lexer,\n            last_match: lexer_start_pos,\n            upcoming_tokens: VecDeque::new(),\n            parsing_stack: Vec::new(),\n        }\n    }\n\n    fn ensure_n_tokens_in_lookahead(\u0026mut self, n: usize) -\u003e Result\u003c(), LexError\u003e {\n        while self.upcoming_tokens.len() \u003c= n \u0026\u0026 self.lexer.peek()?.0 != Token::Eof {\n            self.upcoming_tokens.push_back(self.lexer.next()?);\n        }\n\n        Ok(())\n    }\n\n    // return the next token from the input stream without advancing\n    // utilizes lookahead_token\n    fn peek_token(\u0026mut self) -\u003e Result\u003cToken, LexError\u003e {\n        // FIXME: since lookahead_token_with_loc always unwrap_or's, it can never return an error.\n        match self.peek_token_with_loc() {\n            Ok((token, _)) =\u003e Ok(token),\n            Err(e) =\u003e Err(e),\n        }\n    }\n\n    fn peek_token_with_loc(\u0026mut self) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        let peeked = self.lookahead_token_with_loc(0)?;\n        // #[cfg(feature = \"loud_parsing\")]\n        // println!(\"Parser::peek_token() -\u003e {}\", peeked);\n        return Ok(peeked);\n    }\n\n    fn lookahead_token(\u0026mut self, lookahead_by: usize) -\u003e Result\u003cToken, LexError\u003e {\n        match self.lookahead_token_with_loc(lookahead_by) {\n            Ok((token, _)) =\u003e Ok(token),\n            Err(e) =\u003e Err(e),\n        }\n    }\n\n    // returns the lookahead_by-th token from the input stream withing advancing, or EOF if that many tokens are not available\n    fn lookahead_token_with_loc(\n        \u0026mut self,\n        lookahead_by: usize,\n    ) -\u003e Result\u003c(Token, SourceLoc), LexError\u003e {\n        self.ensure_n_tokens_in_lookahead(lookahead_by)?;\n\n        Ok(self\n            .upcoming_tokens\n            .get(lookahead_by)\n            .cloned()\n            .unwrap_or((Token::Eof, SourceLoc::none())))\n    }\n\n    fn next_token(\u0026mut self) -\u003e Result\u003cToken, ParseError\u003e {\n        self.ensure_n_tokens_in_lookahead(1)?;\n        let (next, start_loc) = self\n            .upcoming_tokens\n            .pop_front()\n            .unwrap_or((Token::Eof, self.lexer.current_loc()));\n        self.last_match = start_loc;\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\"Parser::next_token() -\u003e {}@{}\", next, start_loc);\n        Ok(next)\n    }\n\n    fn expect_token(\u0026mut self, _expected: Token) -\u003e Result\u003cToken, ParseError\u003e {\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\"Parser::expect_token({})\", _expected);\n\n        let (upcoming_token, upcoming_loc) = self.peek_token_with_loc()?;\n        if upcoming_token.eq(\u0026_expected) {\n            self.next_token()\n        } else {\n            Err(ParseError::unexpected_token(\n                upcoming_loc,\n                upcoming_token,\n                \u0026[_expected],\n            ))\n        }\n    }\n\n    fn unexpected_token\u003cT\u003e(\u0026mut self, expected_tokens: \u0026[Token]) -\u003e Result\u003cT, ParseError\u003e {\n        let (current_parse_loc, _current_parse_str) = self\n            .parsing_stack\n            .last()\n            .unwrap_or(\u0026(SourceLoc::none(), String::from(\"UNKNOWN\")))\n            .to_owned();\n\n        let upcoming_token = match self.peek_token() {\n            Ok(tok) =\u003e tok,\n            Err(error) =\u003e return Err(ParseError::from(error)),\n        };\n\n        Err(ParseError::unexpected_token(\n            current_parse_loc,\n            upcoming_token,\n            expected_tokens,\n        ))\n    }\n\n    fn start_parsing(\u0026mut self, what_parsing: \u0026str) -\u003e Result\u003cSourceLoc, ParseError\u003e {\n        for _ in 0..self.parsing_stack.len() {\n            print!(\"\\t\");\n        }\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\"Start parsing {}\", what_parsing);\n\n        let start_loc = self.peek_token_with_loc()?.1;\n        self.parsing_stack\n            .push((start_loc, String::from(what_parsing)));\n        Ok(start_loc)\n    }\n\n    fn finish_parsing\u003cT\u003e(\u0026mut self, _parsed: \u0026T) -\u003e Result\u003c(), ParseError\u003e\n    where\n        T: std::fmt::Display,\n    {\n        let (_parse_start, _parsed_description) = self\n            .parsing_stack\n            .pop()\n            .expect(\"Mismatched loud parsing tracking\");\n        for _ in 0..self.parsing_stack.len() {\n            print!(\"\\t\");\n        }\n\n        #[cfg(feature = \"loud_parsing\")]\n        println!(\n            \"Done parsing {} ({}-{}): {}\",\n            _parsed_description,\n            _parse_start,\n            self.peek_token_with_loc()?.1,\n            _parsed\n        );\n\n        Ok(())\n    }\n}\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    pub fn parse(\u0026mut self) -\u003e Result\u003cVec\u003cTranslationUnitTree\u003e, ParseError\u003e {\n        let mut translation_units = Vec::new();\n        while self.peek_token()? != Token::Eof {\n            translation_units.push(self.parse_translation_unit()?);\n        }\n        Ok(translation_units)\n    }\n\n    fn parse_translation_unit(\u0026mut self) -\u003e Result\u003cTranslationUnitTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"translation unit\")?;\n\n        let translation_unit = TranslationUnitTree {\n            loc: start_loc,\n            contents: match self.peek_token()? {\n                Token::Fun =\u003e self.parse_function_declaration_or_definition()?,\n                Token::Struct =\u003e self.parse_struct_definition()?,\n                Token::Impl =\u003e self.parse_implementation()?,\n                _ =\u003e self.unexpected_token(\u0026[Token::Fun, Token::Struct])?,\n            },\n        };\n\n        self.finish_parsing(\u0026translation_unit)?;\n\n        Ok(translation_unit)\n    }\n\n    fn parse_statement(\u0026mut self) -\u003e Result\u003cStatementTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"statement\")?;\n\n        let statement = StatementTree {\n            loc: start_loc,\n            statement: match self.peek_token()? {\n                Token::Identifier(_) =\u003e match self.lookahead_token(1)? {\n                    Token::Colon =\u003e {\n                        Statement::VariableDeclaration(self.parse_variable_declaration()?)\n                    }\n                    _ =\u003e Statement::Expression(self.parse_expression()?),\n                },\n                Token::If | Token::While | Token::LCurly =\u003e {\n                    Statement::Expression(self.parse_expression()?)\n                }\n                _ =\u003e self.unexpected_token::\u003cStatement\u003e(\u0026[\n                    Token::Identifier(\"\".into()),\n                    Token::If,\n                    Token::While,\n                    Token::LCurly,\n                ])?,\n            },\n        };\n\n        if matches!(self.peek_token()?, Token::Semicolon) {\n            self.expect_token(Token::Semicolon)?;\n        }\n\n        self.finish_parsing(\u0026statement)?;\n\n        Ok(statement)\n    }\n\n    fn token_is_operator_of_at_least_precedence(token: \u0026Token, precedence: usize) -\u003e bool {\n        match token {\n            Token::Plus\n            | Token::Minus\n            | Token::Star\n            | Token::FSlash\n            | Token::LThan\n            | Token::GThan\n            | Token::LThanE\n            | Token::GThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e ir::BinaryOperations::precedence_of_token(\u0026token) \u003e= precedence,\n            _ =\u003e false,\n        }\n    }\n\n    fn try_parse_self_param(\u0026mut self) -\u003e Result\u003cOption\u003cVariableDeclarationTree\u003e, ParseError\u003e {\n        let start_loc = self.start_parsing(\"self parameter\")?;\n\n        let is_reference = match self.peek_token()? {\n            Token::Reference =\u003e {\n                self.expect_token(Token::Reference)?;\n                true\n            }\n            _ =\u003e false,\n        };\n\n        let is_mutable = match self.peek_token()? {\n            Token::Mut =\u003e {\n                self.expect_token(Token::Mut)?;\n                true\n            }\n            _ =\u003e false,\n        };\n\n        let maybe_self_param = match self.peek_token()? {\n            Token::SelfLower =\u003e {\n                let typename_loc = self.peek_token_with_loc()?.1;\n                self.expect_token(Token::SelfLower);\n                Some(VariableDeclarationTree {\n                    loc: start_loc,\n                    name: String::from(\"self\"),\n                    typename: TypenameTree {\n                        loc: typename_loc,\n                        type_: Type::Self_,\n                    },\n                })\n            }\n            _ =\u003e None,\n        };\n\n        match \u0026maybe_self_param {\n            Some(self_param) =\u003e self.finish_parsing(self_param)?,\n            None =\u003e self.finish_parsing(\u0026String::from(\"no self param\"))?,\n        };\n\n        Ok(maybe_self_param)\n    }\n\n    fn parse_function_parameters(\u0026mut self) -\u003e Result\u003cVec\u003cVariableDeclarationTree\u003e, ParseError\u003e {\n        let _start_loc = self.start_parsing(\"function parameters\");\n\n        let mut params = Vec::\u003cVariableDeclarationTree\u003e::new();\n\n        loop {\n            match self.peek_token()? {\n                // argument declaration\n                Token::Identifier(_) =\u003e {\n                    params.push(self.parse_variable_declaration()?);\n                    match self.peek_token()? {\n                        Token::Comma =\u003e self.next_token()?, // expect another argument declaration after comma\n                        _ =\u003e break,                         // loop again for anything else\n                    };\n                }\n                Token::RParen =\u003e break, // done on rparen\n                _ =\u003e self.unexpected_token(\u0026[Token::Identifier(\"\".into())])?,\n            }\n        }\n\n        self.finish_parsing(\u0026format!(\"{} parameters\", params.len()));\n        Ok(params)\n    }\n\n    fn parse_function_prototype(\u0026mut self) -\u003e Result\u003cFunctionDeclarationTree, ParseError\u003e {\n        let start_loc = self.start_parsing(\"function prototype\")?;\n\n        // start with fun\n        self.expect_token(Token::Fun)?;\n        let prototype = FunctionDeclarationTree {\n            // grab start location and name\n            loc: start_loc,\n            name: self.parse_identifier()?,\n            arguments: {\n                self.expect_token(Token::LParen)?;\n                let params = self.parse_function_parameters()?;\n                self.expect_token(Token::RParen)?;\n                params\n            },\n            return_type: match self.peek_token()? {\n                Token::Arrow =\u003e {\n                    self.next_token()?;\n                    Some(self.parse_typename()?)\n                }\n                _ =\u003e None,\n            },\n        };\n\n        self.finish_parsing(\u0026prototype)?;\n\n        Ok(prototype)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::frontend::{\n        lexer::{token::Token, LexError, Lexer},\n        parser::{ParseError, Parser},\n        sourceloc::SourceLoc,\n    };\n\n    #[test]\n    fn expect_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8\"));\n        let result = p.expect_token(Token::U8);\n        assert_eq!(result, Ok(Token::U8))\n    }\n\n    #[test]\n    fn expect_token_fail() {\n        let mut p = Parser::new(Lexer::from_string(\"abcd\"));\n        let result = p.expect_token(Token::U8);\n        assert_eq!(\n            result,\n            Err(ParseError::unexpected_token(\n                SourceLoc::new(1, 1),\n                Token::Identifier(\"abcd\".into()),\n                \u0026[Token::U8]\n            ))\n        )\n    }\n\n    #[test]\n    fn peek_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8\"));\n        assert_eq!(p.peek_token(), Ok(Token::U8));\n        p.next_token().unwrap();\n        assert_eq!(p.peek_token(), Ok(Token::Eof));\n        p.next_token().unwrap();\n        assert_eq!(p.peek_token(), Ok(Token::Eof));\n    }\n\n    #[test]\n    fn lookahead_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8 u16 u32 u64\"));\n        assert_eq!(p.lookahead_token(0), Ok(Token::U8));\n        assert_eq!(p.lookahead_token(1), Ok(Token::U16));\n        assert_eq!(p.lookahead_token(2), Ok(Token::U32));\n        assert_eq!(p.lookahead_token(3), Ok(Token::U64));\n    }\n\n    #[test]\n    fn unexpected_token() {\n        let mut p = Parser::new(Lexer::from_string(\"u8 u16 u32 u64\"));\n        assert_eq!(p.expect_token(Token::U8), Ok(Token::U8));\n        assert_eq!(\n            p.expect_token(Token::U32),\n            Err(ParseError::unexpected_token(\n                SourceLoc::new(1, 4),\n                Token::U16,\n                \u0026[Token::U32]\n            ))\n        );\n    }\n}\n","traces":[{"line":30,"address":[659968],"length":1,"stats":{"Line":0}},{"line":31,"address":[659973],"length":1,"stats":{"Line":0}},{"line":32,"address":[660004],"length":1,"stats":{"Line":0}},{"line":33,"address":[660015],"length":1,"stats":{"Line":0}},{"line":34,"address":[660026],"length":1,"stats":{"Line":0}},{"line":35,"address":[660037],"length":1,"stats":{"Line":0}},{"line":36,"address":[660048],"length":1,"stats":{"Line":0}},{"line":37,"address":[660059],"length":1,"stats":{"Line":0}},{"line":38,"address":[660070],"length":1,"stats":{"Line":0}},{"line":39,"address":[660081],"length":1,"stats":{"Line":0}},{"line":40,"address":[660092],"length":1,"stats":{"Line":0}},{"line":41,"address":[660103],"length":1,"stats":{"Line":0}},{"line":45,"address":[660128],"length":1,"stats":{"Line":0}},{"line":46,"address":[660137],"length":1,"stats":{"Line":0}},{"line":47,"address":[660285],"length":1,"stats":{"Line":0}},{"line":48,"address":[660296],"length":1,"stats":{"Line":0}},{"line":49,"address":[660307],"length":1,"stats":{"Line":0}},{"line":50,"address":[660318],"length":1,"stats":{"Line":0}},{"line":51,"address":[660329],"length":1,"stats":{"Line":0}},{"line":52,"address":[660340],"length":1,"stats":{"Line":0}},{"line":53,"address":[660351],"length":1,"stats":{"Line":0}},{"line":54,"address":[660362],"length":1,"stats":{"Line":0}},{"line":55,"address":[660373],"length":1,"stats":{"Line":0}},{"line":56,"address":[660384],"length":1,"stats":{"Line":0}},{"line":58,"address":[660220],"length":1,"stats":{"Line":0}},{"line":68,"address":[634208,634637],"length":1,"stats":{"Line":3}},{"line":69,"address":[634238,634327],"length":1,"stats":{"Line":7}},{"line":73,"address":[634393],"length":1,"stats":{"Line":4}},{"line":74,"address":[634445],"length":1,"stats":{"Line":4}},{"line":78,"address":[635294,634672],"length":1,"stats":{"Line":4}},{"line":79,"address":[634757,634720],"length":1,"stats":{"Line":8}},{"line":80,"address":[635168,635073],"length":1,"stats":{"Line":1}},{"line":83,"address":[634740],"length":1,"stats":{"Line":1}},{"line":88,"address":[635328],"length":1,"stats":{"Line":1}},{"line":90,"address":[635347],"length":1,"stats":{"Line":1}},{"line":91,"address":[635467],"length":1,"stats":{"Line":1}},{"line":92,"address":[635396],"length":1,"stats":{"Line":0}},{"line":96,"address":[635584],"length":1,"stats":{"Line":2}},{"line":97,"address":[635608],"length":1,"stats":{"Line":2}},{"line":100,"address":[635748],"length":1,"stats":{"Line":1}},{"line":103,"address":[635776],"length":1,"stats":{"Line":1}},{"line":104,"address":[635799],"length":1,"stats":{"Line":1}},{"line":105,"address":[635917],"length":1,"stats":{"Line":1}},{"line":106,"address":[635847],"length":1,"stats":{"Line":0}},{"line":111,"address":[636032,636478],"length":1,"stats":{"Line":2}},{"line":115,"address":[636075],"length":1,"stats":{"Line":4}},{"line":117,"address":[636361,636202,636447],"length":1,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[636241,636508,636400],"length":1,"stats":{"Line":1}},{"line":124,"address":[636528,637093],"length":1,"stats":{"Line":1}},{"line":125,"address":[636558],"length":1,"stats":{"Line":2}},{"line":126,"address":[636943,636685,636845],"length":1,"stats":{"Line":9}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[636884,636721,637123],"length":1,"stats":{"Line":2}},{"line":130,"address":[637020],"length":1,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[637034],"length":1,"stats":{"Line":4}},{"line":136,"address":[637843,637136,637938],"length":1,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[637264,637171],"length":1,"stats":{"Line":3}},{"line":141,"address":[637489,637545],"length":1,"stats":{"Line":2}},{"line":142,"address":[637714,637852],"length":1,"stats":{"Line":4}},{"line":144,"address":[637697,637769],"length":1,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[637570],"length":1,"stats":{"Line":1}},{"line":147,"address":[637604],"length":1,"stats":{"Line":1}},{"line":152,"address":[1016521,1016624,1019897,1015720,1019043,1017379,1018211,1014888,1014912,1014080,1015667,1016596,1015744,1017456,1018288,1019096,1019972,1018264,1019120,1014835,1017432],"length":1,"stats":{"Line":0}},{"line":153,"address":[1018496,1016014,1018558,1016894,1017726,1014350,1018352,1016832,1015808,1016688,1015120,1015182,1014288,1017664,1014144,1015952,1019184,1017520,1019390,1014976,1019328],"length":1,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[1019217,1016721,1018385,1014177,1015009,1015841,1017553],"length":1,"stats":{"Line":0}},{"line":159,"address":[1016155,1019531,1014491,1017035,1017867,1018699,1015323],"length":1,"stats":{"Line":0}},{"line":160,"address":[1019630,1018798,1017134,1017966,1014590,1016254,1015422],"length":1,"stats":{"Line":0}},{"line":161,"address":[1017888,1019911,1014512,1019552,1018720,1015344,1017393,1014849,1018225,1015681,1017056,1019057,1016176,1016535],"length":1,"stats":{"Line":0}},{"line":164,"address":[1018975,1018926,1016382,1018143,1014718,1015550,1019807,1018094,1014767,1019758,1017262,1015599,1017311,1016431],"length":1,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[1019702,1018038,1015494,1016326,1014662,1018870,1017206],"length":1,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[637968],"length":1,"stats":{"Line":2}},{"line":172,"address":[638032],"length":1,"stats":{"Line":2}},{"line":173,"address":[638081],"length":1,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[638116],"length":1,"stats":{"Line":2}},{"line":179,"address":[638387,638488],"length":1,"stats":{"Line":2}},{"line":180,"address":[638396],"length":1,"stats":{"Line":1}},{"line":181,"address":[638523],"length":1,"stats":{"Line":1}},{"line":184,"address":[1025166,1020400,1021200,1024766,1020766,1021166,1020366,1024000,1023600,1022766,1023966,1024366,1021600,1022366,1021966,1023566,1021566,1022400,1023166,1020000,1022800,1024800,1023200,1020800,1022000,1024400],"length":1,"stats":{"Line":1}},{"line":188,"address":[1020833,1022433,1024033,1024433,1020433,1022833,1020033,1023233,1021233,1024833,1022033,1023633,1021633],"length":1,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[1023407,1022945,1021007,1021807,1022607,1021407,1020145,1023345,1020607,1024145,1020545,1021345,1022145,1023007,1021745,1023745,1024945,1024207,1022207,1025007,1023807,1020207,1022545,1024545,1024607,1020945],"length":1,"stats":{"Line":2}},{"line":193,"address":[1022345,1021545,1024681,1023081,1020345,1021945,1023545,1024281,1021145,1022745,1022281,1025081,1023881,1023145,1021081,1021881,1023481,1021481,1023945,1024745,1020681,1020281,1022681,1025145,1020745,1024345],"length":1,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[1024708,1020708,1021508,1024308,1022308,1021908,1025108,1023108,1021108,1023908,1022708,1020308,1023508],"length":1,"stats":{"Line":1}},{"line":210,"address":[639257,638560,639246],"length":1,"stats":{"Line":0}},{"line":211,"address":[638590],"length":1,"stats":{"Line":0}},{"line":212,"address":[639255,638670,638613],"length":1,"stats":{"Line":0}},{"line":213,"address":[639009],"length":1,"stats":{"Line":0}},{"line":215,"address":[638895],"length":1,"stats":{"Line":0}},{"line":218,"address":[639280,641109],"length":1,"stats":{"Line":0}},{"line":219,"address":[639310],"length":1,"stats":{"Line":0}},{"line":223,"address":[639475],"length":1,"stats":{"Line":0}},{"line":231,"address":[640874],"length":1,"stats":{"Line":0}},{"line":233,"address":[641032],"length":1,"stats":{"Line":0}},{"line":236,"address":[641136,644396,642888],"length":1,"stats":{"Line":0}},{"line":237,"address":[641166],"length":1,"stats":{"Line":0}},{"line":241,"address":[641331],"length":1,"stats":{"Line":0}},{"line":260,"address":[643574,644391],"length":1,"stats":{"Line":0}},{"line":261,"address":[643864,644153],"length":1,"stats":{"Line":0}},{"line":264,"address":[644146,644189,644386],"length":1,"stats":{"Line":0}},{"line":266,"address":[644324],"length":1,"stats":{"Line":0}},{"line":269,"address":[644432],"length":1,"stats":{"Line":0}},{"line":270,"address":[644451],"length":1,"stats":{"Line":0}},{"line":271,"address":[644507],"length":1,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[644500],"length":1,"stats":{"Line":0}},{"line":285,"address":[644560,645457],"length":1,"stats":{"Line":0}},{"line":286,"address":[644590],"length":1,"stats":{"Line":0}},{"line":288,"address":[644761],"length":1,"stats":{"Line":0}},{"line":289,"address":[645038,645138],"length":1,"stats":{"Line":0}},{"line":290,"address":[645355],"length":1,"stats":{"Line":0}},{"line":291,"address":[645069],"length":1,"stats":{"Line":0}},{"line":294,"address":[645381,645484],"length":1,"stats":{"Line":0}},{"line":295,"address":[645805,645705],"length":1,"stats":{"Line":0}},{"line":296,"address":[646022],"length":1,"stats":{"Line":0}},{"line":297,"address":[645736],"length":1,"stats":{"Line":0}},{"line":300,"address":[646121,646048],"length":1,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[646343,646429],"length":1,"stats":{"Line":0}},{"line":303,"address":[646703],"length":1,"stats":{"Line":0}},{"line":304,"address":[646878],"length":1,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[646749],"length":1,"stats":{"Line":0}},{"line":307,"address":[646814],"length":1,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[646796],"length":1,"stats":{"Line":0}},{"line":313,"address":[647006,646350],"length":1,"stats":{"Line":0}},{"line":315,"address":[647071],"length":1,"stats":{"Line":0}},{"line":316,"address":[647523,647121],"length":1,"stats":{"Line":0}},{"line":317,"address":[647147,647470],"length":1,"stats":{"Line":0}},{"line":320,"address":[647416],"length":1,"stats":{"Line":0}},{"line":323,"address":[647680,649065,649810],"length":1,"stats":{"Line":0}},{"line":324,"address":[647710],"length":1,"stats":{"Line":0}},{"line":326,"address":[647781,647737],"length":1,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[647796,649793,647853],"length":1,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[648191,648128,649452],"length":1,"stats":{"Line":0}},{"line":333,"address":[649447,648449],"length":1,"stats":{"Line":0}},{"line":334,"address":[648785,648704],"length":1,"stats":{"Line":0}},{"line":339,"address":[649462,648063],"length":1,"stats":{"Line":0}},{"line":343,"address":[649079],"length":1,"stats":{"Line":0}},{"line":344,"address":[649336],"length":1,"stats":{"Line":0}},{"line":347,"address":[649824,652526],"length":1,"stats":{"Line":0}},{"line":348,"address":[649854],"length":1,"stats":{"Line":0}},{"line":351,"address":[650018],"length":1,"stats":{"Line":0}},{"line":355,"address":[650285],"length":1,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[651401,651464],"length":1,"stats":{"Line":0}},{"line":371,"address":[652606],"length":1,"stats":{"Line":0}},{"line":373,"address":[652764],"length":1,"stats":{"Line":0}}],"covered":44,"coverable":174},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend","sourceloc.rs"],"content":"use std::fmt::Display;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct SourceLoc {\n    line: usize,\n    col: usize,\n}\n\nimpl SourceLoc {\n    pub fn none() -\u003e Self {\n        SourceLoc { line: 0, col: 0 }\n    }\n\n    pub fn new(line: usize, col: usize) -\u003e Self {\n        SourceLoc { line, col }\n    }\n}\n\nimpl Display for SourceLoc {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}:{}\", self.line, self.col)\n    }\n}\n","traces":[{"line":12,"address":[772224],"length":1,"stats":{"Line":1}},{"line":16,"address":[772240],"length":1,"stats":{"Line":8}},{"line":22,"address":[772272],"length":1,"stats":{"Line":0}},{"line":23,"address":[772311],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","frontend.rs"],"content":"pub mod ast;\npub mod lexer;\npub mod parser;\npub mod sourceloc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","hashmap_ooo_iter.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::hash::Hash;\n\nfn check_key_order\u003cK, V\u003e(map: \u0026HashMap\u003cK, V\u003e, key_order: \u0026Vec\u003cK\u003e)\nwhere\n    K: Eq + Hash,\n{\n    let mut seen_keys = HashSet::\u003c\u0026K\u003e::new();\n    for key in key_order {\n        assert!(\n            map.contains_key(key),\n            \"All keys in key ordering for out-of-order HashMap iterator must be present in map\"\n        );\n        assert!(\n            !seen_keys.contains(key),\n            \"Duplicate key seen in key ordering for out-of-order HashMap iterator\",\n        );\n        seen_keys.insert(key);\n    }\n\n    assert!(\n        seen_keys.len() == map.len(),\n        \"Missing key(s) from key ordering for out-of-order HashMap iterator. All keys must be included\"\n    );\n}\n\n// the iterator itself only needs to own Key, \u0026Value pairs\npub struct HashMapOOOIter\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a V)\u003e,\n}\n\n// iteration is simply popping from the references vec\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIter\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIter\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // allocate the vector with its full capacity from the get-go\n        let mut references = Vec::\u003c(K, \u0026'a V)\u003e::with_capacity(map.len());\n        // grab values for each key, moving each key into the references vector along with its corresponding value reference\n        for key in key_order.into_iter().rev() {\n            let value_ref: \u0026V = map.get(\u0026key).unwrap();\n            references.push((key, value_ref));\n        }\n\n        HashMapOOOIter { references }\n    }\n}\n\npub struct HashMapOOOIterMut\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a mut V)\u003e,\n}\n\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIterMut\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a mut V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIterMut\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a mut HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // same as for HashMapOOOIter but with additional reference manipulation\n        let mut references = Vec::\u003c(K, \u0026'a mut V)\u003e::with_capacity(map.len());\n        for key in key_order.into_iter().rev() {\n            // get our value reference as normal\n            let value: \u0026V = map.get(\u0026key).unwrap();\n            // create a pointer from the reference, and cast it to a mutable pointer\n            let pointer: *const V = std::ptr::from_ref(value);\n            let mut_pointer: *mut V = pointer as *mut V;\n            // since we have exactly one instance of every key in the map per check_key_order()\n            let value_mut: \u0026mut V = unsafe {\n                // trust that we can .as_mut() the pointer into a mutable reference\n                mut_pointer.as_mut()\n            }\n            .unwrap();\n            references.push((key, value_mut));\n        }\n\n        HashMapOOOIterMut { references }\n    }\n}\n","traces":[{"line":4,"address":[711244,710736],"length":1,"stats":{"Line":0}},{"line":8,"address":[710774],"length":1,"stats":{"Line":0}},{"line":9,"address":[710848,710784],"length":1,"stats":{"Line":0}},{"line":10,"address":[711092,711135],"length":1,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[711124,711165],"length":1,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[711181,711210],"length":1,"stats":{"Line":0}},{"line":21,"address":[711014,711054],"length":1,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[711280],"length":1,"stats":{"Line":0}},{"line":37,"address":[711285],"length":1,"stats":{"Line":0}},{"line":45,"address":[711296,712040],"length":1,"stats":{"Line":0}},{"line":46,"address":[711347],"length":1,"stats":{"Line":0}},{"line":49,"address":[711424],"length":1,"stats":{"Line":0}},{"line":51,"address":[711465,712030,711572,711726],"length":1,"stats":{"Line":0}},{"line":52,"address":[711957,711793],"length":1,"stats":{"Line":0}},{"line":53,"address":[711987],"length":1,"stats":{"Line":0}},{"line":67,"address":[712080],"length":1,"stats":{"Line":0}},{"line":68,"address":[712085],"length":1,"stats":{"Line":0}},{"line":76,"address":[712943,712096],"length":1,"stats":{"Line":0}},{"line":77,"address":[712147],"length":1,"stats":{"Line":0}},{"line":80,"address":[712224],"length":1,"stats":{"Line":0}},{"line":81,"address":[712933,712541,712265,712372],"length":1,"stats":{"Line":0}},{"line":83,"address":[712608,712776],"length":1,"stats":{"Line":0}},{"line":85,"address":[712808],"length":1,"stats":{"Line":0}},{"line":86,"address":[712833],"length":1,"stats":{"Line":0}},{"line":90,"address":[712841],"length":1,"stats":{"Line":0}},{"line":93,"address":[712890],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","main.rs"],"content":"mod backend;\nmod frontend;\nmod midend;\n\nmod hashmap_ooo_iter;\n\nuse backend::generate_code;\nuse frontend::{lexer::Lexer, parser::Parser};\n\nconst FIB_FUN: \u0026str = \"fun fib(u8 n) -\u003e u64\n{\n    u64 result;\n    result = 0;\n    if (n \u003e 0) {\n        if(n == 0) {\n            result = 0;\n        } else {\n         result = 1;\n        }\n    } else {\n        result = (n - 1) - (n - 2);\n    }\n}\";\n\nconst WHILE_LOOP: \u0026str = \"fun down_to_zero(u16 input)\n{\n    input = input;\n    while(input \u003e 0) {\n        input = input - 1;\n    }\n\n    input = input + 1;\n}\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH: \u0026str = \"\nfun while_with_nested_branch(a: u8, b: u16, c: u32) {\n    counter: u8;\n    counter = 0;\n    while (a \u003c b) {\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            counter = counter - 1;\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH_NO_ARGS: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    while (a \u003c b) {\n        u8 counter;\n        if (c \u003e 22) {\n            a = a + b;\n        } else {\n            b = b - 1;\n        }\n    }\n}\n\";\n\nconst NESTED_WHILE_LOOPS: \u0026str = \"\nfun while_with_nested_branch(u8 a, u16 b, u32 c) {\n    while (a \u003c b) {\n        u8 counter;\n        counter = 0;\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            while (counter \u003e 0) {\n            counter = counter - 1;\n            }\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst SSA_EXAMPLE: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    \n    a = b + c;\n    b = a + c;\n    if (a \u003e b) {\n    c = c + 1;\n    } else {\n     c = 1;}\n    c = c + 1;\n    c = c + 1;\n}\";\n\nconst STRUCT_EXAMPLE: \u0026str = \"struct Money {\ndollars: u64,\ncents: u8\n}\n\nimpl Money {\n    fun new(dollars: u64, cents: u8) -\u003e Self {\n        \n    }\n}\n\nfun money_add_dollars(m: Money, dollars: u64) {\n    m.dollars = m.dollars + dollars;\n    m.print();\n}\n\";\n\nfn main() {\n    println!(\"Hello, world!\");\n    let mut parser = Parser::new(Lexer::from_string(STRUCT_EXAMPLE));\n    let program = parser.parse().expect(\"Error parsing input\");\n\n    for t in \u0026program {\n        println!(\"{}\", t);\n    }\n\n    let mut symtab = midend::symbol_table_from_program(program);\n\n    // println!(\"{}\", serde_json::to_string_pretty(\u0026symtab).unwrap());\n    println!(\"SYMTAB IR\");\n    symtab.print_ir();\n\n    symtab.assign_program_points();\n\n    generate_code(symtab);\n}\n","traces":[{"line":122,"address":[376642,376541,375840],"length":1,"stats":{"Line":0}},{"line":123,"address":[375847],"length":1,"stats":{"Line":0}},{"line":124,"address":[375899],"length":1,"stats":{"Line":0}},{"line":125,"address":[375962,376006],"length":1,"stats":{"Line":0}},{"line":127,"address":[376064,376129],"length":1,"stats":{"Line":0}},{"line":128,"address":[376550,376241],"length":1,"stats":{"Line":0}},{"line":131,"address":[376251],"length":1,"stats":{"Line":0}},{"line":134,"address":[376385,376322],"length":1,"stats":{"Line":0}},{"line":135,"address":[376412],"length":1,"stats":{"Line":0}},{"line":137,"address":[376427],"length":1,"stats":{"Line":0}},{"line":139,"address":[376434],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","block_args.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct BlockArgs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for BlockArgs\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, _to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        facts.gen_facts.clone()\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut super::Facts\u003cFact\u003e) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    if !block_facts.kill_facts.contains(read) {\n                        block_facts.gen_facts.insert(read.clone());\n                    }\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.kill_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(mut a: BTreeSet\u003cFact\u003e, b: \u0026BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e super::Facts\u003cFact\u003e {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":17,"address":[383246,383168],"length":1,"stats":{"Line":0}},{"line":18,"address":[383189],"length":1,"stats":{"Line":0}},{"line":21,"address":[384131,383280],"length":1,"stats":{"Line":0}},{"line":22,"address":[383314],"length":1,"stats":{"Line":0}},{"line":23,"address":[383443],"length":1,"stats":{"Line":0}},{"line":25,"address":[383500,383469],"length":1,"stats":{"Line":0}},{"line":26,"address":[383740,383577],"length":1,"stats":{"Line":0}},{"line":27,"address":[383805,384157],"length":1,"stats":{"Line":0}},{"line":28,"address":[384177],"length":1,"stats":{"Line":0}},{"line":31,"address":[384004,383841],"length":1,"stats":{"Line":0}},{"line":32,"address":[384119,384064],"length":1,"stats":{"Line":0}},{"line":38,"address":[384224,384496],"length":1,"stats":{"Line":0}},{"line":39,"address":[384316,384272],"length":1,"stats":{"Line":0}},{"line":40,"address":[384484,384419],"length":1,"stats":{"Line":0}},{"line":43,"address":[384441],"length":1,"stats":{"Line":0}},{"line":46,"address":[384528],"length":1,"stats":{"Line":0}},{"line":48,"address":[384560],"length":1,"stats":{"Line":0}},{"line":58,"address":[384640],"length":1,"stats":{"Line":0}},{"line":59,"address":[384645],"length":1,"stats":{"Line":0}},{"line":62,"address":[384656],"length":1,"stats":{"Line":0}},{"line":63,"address":[384673],"length":1,"stats":{"Line":0}},{"line":66,"address":[384720],"length":1,"stats":{"Line":0}},{"line":67,"address":[384728],"length":1,"stats":{"Line":0}},{"line":70,"address":[384736],"length":1,"stats":{"Line":0}},{"line":71,"address":[384744],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","block_depths.rs"],"content":"\npub struct BlockDepths\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","idfa_base.rs"],"content":"use std::{\n    collections::{BTreeSet, HashMap},\n    fmt::Display,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\npub enum IdfaAnalysisDirection {\n    Forward,\n    Backward,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct BlockFacts\u003cT\u003e {\n    pub in_facts: BTreeSet\u003cT\u003e,\n    pub out_facts: BTreeSet\u003cT\u003e,\n    pub gen_facts: BTreeSet\u003cT\u003e,\n    pub kill_facts: BTreeSet\u003cT\u003e,\n}\n\nimpl\u003cT\u003e BlockFacts\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        BlockFacts {\n            in_facts: BTreeSet::\u003cT\u003e::new(),\n            out_facts: BTreeSet::\u003cT\u003e::new(),\n            gen_facts: BTreeSet::\u003cT\u003e::new(),\n            kill_facts: BTreeSet::\u003cT\u003e::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    facts: HashMap\u003cusize, BlockFacts\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub fn new(n_blocks: usize) -\u003e Self {\n        Self {\n            facts: HashMap::with_capacity(n_blocks),\n        }\n    }\n    pub fn for_label(\u0026self, label: usize) -\u003e \u0026BlockFacts\u003cT\u003e {\n        self.facts.get(\u0026label).unwrap()\n    }\n\n    pub fn for_label_mut(\u0026mut self, label: usize) -\u003e \u0026mut BlockFacts\u003cT\u003e {\n        self.facts.entry(label).or_insert(BlockFacts::\u003cT\u003e::new())\n    }\n}\n\npub trait IdfaImplementor\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    fn f_transfer(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e);\n    fn f_meet(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self;\n    fn reanalyze(\u0026mut self);\n    fn take_facts(self) -\u003e Facts\u003cT\u003e;\n    fn facts(\u0026self) -\u003e \u0026Facts\u003cT\u003e;\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts\u003cT\u003e;\n}\n\n#[derive(Debug)]\npub struct Idfa\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub control_flow: \u0026'a ir::ControlFlow,\n    direction: IdfaAnalysisDirection,\n    last_facts: Facts\u003cT\u003e,\n    pub facts: Facts\u003cT\u003e,\n    f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n    f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n}\n\nimpl\u003c'a, T\u003e Idfa\u003c'a, T\u003e\nwhere\n    Facts\u003cT\u003e: PartialEq,\n    T: std::fmt::Debug + Display + Clone + Ord,\n{\n    fn store_facts_as_last(\u0026mut self) {\n        self.last_facts = self.facts.clone();\n    }\n\n    fn reached_fixpoint(\u0026mut self) -\u003e bool {\n        self.facts == self.last_facts\n    }\n\n    fn analyze_block_forwards\u003c'b\u003e(\u0026mut self, block: \u0026ir::BasicBlock) {\n        let label = block.label;\n        let mut new_in_facts = BTreeSet::\u003cT\u003e::new();\n\n        for predecessor in \u0026block.predecessors {\n            new_in_facts =\n                (self.f_meet)(new_in_facts, \u0026self.facts.for_label(*predecessor).out_facts);\n        }\n\n        self.facts.for_label_mut(label).in_facts = new_in_facts.clone();\n        let transferred = (self.f_transfer)(self.facts.for_label_mut(label), new_in_facts);\n        self.facts.for_label_mut(label).out_facts = transferred;\n    }\n\n    fn analyze_forward(\u0026mut self) {\n        let mut first_iteration = true;\n        while !self.reached_fixpoint() || first_iteration {\n            first_iteration = false;\n            self.store_facts_as_last();\n\n            for (_, block) in \u0026self.control_flow.blocks {\n                self.analyze_block_forwards(block);\n            }\n        }\n    }\n\n    fn analyze_backward(\u0026mut self) {\n        // let mut first_iteration = true;\n        // while !self.reached_fixpoint() || first_iteration {\n        unimplemented!();\n        // first_iteration = false;\n        // self.store_facts_as_last();\n        // }\n    }\n\n    pub fn analyze(\u0026mut self) {\n        (self.f_find_gen_kills)(self.control_flow, \u0026mut self.facts);\n        match self.direction {\n            IdfaAnalysisDirection::Forward =\u003e {\n                self.analyze_forward();\n            }\n            IdfaAnalysisDirection::Backward =\u003e {\n                self.analyze_backward();\n            }\n        }\n    }\n\n    pub fn new(\n        control_flow: \u0026'a ir::ControlFlow,\n        direction: IdfaAnalysisDirection,\n        f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n        f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n        f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    ) -\u003e Self {\n        let mut idfa = Self {\n            control_flow,\n            direction,\n            last_facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            f_find_gen_kills,\n            f_meet,\n            f_transfer,\n        };\n\n        idfa.analyze();\n\n        idfa\n    }\n}\n","traces":[{"line":23,"address":[573088,573372],"length":1,"stats":{"Line":0}},{"line":25,"address":[573110],"length":1,"stats":{"Line":0}},{"line":26,"address":[573120],"length":1,"stats":{"Line":0}},{"line":27,"address":[573166],"length":1,"stats":{"Line":0}},{"line":28,"address":[573209],"length":1,"stats":{"Line":0}},{"line":45,"address":[573392],"length":1,"stats":{"Line":0}},{"line":47,"address":[573410],"length":1,"stats":{"Line":0}},{"line":50,"address":[573456],"length":1,"stats":{"Line":0}},{"line":51,"address":[573470],"length":1,"stats":{"Line":0}},{"line":54,"address":[573504],"length":1,"stats":{"Line":0}},{"line":55,"address":[573530],"length":1,"stats":{"Line":0}},{"line":92,"address":[573663,573584],"length":1,"stats":{"Line":0}},{"line":93,"address":[573601,573694],"length":1,"stats":{"Line":0}},{"line":96,"address":[573728],"length":1,"stats":{"Line":0}},{"line":97,"address":[573736],"length":1,"stats":{"Line":0}},{"line":100,"address":[573760,574712,574900],"length":1,"stats":{"Line":0}},{"line":101,"address":[573793],"length":1,"stats":{"Line":0}},{"line":102,"address":[573842],"length":1,"stats":{"Line":0}},{"line":104,"address":[573865,574877,573922],"length":1,"stats":{"Line":0}},{"line":105,"address":[574830],"length":1,"stats":{"Line":0}},{"line":106,"address":[574890,574739,574030],"length":1,"stats":{"Line":0}},{"line":109,"address":[574116,574729],"length":1,"stats":{"Line":0}},{"line":110,"address":[574336],"length":1,"stats":{"Line":0}},{"line":111,"address":[574702,574435],"length":1,"stats":{"Line":0}},{"line":114,"address":[574928],"length":1,"stats":{"Line":0}},{"line":115,"address":[574945],"length":1,"stats":{"Line":0}},{"line":116,"address":[575019,574955],"length":1,"stats":{"Line":0}},{"line":117,"address":[574969],"length":1,"stats":{"Line":0}},{"line":118,"address":[574974],"length":1,"stats":{"Line":0}},{"line":120,"address":[575034,574984],"length":1,"stats":{"Line":0}},{"line":121,"address":[575104],"length":1,"stats":{"Line":0}},{"line":126,"address":[575120],"length":1,"stats":{"Line":0}},{"line":135,"address":[575168],"length":1,"stats":{"Line":0}},{"line":136,"address":[575185],"length":1,"stats":{"Line":0}},{"line":137,"address":[575203],"length":1,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[575239],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[575227],"length":1,"stats":{"Line":0}},{"line":147,"address":[575686,575264],"length":1,"stats":{"Line":0}},{"line":157,"address":[575356],"length":1,"stats":{"Line":0}},{"line":158,"address":[575382,575447],"length":1,"stats":{"Line":0}},{"line":164,"address":[575612],"length":1,"stats":{"Line":0}},{"line":166,"address":[575658],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","live_vars.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base::{self, IdfaImplementor};\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct LiveVars\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for LiveVars\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = facts.gen_facts.clone();\n\n        for fact in \u0026to_transfer {\n            if !facts.kill_facts.contains(fact) {\n                transferred.insert(fact.clone());\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":16,"address":[201260,200880],"length":1,"stats":{"Line":0}},{"line":17,"address":[200915],"length":1,"stats":{"Line":0}},{"line":19,"address":[201019,200978],"length":1,"stats":{"Line":0}},{"line":20,"address":[201132,201205],"length":1,"stats":{"Line":0}},{"line":21,"address":[201228],"length":1,"stats":{"Line":0}},{"line":25,"address":[201157],"length":1,"stats":{"Line":0}},{"line":28,"address":[201296,202149],"length":1,"stats":{"Line":0}},{"line":29,"address":[201330],"length":1,"stats":{"Line":0}},{"line":30,"address":[201459],"length":1,"stats":{"Line":0}},{"line":32,"address":[201516,201485],"length":1,"stats":{"Line":0}},{"line":33,"address":[201756,201593],"length":1,"stats":{"Line":0}},{"line":34,"address":[201816,202184],"length":1,"stats":{"Line":0}},{"line":36,"address":[202024,201861],"length":1,"stats":{"Line":0}},{"line":37,"address":[202137,202084],"length":1,"stats":{"Line":0}},{"line":43,"address":[202480,202208],"length":1,"stats":{"Line":0}},{"line":47,"address":[202256,202300],"length":1,"stats":{"Line":0}},{"line":48,"address":[202468,202403],"length":1,"stats":{"Line":0}},{"line":51,"address":[202425],"length":1,"stats":{"Line":0}},{"line":54,"address":[202512],"length":1,"stats":{"Line":0}},{"line":56,"address":[202544],"length":1,"stats":{"Line":0}},{"line":66,"address":[202624],"length":1,"stats":{"Line":0}},{"line":67,"address":[202629],"length":1,"stats":{"Line":0}},{"line":70,"address":[202640],"length":1,"stats":{"Line":0}},{"line":71,"address":[202657],"length":1,"stats":{"Line":0}},{"line":74,"address":[202704],"length":1,"stats":{"Line":0}},{"line":75,"address":[202712],"length":1,"stats":{"Line":0}},{"line":78,"address":[202720],"length":1,"stats":{"Line":0}},{"line":79,"address":[202728],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa","reaching_defs.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct ReachingDefs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for ReachingDefs\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = BTreeSet::\u003cFact\u003e::new();\n\n        for gen_fact in \u0026facts.gen_facts {\n            if !facts.kill_facts.contains(gen_fact) {\n                transferred.insert(gen_fact.clone());\n            }\n        }\n\n        for in_fact in \u0026facts.in_facts {\n            if !facts.kill_facts.contains(in_fact) {\n                transferred.insert(in_fact.clone());\n            }\n        }\n\n        for transfer_fact in to_transfer {\n            if !facts.kill_facts.contains(\u0026transfer_fact) {\n                transferred.insert(transfer_fact);\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        //TODO: need to be able to possibly act on function arguments for gen/kill\n        // e.g. reaching defs on function arguments\n\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n\nimpl\u003c'a\u003e ReachingDefs\u003c'a\u003e\n// TODO: supertrait?\n{\n    pub fn print(\u0026self) {\n        for label in self.idfa.control_flow.blocks.keys() {\n            let facts = self.idfa.facts.for_label(*label);\n            println!(\"{}:\", label);\n\n            print!(\"\\tGEN:\");\n            for gen_fact in \u0026facts.gen_facts {\n                print!(\"{} \", gen_fact);\n            }\n            println!();\n\n            print!(\"\\tKILL:\");\n            for kill_fact in \u0026facts.kill_facts {\n                print!(\"{} \", kill_fact);\n            }\n            println!();\n\n            print!(\"\\tIN:\");\n            for in_fact in \u0026facts.in_facts {\n                print!(\"{} \", in_fact);\n            }\n            println!();\n\n            print!(\"\\tOUT:\");\n            for out_fact in \u0026facts.out_facts {\n                print!(\"{} \", out_fact);\n            }\n            println!();\n        }\n    }\n}\n","traces":[{"line":17,"address":[188048,189006,189133],"length":1,"stats":{"Line":0}},{"line":18,"address":[188083],"length":1,"stats":{"Line":0}},{"line":20,"address":[188165,188215],"length":1,"stats":{"Line":0}},{"line":21,"address":[189078,188328],"length":1,"stats":{"Line":0}},{"line":22,"address":[189101],"length":1,"stats":{"Line":0}},{"line":26,"address":[188359],"length":1,"stats":{"Line":0}},{"line":27,"address":[189019,188482],"length":1,"stats":{"Line":0}},{"line":28,"address":[189042],"length":1,"stats":{"Line":0}},{"line":32,"address":[188968,188648,188505],"length":1,"stats":{"Line":0}},{"line":33,"address":[188737,188864],"length":1,"stats":{"Line":0}},{"line":34,"address":[188958,188870],"length":1,"stats":{"Line":0}},{"line":38,"address":[188785],"length":1,"stats":{"Line":0}},{"line":41,"address":[189168,190021],"length":1,"stats":{"Line":0}},{"line":45,"address":[189202],"length":1,"stats":{"Line":0}},{"line":46,"address":[189331],"length":1,"stats":{"Line":0}},{"line":48,"address":[189357,189388],"length":1,"stats":{"Line":0}},{"line":49,"address":[189465,189628],"length":1,"stats":{"Line":0}},{"line":50,"address":[189688,190056],"length":1,"stats":{"Line":0}},{"line":52,"address":[189896,189733],"length":1,"stats":{"Line":0}},{"line":53,"address":[190009,189956],"length":1,"stats":{"Line":0}},{"line":59,"address":[190352,190080],"length":1,"stats":{"Line":0}},{"line":63,"address":[190172,190128],"length":1,"stats":{"Line":0}},{"line":64,"address":[190275,190340],"length":1,"stats":{"Line":0}},{"line":67,"address":[190297],"length":1,"stats":{"Line":0}},{"line":70,"address":[190384],"length":1,"stats":{"Line":0}},{"line":72,"address":[190416],"length":1,"stats":{"Line":0}},{"line":82,"address":[190496],"length":1,"stats":{"Line":0}},{"line":83,"address":[190501],"length":1,"stats":{"Line":0}},{"line":86,"address":[190512],"length":1,"stats":{"Line":0}},{"line":87,"address":[190529],"length":1,"stats":{"Line":0}},{"line":90,"address":[190576],"length":1,"stats":{"Line":0}},{"line":91,"address":[190584],"length":1,"stats":{"Line":0}},{"line":94,"address":[190592],"length":1,"stats":{"Line":0}},{"line":95,"address":[190600],"length":1,"stats":{"Line":0}},{"line":102,"address":[190608],"length":1,"stats":{"Line":0}},{"line":103,"address":[190628],"length":1,"stats":{"Line":0}},{"line":104,"address":[190750],"length":1,"stats":{"Line":0}},{"line":105,"address":[190782],"length":1,"stats":{"Line":0}},{"line":107,"address":[190878],"length":1,"stats":{"Line":0}},{"line":108,"address":[190969,190916],"length":1,"stats":{"Line":0}},{"line":109,"address":[191037],"length":1,"stats":{"Line":0}},{"line":111,"address":[191138],"length":1,"stats":{"Line":0}},{"line":113,"address":[191172],"length":1,"stats":{"Line":0}},{"line":114,"address":[191210],"length":1,"stats":{"Line":0}},{"line":115,"address":[191321],"length":1,"stats":{"Line":0}},{"line":117,"address":[191422],"length":1,"stats":{"Line":0}},{"line":119,"address":[191456],"length":1,"stats":{"Line":0}},{"line":120,"address":[191494],"length":1,"stats":{"Line":0}},{"line":121,"address":[191601],"length":1,"stats":{"Line":0}},{"line":123,"address":[191702],"length":1,"stats":{"Line":0}},{"line":125,"address":[191736],"length":1,"stats":{"Line":0}},{"line":126,"address":[191774],"length":1,"stats":{"Line":0}},{"line":127,"address":[191885],"length":1,"stats":{"Line":0}},{"line":129,"address":[191986],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","idfa.rs"],"content":"pub mod block_args;\nmod idfa_base;\npub mod live_vars;\npub mod reaching_defs;\n\npub use block_args::BlockArgs;\npub use idfa_base::Facts;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","control_flow.rs"],"content":"use crate::{\n    frontend::sourceloc::SourceLoc,\n    hashmap_ooo_iter::{HashMapOOOIter, HashMapOOOIterMut},\n};\n\nuse super::ir;\nuse serde::Serialize;\nuse std::{\n    collections::{HashMap, HashSet, VecDeque},\n    fmt::Debug,\n    usize,\n};\n\n/*\n    A ControlFlow represents the notion of ownership over basic blocks. At the end of linearization of a section of code,\n    all relevant basic blocks will be owned by a single control flow. During linearization control flows can branch\n    correspondingly with actual branches in the code, as they are linarized. Each branch gets its own control flow,\n    which owns only the blocks relevant to the contents of branch. When the linearization of each branch is complete,\n    its control flow is merged back to the one from which it was branched. The original brancher then takes ownership\n    of all blocks of the branchee.\n*/\n\n#[derive(Debug, Serialize)]\npub struct ControlFlow {\n    pub blocks: HashMap\u003cusize, ir::BasicBlock\u003e,\n    pub max_block: usize,\n}\n\nimpl ControlFlow {\n    pub fn new() -\u003e Self {\n        let mut starter_blocks = HashMap::\u003cusize, ir::BasicBlock\u003e::new();\n        starter_blocks.insert(0, ir::BasicBlock::new(0));\n        starter_blocks.insert(1, ir::BasicBlock::new(1));\n        ControlFlow {\n            blocks: starter_blocks,\n            max_block: 1,\n        }\n    }\n\n    pub fn block_for_label(\u0026self, label: \u0026usize) -\u003e \u0026ir::BasicBlock {\n        self.blocks.get(label).unwrap()\n    }\n\n    fn block_mut_for_label(\u0026mut self, label: usize) -\u003e \u0026mut ir::BasicBlock {\n        self.blocks\n            .entry(label)\n            .or_insert(ir::BasicBlock::new(label))\n    }\n\n    pub fn next_block(\u0026mut self) -\u003e usize {\n        self.max_block += 1;\n        self.max_block\n    }\n\n    // appends the given statement to the block with the label provided\n    // returns: (Option\u003cusize\u003e, Option\u003cusize\u003e) referring to (if the statement is a branch):\n    // block targeted by branch\n    // block control flow ends up in if the branch is not taken (conditional branches only)\n    // retrurns an option to a reference to the field containing the destination label of the false jump\n    // iff the statement was a conditional jump which forced the end of the block\n    pub fn append_statement_to_block(\n        \u0026mut self,\n        statement: ir::IrLine,\n        label: usize,\n    ) -\u003e (Option\u003cusize\u003e, Option\u003cusize\u003e) {\n        self.append_statement_to_block_raw(statement.clone(), label);\n\n        match \u0026statement.operation {\n            ir::Operations::Jump(jump) =\u003e {\n                let target = jump.destination_block;\n                match \u0026jump.condition {\n                    ir::JumpCondition::Unconditional =\u003e (Some(target), None),\n                    _ =\u003e {\n                        let false_label = self.next_block();\n                        let block_exit = ir::IrLine::new_jump(\n                            SourceLoc::none(),\n                            false_label,\n                            ir::JumpCondition::Unconditional,\n                        );\n                        self.append_statement_to_block_raw(block_exit, label);\n                        (Some(target), Some(false_label))\n                    }\n                }\n            }\n            _ =\u003e (None, None),\n        }\n    }\n\n    fn append_statement_to_block_raw(\u0026mut self, statement: ir::IrLine, label: usize) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(operands) =\u003e {\n                let target_block = operands.destination_block;\n\n                self.block_mut_for_label(target_block)\n                    .predecessors\n                    .insert(label);\n                self.block_mut_for_label(label)\n                    .successors\n                    .insert(target_block);\n            }\n            _ =\u003e {}\n        };\n\n        self.block_mut_for_label(label).statements.push(statement);\n    }\n\n    pub fn to_graphviz(\u0026self) {\n        print!(\"digraph {{fontname=\\\"consolas\\\"; node[shape=box; fontname=\\\"consolas\\\"; nojustify=true]; splines=ortho;\");\n        for block in self.blocks.values() {\n            let mut block_arg_string = String::new();\n            for arg in \u0026block.arguments {\n                block_arg_string += \u0026format!(\"{} \", arg);\n            }\n\n            let mut block_string =\n                String::from(format!(\"Block {}({})\\n\", block.label, block_arg_string));\n            for statement in \u0026block.statements {\n                let stmt_str = \u0026String::from(format!(\"{}\\\\l\", statement)).replace(\"\\\"\", \"\\\\\\\"\");\n                block_string += stmt_str;\n            }\n\n            println!(\"{}[label=\\\"{}\\\\l\\\"]; \", block.label, block_string);\n\n            for successor in \u0026block.successors {\n                print!(\"{}-\u003e{};\", block.label, successor);\n            }\n        }\n\n        println!(\"}}\");\n    }\n}\n\npub struct ControlFlowIntoIter\u003cT\u003e {\n    postorder_stack: VecDeque\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for ControlFlowIntoIter\u003cT\u003e {\n    type Item = T;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_back()\n    }\n}\n\n// TODO: are the postorder and reverse postorder named opposite right now? Need to actually check this...\nimpl ControlFlow {\n    fn generate_postorder_stack(\u0026self) -\u003e Vec\u003cusize\u003e {\n        let mut postorder_stack = Vec::\u003cusize\u003e::new();\n        postorder_stack.clear();\n        let mut visited = HashSet::\u003cusize\u003e::new();\n\n        let mut dfs_stack = Vec::\u003cusize\u003e::new();\n        dfs_stack.push(0);\n\n        // go until done\n        while dfs_stack.len() \u003e 0 {\n            match dfs_stack.pop() {\n                Some(label) =\u003e {\n                    // only visit once\n                    if !visited.contains(\u0026label) {\n                        visited.insert(label);\n\n                        postorder_stack.push(label);\n\n                        for successor in \u0026self.block_for_label(\u0026label).successors {\n                            dfs_stack.push(*successor);\n                        }\n                    }\n                }\n                None =\u003e {}\n            }\n        }\n        postorder_stack\n    }\n\n    pub fn blocks_postorder(\u0026self) -\u003e HashMapOOOIter\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIter::new(\u0026self.blocks, postorder_stack)\n    }\n\n    pub fn blocks_postorder_mut(\u0026mut self) -\u003e HashMapOOOIterMut\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIterMut::new(\u0026mut self.blocks, postorder_stack)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::midend::ir::*;\n\n    #[test]\n    fn starter_blocks() {\n        let cf = ControlFlow::new();\n\n        assert!(cf.blocks.len() == 2);\n        assert!(cf.max_block == 1);\n    }\n\n    #[test]\n    fn get_block_for_label() {\n        let mut cf = ControlFlow::new();\n\n        assert_eq!(cf.block_for_label(\u00260).label, 0);\n\n        assert_eq!(cf.block_mut_for_label(0).label, 0);\n        assert_eq!(cf.block_mut_for_label(999).label, 999);\n    }\n\n    #[test]\n    fn append_statement_to_block() {\n        let mut cf = ControlFlow::new();\n\n        let assignment = IrLine::new_assignment(\n            SourceLoc::none(),\n            Operand::new_as_variable(\"dest\".into()),\n            Operand::new_as_variable(\"source\".into()),\n        );\n        assert_eq!(cf.append_statement_to_block(assignment, 0), (None, None));\n    }\n\n    #[test]\n    fn append_unconditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(SourceLoc::none(), 1, JumpCondition::Unconditional);\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), None));\n    }\n\n    #[test]\n    fn append_conditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a\".into()),\n                b: Operand::new_as_variable(\"eq_b\".into()),\n            }),\n        );\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), Some(2)));\n\n        let second_jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a2\".into()),\n                b: Operand::new_as_variable(\"eq_b2\".into()),\n            }),\n        );\n        assert_eq!(\n            cf.append_statement_to_block(second_jump, 0),\n            (Some(1), Some(3))\n        );\n    }\n}\n","traces":[{"line":30,"address":[424664,424400],"length":1,"stats":{"Line":1}},{"line":31,"address":[424422],"length":1,"stats":{"Line":1}},{"line":32,"address":[424505,424439],"length":1,"stats":{"Line":4}},{"line":33,"address":[424537],"length":1,"stats":{"Line":1}},{"line":40,"address":[424688],"length":1,"stats":{"Line":1}},{"line":41,"address":[424702],"length":1,"stats":{"Line":1}},{"line":44,"address":[424736],"length":1,"stats":{"Line":1}},{"line":45,"address":[424769,424793],"length":1,"stats":{"Line":2}},{"line":47,"address":[424783],"length":1,"stats":{"Line":1}},{"line":50,"address":[424816],"length":1,"stats":{"Line":1}},{"line":51,"address":[424829,424869],"length":1,"stats":{"Line":1}},{"line":52,"address":[424860],"length":1,"stats":{"Line":1}},{"line":61,"address":[425517,424896],"length":1,"stats":{"Line":1}},{"line":66,"address":[424957,425016],"length":1,"stats":{"Line":3}},{"line":68,"address":[425028],"length":1,"stats":{"Line":1}},{"line":69,"address":[425059],"length":1,"stats":{"Line":1}},{"line":70,"address":[425067],"length":1,"stats":{"Line":2}},{"line":71,"address":[425087],"length":1,"stats":{"Line":2}},{"line":72,"address":[425186],"length":1,"stats":{"Line":1}},{"line":74,"address":[425312,425272],"length":1,"stats":{"Line":2}},{"line":76,"address":[425320],"length":1,"stats":{"Line":1}},{"line":78,"address":[425350],"length":1,"stats":{"Line":1}},{"line":80,"address":[425403],"length":1,"stats":{"Line":1}},{"line":81,"address":[425425],"length":1,"stats":{"Line":1}},{"line":85,"address":[425103],"length":1,"stats":{"Line":1}},{"line":89,"address":[425552,425881,425906],"length":1,"stats":{"Line":2}},{"line":90,"address":[425590],"length":1,"stats":{"Line":1}},{"line":91,"address":[425642],"length":1,"stats":{"Line":2}},{"line":92,"address":[425650],"length":1,"stats":{"Line":2}},{"line":94,"address":[425670,425755],"length":1,"stats":{"Line":4}},{"line":97,"address":[425776],"length":1,"stats":{"Line":2}},{"line":104,"address":[425819,425692],"length":1,"stats":{"Line":2}},{"line":107,"address":[427584,425920,427805],"length":1,"stats":{"Line":0}},{"line":108,"address":[425940],"length":1,"stats":{"Line":0}},{"line":109,"address":[425973],"length":1,"stats":{"Line":0}},{"line":110,"address":[426114],"length":1,"stats":{"Line":0}},{"line":111,"address":[426124,426229],"length":1,"stats":{"Line":0}},{"line":112,"address":[427593,426351],"length":1,"stats":{"Line":0}},{"line":115,"address":[426366],"length":1,"stats":{"Line":0}},{"line":117,"address":[426623,426552],"length":1,"stats":{"Line":0}},{"line":118,"address":[426735,427190],"length":1,"stats":{"Line":0}},{"line":119,"address":[427520],"length":1,"stats":{"Line":0}},{"line":122,"address":[426750],"length":1,"stats":{"Line":0}},{"line":124,"address":[426886],"length":1,"stats":{"Line":0}},{"line":125,"address":[427093,427016],"length":1,"stats":{"Line":0}},{"line":129,"address":[426143],"length":1,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[428527,427824],"length":1,"stats":{"Line":0}},{"line":148,"address":[427854],"length":1,"stats":{"Line":0}},{"line":149,"address":[427890],"length":1,"stats":{"Line":0}},{"line":150,"address":[427943],"length":1,"stats":{"Line":0}},{"line":152,"address":[427958],"length":1,"stats":{"Line":0}},{"line":153,"address":[428062,427999],"length":1,"stats":{"Line":0}},{"line":156,"address":[428072],"length":1,"stats":{"Line":0}},{"line":157,"address":[428208,428148],"length":1,"stats":{"Line":0}},{"line":158,"address":[428242],"length":1,"stats":{"Line":0}},{"line":160,"address":[428271],"length":1,"stats":{"Line":0}},{"line":161,"address":[428296],"length":1,"stats":{"Line":0}},{"line":163,"address":[428316],"length":1,"stats":{"Line":0}},{"line":165,"address":[428356],"length":1,"stats":{"Line":0}},{"line":166,"address":[428500],"length":1,"stats":{"Line":0}},{"line":173,"address":[428100],"length":1,"stats":{"Line":0}},{"line":176,"address":[428576],"length":1,"stats":{"Line":0}},{"line":177,"address":[428599],"length":1,"stats":{"Line":0}},{"line":179,"address":[428618],"length":1,"stats":{"Line":0}},{"line":182,"address":[428640],"length":1,"stats":{"Line":0}},{"line":183,"address":[428663],"length":1,"stats":{"Line":0}},{"line":185,"address":[428682],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":69},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","operands.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::{linearizer, types::Type};\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub struct OperandName {\n    pub base_name: String,\n    pub ssa_number: Option\u003cusize\u003e,\n}\n\nimpl PartialEq for OperandName {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        (self.base_name == other.base_name) \u0026\u0026 (self.ssa_number == other.ssa_number)\n    }\n}\n\nimpl Eq for OperandName {}\n\nimpl PartialOrd for OperandName {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        Some(\n            self.base_name\n                .cmp(\u0026other.base_name)\n                .then(match self.ssa_number {\n                    Some(self_ssa_number) =\u003e match other.ssa_number {\n                        Some(other_ssa_number) =\u003e self_ssa_number.cmp(\u0026other_ssa_number),\n                        None =\u003e std::cmp::Ordering::Greater,\n                    },\n                    None =\u003e match other.ssa_number {\n                        Some(_) =\u003e std::cmp::Ordering::Less,\n                        None =\u003e std::cmp::Ordering::Equal,\n                    },\n                }),\n        )\n    }\n}\n\nimpl Ord for OperandName {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Display for OperandName {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self.ssa_number {\n            Some(number) =\u003e {\n                write!(f, \"{}.{}\", self.base_name, number)\n            }\n            None =\u003e write!(f, \"{}\", self.base_name),\n        }\n    }\n}\n\nimpl OperandName {\n    pub fn new_basic(base_name: String) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: None,\n        }\n    }\n\n    fn new_ssa(base_name: String, ssa_number: usize) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: Some(ssa_number),\n        }\n    }\n\n    pub fn into_non_ssa(mut self) -\u003e Self {\n        self.ssa_number = None;\n        self\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub enum Operand {\n    Variable(OperandName),\n    Temporary(OperandName),\n    UnsignedDecimalConstant(usize),\n}\n\nimpl Display for Operand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Variable(name) =\u003e {\n                // write!(f, \"[V {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::Temporary(name) =\u003e {\n                // write!(f, \"[T {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::UnsignedDecimalConstant(value) =\u003e {\n                // write!(f, \"[C {}]\", value)\n                write!(f, \"{}\", value)\n            }\n        }\n    }\n}\n\nimpl PartialEq for Operand {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.cmp(other) == std::cmp::Ordering::Equal\n    }\n}\n\nimpl Eq for Operand {}\n\nimpl PartialOrd for Operand {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        match (self, other) {\n            (Operand::Variable(var_self), Operand::Variable(var_other)) =\u003e {\n                Some(var_self.cmp(var_other))\n            }\n            (Operand::Temporary(temp_self), Operand::Temporary(temp_other)) =\u003e {\n                Some(temp_self.cmp(temp_other))\n            }\n            (\n                Operand::UnsignedDecimalConstant(value_self),\n                Operand::UnsignedDecimalConstant(value_other),\n            ) =\u003e Some(value_self.cmp(value_other)),\n            (_, _) =\u003e None,\n        }\n    }\n}\n\nimpl Ord for Operand {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        let partial_result = self.partial_cmp(other);\n\n        match partial_result {\n            Some(ordering) =\u003e ordering,\n            None =\u003e match (self, other) {\n                (Operand::Variable(_), Operand::Temporary(_)) =\u003e std::cmp::Ordering::Greater,\n                (Operand::Variable(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::Temporary(_), Operand::Variable(_)) =\u003e std::cmp::Ordering::Less,\n                (Operand::Temporary(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Variable(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Temporary(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n\n                (Operand::Variable(_), Operand::Variable(_))\n                | (Operand::Temporary(_), Operand::Temporary(_))\n                | (Operand::UnsignedDecimalConstant(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    panic!(\"Non-covered case in Operand::cmp\")\n                }\n            },\n        }\n    }\n}\n\nimpl Operand {\n    pub fn new_as_variable(identifier: String) -\u003e Self {\n        Operand::Variable(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_temporary(identifier: String) -\u003e Self {\n        Operand::Temporary(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_unsigned_decimal_constant(constant: usize) -\u003e Self {\n        Operand::UnsignedDecimalConstant(constant)\n    }\n\n    pub fn type_\u003c'a\u003e(\u0026self, context: \u0026'a linearizer::walkcontext::WalkContext) -\u003e \u0026'a Type {\n        match self {\n            Operand::Variable(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::Temporary(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::UnsignedDecimalConstant(value) =\u003e {\n                if *value \u003e (u32::MAX as usize) {\n                    \u0026Type::U64\n                } else if *value \u003e (u16::MAX as usize) {\n                    \u0026Type::U32\n                } else if *value \u003e (u8::MAX as usize) {\n                    \u0026Type::U16\n                } else {\n                    \u0026Type::U8\n                }\n            }\n        }\n    }\n\n    pub fn get_name(\u0026self) -\u003e Option\u003c\u0026OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n\n    pub fn get_name_mut(\u0026mut self) -\u003e Option\u003c\u0026mut OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n}\n\n/*\n groupings of operands\n*/\n\n#[derive(Debug, Serialize, Clone)]\npub struct DualSourceOperands {\n    pub a: Operand,\n    pub b: Operand,\n}\n\nimpl DualSourceOperands {\n    pub fn new(a: Operand, b: Operand) -\u003e Self {\n        DualSourceOperands { a, b }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct BinaryArithmeticOperands {\n    pub destination: Operand,\n    pub sources: DualSourceOperands,\n}\n\nimpl BinaryArithmeticOperands {\n    pub fn from(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryArithmeticOperands {\n            destination,\n            sources: DualSourceOperands::new(source_a, source_b),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct SourceDestOperands {\n    pub destination: Operand,\n    pub source: Operand,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub enum JumpCondition {\n    Unconditional,\n    Eq(DualSourceOperands),\n    NE(DualSourceOperands),\n    GT(DualSourceOperands),\n    LT(DualSourceOperands),\n    GE(DualSourceOperands),\n    LE(DualSourceOperands),\n}\n\nimpl Display for JumpCondition {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Unconditional =\u003e {\n                write!(f, \"jmp\")\n            }\n            Self::Eq(operands) =\u003e {\n                write!(f, \"jeq({}, {})\", operands.a, operands.b)\n            }\n            Self::NE(operands) =\u003e {\n                write!(f, \"jne({}, {})\", operands.a, operands.b)\n            }\n            Self::LT(operands) =\u003e {\n                write!(f, \"jl({}, {})\", operands.a, operands.b)\n            }\n            Self::GT(operands) =\u003e {\n                write!(f, \"jg({}, {})\", operands.a, operands.b)\n            }\n            Self::LE(operands) =\u003e {\n                write!(f, \"jle({}, {})\", operands.a, operands.b)\n            }\n            Self::GE(operands) =\u003e {\n                write!(f, \"jge({}, {})\", operands.a, operands.b)\n            }\n        }\n    }\n}\n\npub type OrderedArgumentList = Vec\u003cOperand\u003e;\n\nfn arg_list_to_string(args: \u0026OrderedArgumentList) -\u003e String {\n    let mut arg_string = String::new();\n    for arg in args {\n        if arg_string.len() \u003e 0 {\n            arg_string += \u0026\",\";\n        }\n\n        arg_string += \u0026format!(\"{}\", arg);\n    }\n    arg_string\n}\n\n/// ## Function Call Operands\n#[derive(Debug, Serialize, Clone)]\npub struct FunctionCallOperands {\n    pub function_name: String,\n    pub arguments: OrderedArgumentList,\n    pub return_value_to: Option\u003cOperand\u003e,\n}\n\nimpl Display for FunctionCallOperands {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{}({})\",\n            self.function_name,\n            arg_list_to_string(\u0026self.arguments)\n        )\n    }\n}\n\nimpl FunctionCallOperands {\n    pub fn new(\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self {\n            function_name: name.into(),\n            arguments,\n            return_value_to,\n        }\n    }\n}\n\n/// ## Method Call Operands\n#[derive(Debug, Serialize, Clone)]\npub struct MethodCallOperands {\n    pub receiver: Operand,\n    pub call: FunctionCallOperands,\n}\n\nimpl Display for MethodCallOperands {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}.{}\", self.receiver, self.call)\n    }\n}\n\nimpl MethodCallOperands {\n    pub fn new(\n        receiver: Operand,\n        method_name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self {\n            receiver,\n            call: FunctionCallOperands::new(method_name, arguments, return_value_to),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct FieldReadOperands {\n    pub receiver: Operand,\n    pub field_name: String,\n    pub destination: Operand,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct FieldWriteOperands {\n    pub receiver: Operand,\n    pub field_name: String,\n    pub source: Operand,\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::midend::ir::*;\n\n    #[test]\n    fn operand_name_ord() {\n        // non-ssa operand names\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"b\".into())),\n            Ordering::Less\n        );\n\n        // ssa operand names\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 4)),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 5)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"b\".into(), 4)),\n            Ordering::Less\n        );\n\n        // mixed ssa and non-ssa\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_ssa(\"a\".into(), 1)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 1).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn operand_name_into_non_ssa() {\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 123).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n    }\n\n    #[test]\n    fn operand_eq() {\n        // variable against other types\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // temporary against other types\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // unsigned decimal constant against other types\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n    }\n\n    #[test]\n    fn operand_get_name() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name(),\n            None\n        );\n    }\n\n    #[test]\n    fn operand_get_name_mut() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name_mut(),\n            None\n        );\n    }\n}\n","traces":[{"line":14,"address":[326672],"length":1,"stats":{"Line":3}},{"line":15,"address":[326695],"length":1,"stats":{"Line":3}},{"line":22,"address":[326752],"length":1,"stats":{"Line":1}},{"line":24,"address":[326783,326775,326864],"length":1,"stats":{"Line":3}},{"line":25,"address":[326779],"length":1,"stats":{"Line":1}},{"line":26,"address":[326797],"length":1,"stats":{"Line":1}},{"line":27,"address":[326815],"length":1,"stats":{"Line":1}},{"line":28,"address":[326894],"length":1,"stats":{"Line":1}},{"line":29,"address":[326924],"length":1,"stats":{"Line":1}},{"line":31,"address":[326839],"length":1,"stats":{"Line":1}},{"line":32,"address":[326848],"length":1,"stats":{"Line":1}},{"line":33,"address":[326855],"length":1,"stats":{"Line":1}},{"line":41,"address":[326944],"length":1,"stats":{"Line":1}},{"line":42,"address":[326958],"length":1,"stats":{"Line":1}},{"line":47,"address":[326992],"length":1,"stats":{"Line":1}},{"line":48,"address":[327025],"length":1,"stats":{"Line":1}},{"line":49,"address":[327043],"length":1,"stats":{"Line":0}},{"line":50,"address":[327052],"length":1,"stats":{"Line":0}},{"line":52,"address":[327185],"length":1,"stats":{"Line":1}},{"line":58,"address":[327312],"length":1,"stats":{"Line":3}},{"line":65,"address":[327376],"length":1,"stats":{"Line":1}},{"line":68,"address":[327384],"length":1,"stats":{"Line":1}},{"line":72,"address":[327440],"length":1,"stats":{"Line":1}},{"line":73,"address":[327451],"length":1,"stats":{"Line":1}},{"line":74,"address":[327477],"length":1,"stats":{"Line":1}},{"line":86,"address":[327504],"length":1,"stats":{"Line":0}},{"line":87,"address":[327536],"length":1,"stats":{"Line":0}},{"line":88,"address":[327575],"length":1,"stats":{"Line":0}},{"line":90,"address":[327584],"length":1,"stats":{"Line":0}},{"line":92,"address":[327672],"length":1,"stats":{"Line":0}},{"line":94,"address":[327681],"length":1,"stats":{"Line":0}},{"line":96,"address":[327790],"length":1,"stats":{"Line":0}},{"line":98,"address":[327802],"length":1,"stats":{"Line":0}},{"line":105,"address":[327936],"length":1,"stats":{"Line":1}},{"line":106,"address":[327950],"length":1,"stats":{"Line":1}},{"line":113,"address":[328043,327984],"length":1,"stats":{"Line":1}},{"line":114,"address":[327998,328045],"length":1,"stats":{"Line":2}},{"line":115,"address":[328084],"length":1,"stats":{"Line":1}},{"line":116,"address":[328112],"length":1,"stats":{"Line":1}},{"line":118,"address":[328137],"length":1,"stats":{"Line":1}},{"line":119,"address":[328165],"length":1,"stats":{"Line":1}},{"line":121,"address":[328190],"length":1,"stats":{"Line":1}},{"line":125,"address":[328123],"length":1,"stats":{"Line":1}},{"line":131,"address":[328224],"length":1,"stats":{"Line":1}},{"line":132,"address":[328257],"length":1,"stats":{"Line":1}},{"line":134,"address":[328266],"length":1,"stats":{"Line":1}},{"line":135,"address":[328290],"length":1,"stats":{"Line":1}},{"line":136,"address":[328320],"length":1,"stats":{"Line":1}},{"line":137,"address":[328511],"length":1,"stats":{"Line":1}},{"line":139,"address":[328518],"length":1,"stats":{"Line":1}},{"line":141,"address":[328535],"length":1,"stats":{"Line":1}},{"line":143,"address":[328542],"length":1,"stats":{"Line":1}},{"line":146,"address":[328549],"length":1,"stats":{"Line":1}},{"line":149,"address":[328556],"length":1,"stats":{"Line":1}},{"line":155,"address":[328470],"length":1,"stats":{"Line":0}},{"line":163,"address":[328576],"length":1,"stats":{"Line":2}},{"line":164,"address":[328589],"length":1,"stats":{"Line":2}},{"line":167,"address":[328656],"length":1,"stats":{"Line":2}},{"line":168,"address":[328669],"length":1,"stats":{"Line":2}},{"line":171,"address":[328736],"length":1,"stats":{"Line":1}},{"line":172,"address":[328744],"length":1,"stats":{"Line":1}},{"line":175,"address":[328768,329392],"length":1,"stats":{"Line":1}},{"line":176,"address":[328801,329367],"length":1,"stats":{"Line":2}},{"line":177,"address":[328862,329245,329290,329348,328876],"length":1,"stats":{"Line":0}},{"line":178,"address":[328871],"length":1,"stats":{"Line":0}},{"line":179,"address":[328907,329044,329385,329282],"length":1,"stats":{"Line":0}},{"line":181,"address":[329668,328947,328927,329727,329620],"length":1,"stats":{"Line":0}},{"line":182,"address":[328939],"length":1,"stats":{"Line":0}},{"line":183,"address":[329660,329759,328984,329422],"length":1,"stats":{"Line":0}},{"line":185,"address":[328999],"length":1,"stats":{"Line":1}},{"line":186,"address":[329864,329019,329797],"length":1,"stats":{"Line":2}},{"line":187,"address":[329782],"length":1,"stats":{"Line":0}},{"line":188,"address":[329771,329830],"length":1,"stats":{"Line":1}},{"line":189,"address":[329815],"length":1,"stats":{"Line":0}},{"line":190,"address":[329804,329847],"length":1,"stats":{"Line":2}},{"line":191,"address":[329849],"length":1,"stats":{"Line":0}},{"line":193,"address":[329832],"length":1,"stats":{"Line":1}},{"line":199,"address":[329888],"length":1,"stats":{"Line":1}},{"line":200,"address":[329898],"length":1,"stats":{"Line":1}},{"line":201,"address":[329935],"length":1,"stats":{"Line":1}},{"line":202,"address":[329956],"length":1,"stats":{"Line":1}},{"line":203,"address":[329972],"length":1,"stats":{"Line":1}},{"line":207,"address":[330000],"length":1,"stats":{"Line":1}},{"line":208,"address":[330010],"length":1,"stats":{"Line":1}},{"line":209,"address":[330047],"length":1,"stats":{"Line":1}},{"line":210,"address":[330068],"length":1,"stats":{"Line":1}},{"line":211,"address":[330084],"length":1,"stats":{"Line":1}},{"line":227,"address":[330112],"length":1,"stats":{"Line":1}},{"line":239,"address":[330346,330176],"length":1,"stats":{"Line":1}},{"line":242,"address":[330248],"length":1,"stats":{"Line":1}},{"line":265,"address":[330368],"length":1,"stats":{"Line":0}},{"line":266,"address":[330401],"length":1,"stats":{"Line":0}},{"line":268,"address":[330432],"length":1,"stats":{"Line":0}},{"line":270,"address":[330480],"length":1,"stats":{"Line":0}},{"line":271,"address":[330497],"length":1,"stats":{"Line":0}},{"line":273,"address":[330659],"length":1,"stats":{"Line":0}},{"line":274,"address":[330676],"length":1,"stats":{"Line":0}},{"line":276,"address":[331017],"length":1,"stats":{"Line":0}},{"line":277,"address":[331034],"length":1,"stats":{"Line":0}},{"line":279,"address":[330838],"length":1,"stats":{"Line":0}},{"line":280,"address":[330855],"length":1,"stats":{"Line":0}},{"line":282,"address":[331375],"length":1,"stats":{"Line":0}},{"line":283,"address":[331392],"length":1,"stats":{"Line":0}},{"line":285,"address":[331196],"length":1,"stats":{"Line":0}},{"line":286,"address":[331213],"length":1,"stats":{"Line":0}},{"line":294,"address":[331568,332083],"length":1,"stats":{"Line":0}},{"line":295,"address":[331603],"length":1,"stats":{"Line":0}},{"line":296,"address":[331681,331613],"length":1,"stats":{"Line":0}},{"line":297,"address":[331822,331761],"length":1,"stats":{"Line":0}},{"line":298,"address":[331848],"length":1,"stats":{"Line":0}},{"line":301,"address":[331876,331841],"length":1,"stats":{"Line":0}},{"line":303,"address":[331783],"length":1,"stats":{"Line":0}},{"line":315,"address":[332112,332356],"length":1,"stats":{"Line":0}},{"line":316,"address":[332256,332151,332205],"length":1,"stats":{"Line":0}},{"line":320,"address":[332170],"length":1,"stats":{"Line":0}},{"line":326,"address":[332621,332642,332384],"length":1,"stats":{"Line":0}},{"line":332,"address":[332427],"length":1,"stats":{"Line":0}},{"line":347,"address":[332656],"length":1,"stats":{"Line":0}},{"line":348,"address":[332695],"length":1,"stats":{"Line":0}},{"line":353,"address":[332816,333028],"length":1,"stats":{"Line":0}},{"line":361,"address":[332930],"length":1,"stats":{"Line":0}}],"covered":70,"coverable":121},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","operations.rs"],"content":"use serde::Serialize;\nuse std::{collections::HashMap, fmt::Display};\n\nuse crate::midend::{symtab::Function, types::Type};\n\nuse super::operands::*;\n\n/// ## Binary Operations\n#[derive(Debug, Serialize, Clone)]\npub enum BinaryOperations {\n    Add(BinaryArithmeticOperands),\n    Subtract(BinaryArithmeticOperands),\n    Multiply(BinaryArithmeticOperands),\n    Divide(BinaryArithmeticOperands),\n    LThan(BinaryArithmeticOperands),\n    GThan(BinaryArithmeticOperands),\n    LThanE(BinaryArithmeticOperands),\n    GThanE(BinaryArithmeticOperands),\n    Equals(BinaryArithmeticOperands),\n    NotEquals(BinaryArithmeticOperands),\n}\n\nimpl Display for BinaryOperations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} + {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Subtract(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} - {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Multiply(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} * {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Divide(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} / {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Equals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} == {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::NotEquals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} != {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n        }\n    }\n}\n\nimpl BinaryOperations {\n    pub fn new_add(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Add(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_subtract(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Subtract(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_multiply(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Multiply(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_divide(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Divide(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Equals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_not_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::NotEquals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn raw_operands(\u0026self) -\u003e \u0026BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n\n    pub fn raw_operands_mut(\u0026mut self) -\u003e \u0026mut BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n}\n\n/// ## Jump\n#[derive(Debug, Serialize, Clone)]\npub struct JumpOperation {\n    pub destination_block: usize,\n    pub block_args: HashMap\u003cOperandName, OperandName\u003e,\n    pub condition: JumpCondition,\n}\n\nimpl Display for JumpOperation {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut block_args_string = String::new();\n        for (arg, operand) in \u0026self.block_args {\n            block_args_string += \u0026format!(\"{}:{} \", arg, operand);\n        }\n        write!(\n            f,\n            \"{} Block{}({})\",\n            self.condition, self.destination_block, block_args_string\n        )\n    }\n}\n\nimpl JumpOperation {\n    pub fn new(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self {\n            destination_block,\n            block_args: HashMap::new(),\n            condition,\n        }\n    }\n}\n\n/// ## Enum of all operations\n#[derive(Debug, Serialize, Clone)]\npub enum Operations {\n    Assignment(SourceDestOperands),\n    BinaryOperation(BinaryOperations),\n    Jump(JumpOperation),\n    FunctionCall(FunctionCallOperands),\n    MethodCall(MethodCallOperands),\n    FieldRead(FieldReadOperands),\n    FieldWrite(FieldWriteOperands),\n}\n\nimpl Display for Operations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Assignment(assignment) =\u003e {\n                write!(f, \"{} = {}\", assignment.destination, assignment.source)\n            }\n            Self::BinaryOperation(binary_operation) =\u003e write!(f, \"{}\", binary_operation),\n            Self::Jump(jump) =\u003e write!(f, \"{}\", jump),\n            Self::FunctionCall(function_call) =\u003e write!(f, \"{}\", function_call),\n            Self::MethodCall(method_call) =\u003e write!(f, \"{}\", method_call),\n            Self::FieldRead(field_read) =\u003e write!(\n                f,\n                \"{} = {}.{}\",\n                field_read.destination, field_read.receiver, field_read.field_name\n            ),\n            Self::FieldWrite(field_write) =\u003e write!(\n                f,\n                \"{}.{} = {}\",\n                field_write.receiver, field_write.field_name, field_write.source\n            ),\n        }\n    }\n}\n\nimpl Operations {\n    pub fn new_assignment(destination: Operand, source: Operand) -\u003e Self {\n        Self::Assignment(SourceDestOperands {\n            destination,\n            source,\n        })\n    }\n\n    pub fn new_jump(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self::Jump(JumpOperation::new(destination_block, condition))\n    }\n\n    pub fn new_function_call(\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::FunctionCall(FunctionCallOperands::new(name, arguments, return_value_to))\n    }\n\n    pub fn new_method_call(\n        receiver: Operand,\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::MethodCall(MethodCallOperands::new(\n            receiver,\n            name,\n            arguments,\n            return_value_to,\n        ))\n    }\n\n    pub fn new_field_read(receiver: Operand, field_name: String, destination: Operand) -\u003e Self {\n        Self::FieldRead(FieldReadOperands {\n            receiver,\n            field_name,\n            destination,\n        })\n    }\n\n    pub fn new_field_write(source: Operand, receiver: Operand, field_name: String) -\u003e Self {\n        Self::FieldWrite(FieldWriteOperands {\n            receiver,\n            field_name,\n            source,\n        })\n    }\n}\n","traces":[{"line":24,"address":[660416],"length":1,"stats":{"Line":0}},{"line":25,"address":[660449],"length":1,"stats":{"Line":0}},{"line":26,"address":[660485],"length":1,"stats":{"Line":0}},{"line":27,"address":[660502],"length":1,"stats":{"Line":0}},{"line":33,"address":[660715],"length":1,"stats":{"Line":0}},{"line":34,"address":[660732],"length":1,"stats":{"Line":0}},{"line":40,"address":[660951],"length":1,"stats":{"Line":0}},{"line":41,"address":[660968],"length":1,"stats":{"Line":0}},{"line":47,"address":[661187],"length":1,"stats":{"Line":0}},{"line":48,"address":[661204],"length":1,"stats":{"Line":0}},{"line":54,"address":[661423],"length":1,"stats":{"Line":0}},{"line":55,"address":[661440],"length":1,"stats":{"Line":0}},{"line":61,"address":[661659],"length":1,"stats":{"Line":0}},{"line":62,"address":[661676],"length":1,"stats":{"Line":0}},{"line":68,"address":[661895],"length":1,"stats":{"Line":0}},{"line":69,"address":[661912],"length":1,"stats":{"Line":0}},{"line":75,"address":[662131],"length":1,"stats":{"Line":0}},{"line":76,"address":[662148],"length":1,"stats":{"Line":0}},{"line":82,"address":[662367],"length":1,"stats":{"Line":0}},{"line":83,"address":[662384],"length":1,"stats":{"Line":0}},{"line":89,"address":[662603],"length":1,"stats":{"Line":0}},{"line":90,"address":[662620],"length":1,"stats":{"Line":0}},{"line":101,"address":[662848],"length":1,"stats":{"Line":1}},{"line":102,"address":[662865],"length":1,"stats":{"Line":1}},{"line":109,"address":[662928],"length":1,"stats":{"Line":2}},{"line":110,"address":[662945],"length":1,"stats":{"Line":2}},{"line":117,"address":[663008],"length":1,"stats":{"Line":0}},{"line":118,"address":[663025],"length":1,"stats":{"Line":0}},{"line":125,"address":[663088],"length":1,"stats":{"Line":0}},{"line":126,"address":[663105],"length":1,"stats":{"Line":0}},{"line":133,"address":[663168],"length":1,"stats":{"Line":0}},{"line":134,"address":[663185],"length":1,"stats":{"Line":0}},{"line":141,"address":[663248],"length":1,"stats":{"Line":0}},{"line":142,"address":[663265],"length":1,"stats":{"Line":0}},{"line":149,"address":[663328],"length":1,"stats":{"Line":0}},{"line":150,"address":[663345],"length":1,"stats":{"Line":0}},{"line":157,"address":[663408],"length":1,"stats":{"Line":0}},{"line":158,"address":[663425],"length":1,"stats":{"Line":0}},{"line":165,"address":[663488],"length":1,"stats":{"Line":0}},{"line":166,"address":[663505],"length":1,"stats":{"Line":0}},{"line":173,"address":[663568],"length":1,"stats":{"Line":0}},{"line":174,"address":[663585],"length":1,"stats":{"Line":0}},{"line":181,"address":[663648],"length":1,"stats":{"Line":1}},{"line":182,"address":[663658,663703,663722,663834,663818,663738,663770,663754,663786,663802],"length":1,"stats":{"Line":2}},{"line":183,"address":[663729],"length":1,"stats":{"Line":0}},{"line":196,"address":[663856],"length":1,"stats":{"Line":1}},{"line":197,"address":[663866,663911,663962,663946,664010,663978,663994,664026,663930,664042],"length":1,"stats":{"Line":2}},{"line":198,"address":[664049],"length":1,"stats":{"Line":0}},{"line":221,"address":[664770,664064],"length":1,"stats":{"Line":0}},{"line":222,"address":[664102],"length":1,"stats":{"Line":0}},{"line":223,"address":[664112,664169],"length":1,"stats":{"Line":0}},{"line":224,"address":[664540,664316],"length":1,"stats":{"Line":0}},{"line":226,"address":[664339],"length":1,"stats":{"Line":0}},{"line":235,"address":[664970,664800],"length":1,"stats":{"Line":2}},{"line":238,"address":[664840],"length":1,"stats":{"Line":2}},{"line":257,"address":[664992],"length":1,"stats":{"Line":0}},{"line":258,"address":[665025],"length":1,"stats":{"Line":0}},{"line":259,"address":[665081],"length":1,"stats":{"Line":0}},{"line":260,"address":[665098],"length":1,"stats":{"Line":0}},{"line":262,"address":[665245],"length":1,"stats":{"Line":0}},{"line":263,"address":[665373],"length":1,"stats":{"Line":0}},{"line":264,"address":[665497],"length":1,"stats":{"Line":0}},{"line":265,"address":[665625],"length":1,"stats":{"Line":0}},{"line":266,"address":[665753],"length":1,"stats":{"Line":0}},{"line":271,"address":[665985],"length":1,"stats":{"Line":0}},{"line":281,"address":[666224],"length":1,"stats":{"Line":1}},{"line":282,"address":[666242],"length":1,"stats":{"Line":1}},{"line":288,"address":[666336],"length":1,"stats":{"Line":2}},{"line":289,"address":[666360],"length":1,"stats":{"Line":2}},{"line":292,"address":[666416],"length":1,"stats":{"Line":0}},{"line":297,"address":[666446],"length":1,"stats":{"Line":0}},{"line":300,"address":[666512],"length":1,"stats":{"Line":0}},{"line":306,"address":[666545],"length":1,"stats":{"Line":0}},{"line":314,"address":[666608],"length":1,"stats":{"Line":0}},{"line":315,"address":[666634],"length":1,"stats":{"Line":0}},{"line":322,"address":[666768],"length":1,"stats":{"Line":0}},{"line":323,"address":[666808],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":77},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir","tests.rs"],"content":"use crate::midend::ir::*;\n\n#[test]\nfn ir_line_new_assignment() {\n    let assignment = IrLine::new_assignment(\n        SourceLoc::new(123, 456),\n        Operand::new_as_variable(\"a\".into()),\n        Operand::new_as_unsigned_decimal_constant(99),\n    );\n\n    assert_eq!(assignment.loc, SourceLoc::new(123, 456));\n    assert!(matches!(assignment.operation, Operations::Assignment(_)));\n}\n\n#[test]\nfn ir_line_new_binary_op() {\n    let binary_operation = IrLine::new_binary_op(\n        SourceLoc::new(123, 456),\n        BinaryOperations::new_add(\n            Operand::new_as_variable(\"result\".into()),\n            Operand::new_as_variable(\"a\".into()),\n            Operand::new_as_variable(\"b\".into()),\n        ),\n    );\n\n    assert_eq!(binary_operation.loc, SourceLoc::new(123, 456));\n    assert!(matches!(\n        binary_operation.operation,\n        Operations::BinaryOperation(_)\n    ));\n}\n\n#[test]\nfn ir_line_new_jump() {\n    let jump = IrLine::new_jump(SourceLoc::new(123, 456), 8, JumpCondition::Unconditional);\n\n    assert_eq!(jump.loc, SourceLoc::new(123, 456));\n    assert!(matches!(jump.operation, Operations::Jump(_)));\n}\n\n#[cfg(test)]\nfn operand_from_string(name: \u0026str) -\u003e Operand {\n    Operand::new_as_variable(name.into())\n}\n\n#[cfg(test)]\nfn line_from_op(operation: Operations) -\u003e IrLine {\n    IrLine::new(SourceLoc::new(0, 0), operation)\n}\n\n#[cfg(test)]\nfn operand_name_from_string(name: \u0026str) -\u003e OperandName {\n    OperandName::new_basic(name.into())\n}\n\n#[test]\nfn read_operand_names() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n\n#[test]\nfn read_operand_names_mut() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ir.rs"],"content":"pub mod control_flow;\npub mod operands;\npub mod operations;\n#[cfg(test)]\nmod tests;\n\nuse std::collections::BTreeSet;\nuse std::fmt::Display;\n\nuse crate::frontend::sourceloc::SourceLoc;\nuse crate::midend::ir;\nuse serde::Serialize;\n\npub use control_flow::ControlFlow;\npub use operands::*;\npub use operations::*;\n\n#[derive(Debug, Serialize, Clone)]\npub struct IrLine {\n    pub loc: SourceLoc,\n    pub operation: Operations,\n}\n\nimpl Display for IrLine {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.operation)\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct BasicBlock {\n    pub label: usize,\n    pub statements: Vec\u003cir::IrLine\u003e,\n    pub arguments: BTreeSet\u003cir::OperandName\u003e,\n    pub successors: BTreeSet\u003cusize\u003e,\n    pub predecessors: BTreeSet\u003cusize\u003e,\n}\n\nimpl BasicBlock {\n    pub fn new(label: usize) -\u003e Self {\n        BasicBlock {\n            statements: Vec::new(),\n            label: label,\n            arguments: BTreeSet::new(),\n            successors: BTreeSet::\u003cusize\u003e::new(),\n            predecessors: BTreeSet::\u003cusize\u003e::new(),\n        }\n    }\n}\n\nimpl IrLine {\n    fn new(loc: SourceLoc, operation: Operations) -\u003e Self {\n        IrLine {\n            loc: loc,\n            operation: operation,\n        }\n    }\n\n    pub fn new_assignment(loc: SourceLoc, destination: Operand, source: Operand) -\u003e Self {\n        Self::new(loc, Operations::new_assignment(destination, source))\n    }\n\n    pub fn new_binary_op(loc: SourceLoc, op: BinaryOperations) -\u003e Self {\n        Self::new(loc, Operations::BinaryOperation(op))\n    }\n\n    pub fn new_jump(\n        loc: SourceLoc,\n        destination_block: usize,\n        condition: operands::JumpCondition,\n    ) -\u003e Self {\n        Self::new(loc, Operations::new_jump(destination_block, condition))\n    }\n\n    pub fn new_function_call(\n        loc: SourceLoc,\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_function_call(name, arguments, return_value_to),\n        )\n    }\n\n    pub fn new_method_call(\n        loc: SourceLoc,\n        receiver: Operand,\n        name: \u0026str,\n        arguments: OrderedArgumentList,\n        return_value_to: Option\u003cOperand\u003e,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_method_call(receiver, name, arguments, return_value_to),\n        )\n    }\n\n    pub fn new_field_read(\n        loc: SourceLoc,\n        receiver: Operand,\n        field_name: String,\n        destination: Operand,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_field_read(receiver, field_name, destination),\n        )\n    }\n\n    pub fn new_field_write(\n        source: Operand,\n        loc: SourceLoc,\n        receiver: Operand,\n        field_name: String,\n    ) -\u003e Self {\n        Self::new(\n            loc,\n            Operations::new_field_write(source, receiver, field_name),\n        )\n    }\n\n    pub fn read_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e match \u0026source_dest.source.get_name() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026operation.raw_operands().sources;\n                match sources.a.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values() {\n                    operand_names.push(arg);\n                }\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                for arg in \u0026function_call.arguments {\n                    match arg.get_name() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026method_call.call;\n                for arg in \u0026inner_function_call.arguments {\n                    match arg.get_name() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::FieldRead(field_read) =\u003e {\n                operand_names.push(field_read.receiver.get_name().unwrap());\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.source.get_name().unwrap());\n            }\n        }\n        operand_names\n    }\n\n    pub fn read_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e match source_dest.source.get_name_mut() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026mut operation.raw_operands_mut().sources;\n                match sources.a.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026mut jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values_mut() {\n                    operand_names.push(arg);\n                }\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                for arg in \u0026mut function_call.arguments {\n                    match arg.get_name_mut() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026mut method_call.call;\n                for arg in \u0026mut inner_function_call.arguments {\n                    match arg.get_name_mut() {\n                        Some(arg_name) =\u003e operand_names.push(arg_name),\n                        None =\u003e (),\n                    }\n                }\n            }\n            Operations::FieldRead(field_read) =\u003e {\n                operand_names.push(field_read.receiver.get_name_mut().unwrap());\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.source.get_name_mut().unwrap());\n            }\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operand_names.push(source_dest.destination.get_name().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands();\n                operand_names.push(arithmetic_operands.destination.get_name().unwrap());\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                if let Some(retval) = \u0026function_call.return_value_to {\n                    operand_names.push(retval.get_name().unwrap());\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026method_call.call;\n                if let Some(retval) = \u0026inner_function_call.return_value_to {\n                    operand_names.push(retval.get_name().unwrap());\n                }\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.receiver.get_name().unwrap());\n            }\n            Operations::Jump(_) | Operations::FieldRead(_) =\u003e {}\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operand_names.push(source_dest.destination.get_name_mut().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands_mut();\n                operand_names.push(arithmetic_operands.destination.get_name_mut().unwrap());\n            }\n            Operations::FunctionCall(function_call) =\u003e {\n                if let Some(retval) = \u0026mut function_call.return_value_to {\n                    operand_names.push(retval.get_name_mut().unwrap());\n                }\n            }\n            Operations::MethodCall(method_call) =\u003e {\n                let inner_function_call = \u0026mut method_call.call;\n                if let Some(retval) = \u0026mut inner_function_call.return_value_to {\n                    operand_names.push(retval.get_name_mut().unwrap());\n                }\n            }\n            Operations::FieldWrite(field_write) =\u003e {\n                operand_names.push(field_write.receiver.get_name_mut().unwrap());\n            }\n            Operations::Jump(_) | Operations::FieldRead(_) =\u003e {}\n        }\n\n        operand_names\n    }\n}\n","traces":[{"line":25,"address":[257088],"length":1,"stats":{"Line":0}},{"line":26,"address":[257112],"length":1,"stats":{"Line":0}},{"line":40,"address":[257515,257200],"length":1,"stats":{"Line":1}},{"line":42,"address":[257235],"length":1,"stats":{"Line":1}},{"line":44,"address":[257245],"length":1,"stats":{"Line":2}},{"line":45,"address":[257294],"length":1,"stats":{"Line":3}},{"line":46,"address":[257340],"length":1,"stats":{"Line":3}},{"line":52,"address":[257552],"length":1,"stats":{"Line":3}},{"line":59,"address":[257632],"length":1,"stats":{"Line":1}},{"line":60,"address":[257701],"length":1,"stats":{"Line":1}},{"line":63,"address":[257760],"length":1,"stats":{"Line":1}},{"line":64,"address":[257814],"length":1,"stats":{"Line":1}},{"line":67,"address":[257888],"length":1,"stats":{"Line":1}},{"line":72,"address":[257963],"length":1,"stats":{"Line":1}},{"line":75,"address":[258016],"length":1,"stats":{"Line":0}},{"line":83,"address":[258128],"length":1,"stats":{"Line":0}},{"line":87,"address":[258176],"length":1,"stats":{"Line":0}},{"line":96,"address":[258296],"length":1,"stats":{"Line":0}},{"line":100,"address":[258352],"length":1,"stats":{"Line":0}},{"line":108,"address":[258440],"length":1,"stats":{"Line":0}},{"line":112,"address":[258496],"length":1,"stats":{"Line":0}},{"line":120,"address":[258573],"length":1,"stats":{"Line":0}},{"line":124,"address":[260580,258624],"length":1,"stats":{"Line":1}},{"line":125,"address":[258671],"length":1,"stats":{"Line":1}},{"line":126,"address":[258684],"length":1,"stats":{"Line":1}},{"line":127,"address":[258749,259118],"length":1,"stats":{"Line":2}},{"line":128,"address":[259165,259262],"length":1,"stats":{"Line":2}},{"line":131,"address":[258794],"length":1,"stats":{"Line":1}},{"line":132,"address":[258806,259272],"length":1,"stats":{"Line":2}},{"line":133,"address":[259289],"length":1,"stats":{"Line":1}},{"line":134,"address":[259404,259345],"length":1,"stats":{"Line":2}},{"line":137,"address":[259388,259411],"length":1,"stats":{"Line":2}},{"line":138,"address":[259454],"length":1,"stats":{"Line":1}},{"line":142,"address":[258832],"length":1,"stats":{"Line":1}},{"line":143,"address":[258840,259635,259613,259569,259591,259547],"length":1,"stats":{"Line":6}},{"line":145,"address":[259623],"length":1,"stats":{"Line":1}},{"line":151,"address":[259657],"length":1,"stats":{"Line":1}},{"line":152,"address":[259721,259783],"length":1,"stats":{"Line":2}},{"line":155,"address":[259790,259759],"length":1,"stats":{"Line":2}},{"line":156,"address":[259833],"length":1,"stats":{"Line":1}},{"line":161,"address":[259505,259892],"length":1,"stats":{"Line":2}},{"line":162,"address":[260009],"length":1,"stats":{"Line":0}},{"line":165,"address":[258883],"length":1,"stats":{"Line":0}},{"line":166,"address":[260049,258898],"length":1,"stats":{"Line":0}},{"line":167,"address":[260149],"length":1,"stats":{"Line":0}},{"line":168,"address":[260209],"length":1,"stats":{"Line":0}},{"line":173,"address":[258936],"length":1,"stats":{"Line":0}},{"line":174,"address":[258951],"length":1,"stats":{"Line":0}},{"line":175,"address":[258966,260265],"length":1,"stats":{"Line":0}},{"line":176,"address":[260365],"length":1,"stats":{"Line":0}},{"line":177,"address":[260425],"length":1,"stats":{"Line":0}},{"line":182,"address":[259001],"length":1,"stats":{"Line":0}},{"line":183,"address":[259013,260473],"length":1,"stats":{"Line":0}},{"line":185,"address":[259036],"length":1,"stats":{"Line":0}},{"line":186,"address":[260529,259051],"length":1,"stats":{"Line":0}},{"line":189,"address":[259219],"length":1,"stats":{"Line":1}},{"line":192,"address":[260608,262556],"length":1,"stats":{"Line":1}},{"line":193,"address":[260655],"length":1,"stats":{"Line":1}},{"line":194,"address":[260668],"length":1,"stats":{"Line":1}},{"line":195,"address":[261102,260733],"length":1,"stats":{"Line":2}},{"line":196,"address":[261141,261238],"length":1,"stats":{"Line":2}},{"line":199,"address":[260778],"length":1,"stats":{"Line":1}},{"line":200,"address":[261248,260790],"length":1,"stats":{"Line":2}},{"line":201,"address":[261265],"length":1,"stats":{"Line":1}},{"line":202,"address":[261321,261380],"length":1,"stats":{"Line":2}},{"line":205,"address":[261387,261364],"length":1,"stats":{"Line":2}},{"line":206,"address":[261430],"length":1,"stats":{"Line":1}},{"line":210,"address":[260816],"length":1,"stats":{"Line":1}},{"line":211,"address":[261589,260824,261545,261567,261611,261523],"length":1,"stats":{"Line":6}},{"line":213,"address":[261577],"length":1,"stats":{"Line":1}},{"line":219,"address":[261633],"length":1,"stats":{"Line":1}},{"line":220,"address":[261697,261759],"length":1,"stats":{"Line":2}},{"line":223,"address":[261735,261766],"length":1,"stats":{"Line":2}},{"line":224,"address":[261809],"length":1,"stats":{"Line":1}},{"line":229,"address":[261481,261868],"length":1,"stats":{"Line":2}},{"line":230,"address":[261985],"length":1,"stats":{"Line":0}},{"line":233,"address":[260867],"length":1,"stats":{"Line":0}},{"line":234,"address":[262025,260882],"length":1,"stats":{"Line":0}},{"line":235,"address":[262125],"length":1,"stats":{"Line":0}},{"line":236,"address":[262185],"length":1,"stats":{"Line":0}},{"line":241,"address":[260920],"length":1,"stats":{"Line":0}},{"line":242,"address":[260935],"length":1,"stats":{"Line":0}},{"line":243,"address":[262241,260950],"length":1,"stats":{"Line":0}},{"line":244,"address":[262341],"length":1,"stats":{"Line":0}},{"line":245,"address":[262401],"length":1,"stats":{"Line":0}},{"line":250,"address":[260985],"length":1,"stats":{"Line":0}},{"line":251,"address":[262449,260997],"length":1,"stats":{"Line":0}},{"line":253,"address":[261020],"length":1,"stats":{"Line":0}},{"line":254,"address":[261035,262505],"length":1,"stats":{"Line":0}},{"line":258,"address":[261195],"length":1,"stats":{"Line":1}},{"line":261,"address":[263387,262592],"length":1,"stats":{"Line":1}},{"line":262,"address":[262633],"length":1,"stats":{"Line":1}},{"line":263,"address":[262646],"length":1,"stats":{"Line":1}},{"line":264,"address":[262711],"length":1,"stats":{"Line":1}},{"line":265,"address":[262723,263037],"length":1,"stats":{"Line":2}},{"line":267,"address":[262746],"length":1,"stats":{"Line":1}},{"line":268,"address":[263093,262758],"length":1,"stats":{"Line":2}},{"line":269,"address":[263101],"length":1,"stats":{"Line":1}},{"line":271,"address":[262834],"length":1,"stats":{"Line":0}},{"line":272,"address":[262854,263174],"length":1,"stats":{"Line":0}},{"line":273,"address":[263182],"length":1,"stats":{"Line":0}},{"line":276,"address":[262892],"length":1,"stats":{"Line":0}},{"line":277,"address":[262907],"length":1,"stats":{"Line":0}},{"line":278,"address":[262924,263255],"length":1,"stats":{"Line":0}},{"line":279,"address":[263263],"length":1,"stats":{"Line":0}},{"line":282,"address":[262965],"length":1,"stats":{"Line":0}},{"line":283,"address":[262977,263336],"length":1,"stats":{"Line":0}},{"line":288,"address":[262783],"length":1,"stats":{"Line":1}},{"line":291,"address":[264219,263424],"length":1,"stats":{"Line":1}},{"line":292,"address":[263465],"length":1,"stats":{"Line":1}},{"line":293,"address":[263478],"length":1,"stats":{"Line":1}},{"line":294,"address":[263543],"length":1,"stats":{"Line":1}},{"line":295,"address":[263555,263869],"length":1,"stats":{"Line":2}},{"line":297,"address":[263578],"length":1,"stats":{"Line":1}},{"line":298,"address":[263925,263590],"length":1,"stats":{"Line":2}},{"line":299,"address":[263933],"length":1,"stats":{"Line":1}},{"line":301,"address":[263666],"length":1,"stats":{"Line":0}},{"line":302,"address":[263686,264006],"length":1,"stats":{"Line":0}},{"line":303,"address":[264014],"length":1,"stats":{"Line":0}},{"line":306,"address":[263724],"length":1,"stats":{"Line":0}},{"line":307,"address":[263739],"length":1,"stats":{"Line":0}},{"line":308,"address":[263756,264087],"length":1,"stats":{"Line":0}},{"line":309,"address":[264095],"length":1,"stats":{"Line":0}},{"line":312,"address":[263797],"length":1,"stats":{"Line":0}},{"line":313,"address":[263809,264168],"length":1,"stats":{"Line":0}},{"line":318,"address":[263615],"length":1,"stats":{"Line":1}}],"covered":70,"coverable":126},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","linearizer","treewalk.rs"],"content":"use std::clone;\n\nuse crate::{\n    frontend::{ast::*, sourceloc::SourceLoc},\n    midend::{\n        ir::{self, IrLine},\n        symtab::{self, SymbolTable},\n        types::Type,\n    },\n};\n\nuse super::walkcontext::WalkContext;\n\n#[derive(Clone, Debug)]\npub struct Value {\n    pub type_: Type,\n    pub operand: Option\u003cir::Operand\u003e,\n}\n\nimpl Value {\n    pub fn unit() -\u003e Self {\n        Self {\n            type_: Type::Unit,\n            operand: None,\n        }\n    }\n\n    pub fn from_type(type_: Type) -\u003e Self {\n        Self {\n            type_,\n            operand: None,\n        }\n    }\n\n    pub fn from_type_and_name(type_: Type, operand: ir::Operand) -\u003e Self {\n        Self {\n            type_,\n            operand: Some(operand),\n        }\n    }\n\n    pub fn from_operand(operand: ir::Operand, context: \u0026WalkContext) -\u003e Self {\n        Self {\n            type_: operand.type_(context).clone(),\n            operand: Some(operand),\n        }\n    }\n}\n\nimpl Into\u003cir::Operand\u003e for Value {\n    fn into(self) -\u003e ir::Operand {\n        self.operand.unwrap()\n    }\n}\n\nimpl Into\u003cType\u003e for Value {\n    fn into(self) -\u003e Type {\n        self.type_\n    }\n}\n\npub trait TableWalk {\n    fn walk(self, symbol_table: \u0026mut SymbolTable);\n}\n\npub trait Walk {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value;\n}\n\npub trait ReturnWalk\u003cT, U\u003e {\n    fn walk(self, context: T) -\u003e U;\n}\n\nimpl TableWalk for TranslationUnitTree {\n    fn walk(self, symbol_table: \u0026mut SymbolTable) {\n        match self.contents {\n            TranslationUnit::FunctionDeclaration(function_declaration) =\u003e {\n                let declared_function =\n                    function_declaration.walk(\u0026mut WalkContext::new(\u0026symbol_table.global_scope));\n                symbol_table.insert_function_prototype(declared_function);\n            }\n            TranslationUnit::FunctionDefinition(function_definition) =\u003e {\n                let context = WalkContext::new(\u0026symbol_table.global_scope);\n                symbol_table.insert_function(function_definition.walk(context));\n            }\n            TranslationUnit::StructDefinition(struct_definition) =\u003e {\n                let mut defined_struct = symtab::StructRepr::new(struct_definition.name);\n                for field in struct_definition.fields {\n                    // TODO: global scoping\n                    let field_type = field\n                        .typename\n                        .walk(\u0026mut WalkContext::new(\u0026symbol_table.global_scope));\n                    defined_struct.add_field(field.name, field_type.type_);\n                }\n\n                symbol_table\n                    .global_scope\n                    .insert_struct_definition(defined_struct);\n            }\n            TranslationUnit::Implementation(implementation) =\u003e {\n                let mut impl_context = WalkContext::new(\u0026symbol_table.global_scope);\n                let implemented_for_type = implementation.type_name.walk(\u0026mut impl_context).type_;\n\n                let methods: Vec\u003csymtab::Function\u003e = implementation\n                    .items\n                    .into_iter()\n                    .map(|item| {\n                        let impl_context = WalkContext::new(\u0026symbol_table.global_scope);\n                        item.walk(impl_context)\n                    })\n                    .collect();\n\n                let implemented_for_mut = symbol_table\n                    .global_scope\n                    .lookup_type_mut(\u0026implemented_for_type)\n                    .unwrap();\n\n                for method in methods {\n                    implemented_for_mut.add_method(method);\n                }\n            }\n        }\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003cWalkContext\u003c'a\u003e, symtab::Function\u003e for FunctionDefinitionTree {\n    fn walk(self, mut context: WalkContext\u003c'a\u003e) -\u003e symtab::Function {\n        let mut declared_prototype = self.prototype.walk(\u0026mut context);\n        context.push_scope(declared_prototype.create_argument_scope());\n\n        self.body.walk(\u0026mut context);\n        let argument_scope = context.pop_last_scope();\n\n        symtab::Function::new(\n            declared_prototype,\n            argument_scope,\n            context.take_control_flow(),\n        )\n    }\n}\n\nimpl Walk for TypenameTree {\n    fn walk(self, _context: \u0026mut WalkContext) -\u003e Value {\n        Value::from_type(self.type_)\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, symtab::Variable\u003e for VariableDeclarationTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e symtab::Variable {\n        symtab::Variable::new(self.name.clone(), self.typename.walk(context).type_)\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, symtab::FunctionPrototype\u003e for FunctionDeclarationTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e symtab::FunctionPrototype {\n        symtab::FunctionPrototype::new(\n            self.name,\n            self.arguments\n                .into_iter()\n                .map(|x| x.walk(context))\n                .collect(),\n            match self.return_type {\n                Some(typename) =\u003e typename.walk(context).type_,\n                None =\u003e Type::Unit,\n            },\n        )\n    }\n}\n\nimpl Walk for ArithmeticExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let (temp_dest, op) = match self {\n            ArithmeticExpressionTree::Add(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_add(dest, lhs, rhs),\n                )\n            }\n            ArithmeticExpressionTree::Subtract(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest: ir::Operand = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_subtract(dest, lhs, rhs),\n                )\n            }\n            ArithmeticExpressionTree::Multiply(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_multiply(dest, lhs, rhs),\n                )\n            }\n            ArithmeticExpressionTree::Divide(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_divide(dest, lhs, rhs),\n                )\n            }\n        };\n\n        // TODO: associate location with arithmetic expression trees\n        let operation = IrLine::new_binary_op(SourceLoc::none(), op);\n        context.append_statement_to_current_block(operation);\n        Value::from_operand(temp_dest, context)\n    }\n}\n\nimpl Walk for ComparisonExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let (temp_dest, op) = match self {\n            ComparisonExpressionTree::LThan(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::GThan(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::LThanE(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::GThanE(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::Equals(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_equals(dest, lhs, rhs),\n                )\n            }\n            ComparisonExpressionTree::NotEquals(operands) =\u003e {\n                let lhs: ir::Operand = operands.e1.walk(context).into();\n                let rhs: ir::Operand = operands.e2.walk(context).into();\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_not_equals(dest, lhs, rhs),\n                )\n            }\n        };\n\n        // TODO: association location with comparison expression tree\n        let operation = IrLine::new_binary_op(SourceLoc::none(), op);\n        context.append_statement_to_current_block(operation);\n        Value::from_operand(temp_dest, context)\n    }\n}\n\nimpl Walk for ExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        match self.expression {\n            Expression::Identifier(ident) =\u003e {\n                Value::from_operand(ir::Operand::new_as_variable(ident), context)\n            }\n            Expression::UnsignedDecimalConstant(constant) =\u003e Value::from_operand(\n                ir::Operand::new_as_unsigned_decimal_constant(constant),\n                context,\n            ),\n            Expression::Arithmetic(arithmetic_operation) =\u003e arithmetic_operation.walk(context),\n            Expression::Comparison(comparison_operation) =\u003e comparison_operation.walk(context),\n            Expression::Assignment(assignment_expression) =\u003e assignment_expression.walk(context),\n            Expression::If(if_expression) =\u003e if_expression.walk(context),\n            Expression::While(while_expression) =\u003e while_expression.walk(context),\n            Expression::FieldExpression(field_expression) =\u003e {\n                let (receiver, field) = field_expression.walk(context);\n                let destination = context.next_temp(field.type_);\n                let field_read_line = ir::IrLine::new_field_read(\n                    self.loc,\n                    receiver.into(),\n                    field.operand.unwrap().get_name().unwrap().base_name.clone(),\n                    destination.clone(),\n                );\n                context.append_statement_to_current_block(field_read_line);\n                Value::from_operand(destination, context)\n            }\n            Expression::MethodCall(method_call) =\u003e method_call.walk(context),\n        }\n    }\n}\n\nimpl Walk for AssignmentTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let assignment_ir = match self.assignee.expression {\n            Expression::FieldExpression(field_expression_tree) =\u003e {\n                let (receiver, field) = field_expression_tree.walk(context);\n                IrLine::new_field_write(\n                    self.value.walk(context).into(),\n                    self.loc,\n                    receiver.into(),\n                    field.operand.unwrap().get_name().unwrap().base_name.clone(),\n                )\n            }\n            _ =\u003e IrLine::new_assignment(\n                self.loc,\n                self.assignee.walk(context).into(),\n                self.value.walk(context).into(),\n            ),\n        };\n\n        context.append_statement_to_current_block(assignment_ir);\n\n        Value::unit()\n    }\n}\n\nimpl Walk for IfExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        // FUTURE: optimize condition walk to use different jumps\n        let condition_loc = self.condition.loc.clone();\n        let condition_result: ir::Operand = self.condition.walk(context).into();\n        let if_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n\n        let (_, maybe_else_label) =\n            context.create_conditional_branch_from_current(condition_loc, if_condition);\n        let if_value = self.true_block.walk(context);\n\n        // create a separate, mutable value which contains the true result\n        let mut result_value = if_value.clone();\n\n        // if a false block exists AND the 'if' value exists\n        if self.false_block.is_some() \u0026\u0026 if_value.operand.is_some() {\n            // we need to copy the 'if' result to the common result_value at the end of the 'if' block\n            let result_operand = context.next_temp(if_value.type_.clone());\n            result_value = Value::from_operand(result_operand.clone(), context);\n            let assign_if_result_line =\n                ir::IrLine::new_assignment(self.loc, result_operand, if_value.clone().into());\n            context.append_statement_to_current_block(assign_if_result_line);\n        }\n        context.converge_current_block();\n\n        match (maybe_else_label, self.false_block) {\n            (Some(else_label), Some(else_block)) =\u003e {\n                context.set_current_block(else_label);\n                let else_value = else_block.walk(context);\n\n                // sanity-check that both branches return the same type\n                if if_value.type_ != else_value.type_ {\n                    panic!(\n                        \"If and Else branches return different types ({} and {}): {}\",\n                        if_value.type_, else_value.type_, self.loc\n                    );\n                }\n\n                // if the 'else' value exists (have already passed check to assert types are the same)\n                if else_value.operand.is_some() {\n                    // copy the 'else' result to the common result_value at the end of the 'else' block\n                    let assign_else_result_line = ir::IrLine::new_assignment(\n                        self.loc,\n                        result_value.clone().into(),\n                        else_value.into(),\n                    );\n                    context.append_statement_to_current_block(assign_else_result_line);\n                }\n\n                context.converge_current_block();\n            }\n            (None, None) =\u003e {}\n            (_, _) =\u003e {\n                panic!(\n                    \"Mismatched else label and else block - expect to have either both or neither\"\n                );\n            }\n        };\n\n        result_value\n    }\n}\n\nimpl Walk for WhileExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let loop_done = context.create_loop(self.loc, self.condition);\n\n        self.body.walk(context);\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n\n        Value::unit()\n    }\n}\n\n// returns (receiver, field_info)\n// receiver is the value containing the receiver of the field access\n// field_info is a value containing name and type information of the field being accessed\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, (Value, Value)\u003e for FieldExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e (Value, Value) {\n        let receiver = self.receiver.walk(context);\n\n        let struct_name = match \u0026receiver.type_ {\n            Type::UDT(type_name) =\u003e type_name,\n            _ =\u003e panic!(\n                \"Field expression receiver must be of struct type (got {})\",\n                receiver.type_\n            ),\n        };\n\n        let receiver_definition = context.lookup_struct(struct_name).expect(\u0026format!(\n            \"Error handling for failed lookups is unimplemented: {}.{}\",\n            receiver.type_, self.field\n        ));\n        // TODO: error handling\n        let accessed_field = receiver_definition.get_field(\u0026self.field).unwrap();\n        (\n            receiver,\n            Value::from_type_and_name(\n                accessed_field.type_().clone(),\n                ir::Operand::Variable(ir::OperandName::new_basic(self.field)),\n            ),\n        )\n    }\n}\n\nimpl\u003c'a\u003e ReturnWalk\u003c\u0026mut WalkContext\u003c'a\u003e, Vec\u003cValue\u003e\u003e for CallParamsTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Vec\u003cValue\u003e {\n        let mut param_values = Vec::new();\n\n        for param in self.params {\n            param_values.push(param.walk(context));\n        }\n\n        param_values\n    }\n}\n\nimpl Walk for MethodCallExpressionTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        let receiver = self.receiver.walk(context);\n\n        let type_definition = context.lookup_type(\u0026receiver.type_).unwrap();\n        let called_method: symtab::FunctionPrototype = type_definition\n            .lookup_method(\u0026self.called_method)\n            .unwrap()\n            .prototype()\n            .clone();\n\n        let return_value_to = if called_method.return_type != Type::Unit {\n            Some(context.next_temp(called_method.return_type))\n        } else {\n            None\n        };\n        // //TODO: error handling and checking\n        // assert!(called_method.arguments.len() == params.len());\n\n        let params: Vec\u003cir::Operand\u003e = self\n            .params\n            .walk(context)\n            .into_iter()\n            .map(|value| value.into())\n            .collect();\n\n        let method_call_line = IrLine::new_method_call(\n            self.loc,\n            receiver.into(),\n            \u0026called_method.name,\n            params,\n            return_value_to.clone(),\n        );\n\n        context.append_statement_to_current_block(method_call_line);\n\n        match return_value_to {\n            Some(operand) =\u003e Value::from_operand(operand, context),\n            None =\u003e Value::unit(),\n        }\n    }\n}\n\nimpl Walk for StatementTree {\n    fn walk(self, context: \u0026mut WalkContext) -\u003e Value {\n        match self.statement {\n            Statement::VariableDeclaration(declaration_tree) =\u003e {\n                let declared_variable = declaration_tree.walk(context);\n                context.scope().insert_variable(declared_variable);\n                Value::unit()\n            }\n            Statement::Expression(expression_tree) =\u003e expression_tree.walk(context),\n        }\n    }\n}\n\nimpl Walk for CompoundExpressionTree {\n    fn walk(mut self, context: \u0026mut WalkContext) -\u003e Value {\n        context.push_scope(symtab::Scope::new());\n        let last_statement = self.statements.pop();\n        for statement in self.statements {\n            statement.walk(context);\n        }\n\n        let last_statement_value = match last_statement {\n            Some(statement_tree) =\u003e match statement_tree.statement {\n                Statement::VariableDeclaration(variable_declaration_tree) =\u003e {\n                    variable_declaration_tree.walk(context);\n                    Value::unit()\n                }\n                Statement::Expression(expression_tree) =\u003e expression_tree.walk(context),\n            },\n            None =\u003e Value::unit(),\n        };\n\n        context.pop_scope_to_subscope_of_next();\n\n        last_statement_value\n    }\n}\n","traces":[{"line":21,"address":[376720],"length":1,"stats":{"Line":0}},{"line":28,"address":[376816],"length":1,"stats":{"Line":0}},{"line":35,"address":[376896],"length":1,"stats":{"Line":0}},{"line":38,"address":[376928],"length":1,"stats":{"Line":0}},{"line":42,"address":[377008,377223],"length":1,"stats":{"Line":1}},{"line":44,"address":[377057,377116],"length":1,"stats":{"Line":2}},{"line":45,"address":[377128],"length":1,"stats":{"Line":1}},{"line":51,"address":[377248,377363],"length":1,"stats":{"Line":1}},{"line":52,"address":[377264],"length":1,"stats":{"Line":1}},{"line":57,"address":[377392],"length":1,"stats":{"Line":0}},{"line":58,"address":[377417],"length":1,"stats":{"Line":0}},{"line":75,"address":[722755,722783,721824],"length":1,"stats":{"Line":0}},{"line":76,"address":[721849],"length":1,"stats":{"Line":0}},{"line":77,"address":[721991],"length":1,"stats":{"Line":0}},{"line":78,"address":[722464,722060],"length":1,"stats":{"Line":0}},{"line":80,"address":[722636],"length":1,"stats":{"Line":0}},{"line":82,"address":[722180],"length":1,"stats":{"Line":0}},{"line":83,"address":[722223],"length":1,"stats":{"Line":0}},{"line":84,"address":[722830],"length":1,"stats":{"Line":0}},{"line":86,"address":[722238],"length":1,"stats":{"Line":0}},{"line":87,"address":[722993,722294],"length":1,"stats":{"Line":0}},{"line":88,"address":[723229,723102,723943,723001],"length":1,"stats":{"Line":0}},{"line":90,"address":[723363,723653],"length":1,"stats":{"Line":0}},{"line":92,"address":[723419,723597,723668],"length":1,"stats":{"Line":0}},{"line":93,"address":[723764],"length":1,"stats":{"Line":0}},{"line":96,"address":[723561],"length":1,"stats":{"Line":0}},{"line":98,"address":[723449],"length":1,"stats":{"Line":0}},{"line":100,"address":[722362],"length":1,"stats":{"Line":0}},{"line":101,"address":[722446],"length":1,"stats":{"Line":0}},{"line":102,"address":[724204,724077],"length":1,"stats":{"Line":0}},{"line":104,"address":[724288],"length":1,"stats":{"Line":0}},{"line":107,"address":[681744,681937,681912],"length":1,"stats":{"Line":0}},{"line":108,"address":[681774],"length":1,"stats":{"Line":0}},{"line":109,"address":[681844],"length":1,"stats":{"Line":0}},{"line":113,"address":[724431,724479],"length":1,"stats":{"Line":0}},{"line":118,"address":[724519,724709],"length":1,"stats":{"Line":0}},{"line":119,"address":[724870,724789],"length":1,"stats":{"Line":0}},{"line":127,"address":[724944,725777,725711],"length":1,"stats":{"Line":0}},{"line":128,"address":[724971,725171],"length":1,"stats":{"Line":0}},{"line":129,"address":[725192,725250],"length":1,"stats":{"Line":0}},{"line":131,"address":[725267],"length":1,"stats":{"Line":0}},{"line":132,"address":[725365],"length":1,"stats":{"Line":0}},{"line":135,"address":[725372],"length":1,"stats":{"Line":0}},{"line":136,"address":[725453],"length":1,"stats":{"Line":0}},{"line":137,"address":[725506],"length":1,"stats":{"Line":0}},{"line":143,"address":[725808],"length":1,"stats":{"Line":0}},{"line":144,"address":[725824],"length":1,"stats":{"Line":0}},{"line":149,"address":[726216,726235,725872],"length":1,"stats":{"Line":0}},{"line":150,"address":[725907,725990],"length":1,"stats":{"Line":0}},{"line":155,"address":[726272,726809,726882],"length":1,"stats":{"Line":0}},{"line":157,"address":[726306],"length":1,"stats":{"Line":0}},{"line":158,"address":[726363,726468],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[681980,681952],"length":1,"stats":{"Line":0}},{"line":161,"address":[726497],"length":1,"stats":{"Line":0}},{"line":162,"address":[726505],"length":1,"stats":{"Line":0}},{"line":163,"address":[726715,726547],"length":1,"stats":{"Line":0}},{"line":164,"address":[726614],"length":1,"stats":{"Line":0}},{"line":171,"address":[726912,728672,728661],"length":1,"stats":{"Line":0}},{"line":172,"address":[728547,726974],"length":1,"stats":{"Line":0}},{"line":173,"address":[727163],"length":1,"stats":{"Line":0}},{"line":174,"address":[727664,727195,727460],"length":1,"stats":{"Line":0}},{"line":175,"address":[727914,727679],"length":1,"stats":{"Line":0}},{"line":176,"address":[727945,728008],"length":1,"stats":{"Line":0}},{"line":178,"address":[728070],"length":1,"stats":{"Line":0}},{"line":179,"address":[728118],"length":1,"stats":{"Line":0}},{"line":182,"address":[727238],"length":1,"stats":{"Line":0}},{"line":183,"address":[727270,729003,728799],"length":1,"stats":{"Line":0}},{"line":184,"address":[729253,729018],"length":1,"stats":{"Line":0}},{"line":185,"address":[729284,729347],"length":1,"stats":{"Line":0}},{"line":187,"address":[729409],"length":1,"stats":{"Line":0}},{"line":188,"address":[729457],"length":1,"stats":{"Line":0}},{"line":191,"address":[727313],"length":1,"stats":{"Line":0}},{"line":192,"address":[727345,730214,730010],"length":1,"stats":{"Line":0}},{"line":193,"address":[730229,730464],"length":1,"stats":{"Line":0}},{"line":194,"address":[730495,730558],"length":1,"stats":{"Line":0}},{"line":196,"address":[730620],"length":1,"stats":{"Line":0}},{"line":197,"address":[730668],"length":1,"stats":{"Line":0}},{"line":200,"address":[727388],"length":1,"stats":{"Line":0}},{"line":201,"address":[727420,731416,731218],"length":1,"stats":{"Line":0}},{"line":202,"address":[731666,731431],"length":1,"stats":{"Line":0}},{"line":203,"address":[731697,731760],"length":1,"stats":{"Line":0}},{"line":205,"address":[731822],"length":1,"stats":{"Line":0}},{"line":206,"address":[731870],"length":1,"stats":{"Line":0}},{"line":212,"address":[728641,732345],"length":1,"stats":{"Line":0}},{"line":213,"address":[732434],"length":1,"stats":{"Line":0}},{"line":214,"address":[732457],"length":1,"stats":{"Line":0}},{"line":219,"address":[732720,734721,734710],"length":1,"stats":{"Line":0}},{"line":220,"address":[734590,732782],"length":1,"stats":{"Line":0}},{"line":221,"address":[733035],"length":1,"stats":{"Line":0}},{"line":222,"address":[733067,733485,733689],"length":1,"stats":{"Line":0}},{"line":223,"address":[733951,733704],"length":1,"stats":{"Line":0}},{"line":224,"address":[733982,734051],"length":1,"stats":{"Line":0}},{"line":226,"address":[734113],"length":1,"stats":{"Line":0}},{"line":227,"address":[734161],"length":1,"stats":{"Line":0}},{"line":230,"address":[733110],"length":1,"stats":{"Line":0}},{"line":231,"address":[734854,733142,735058],"length":1,"stats":{"Line":0}},{"line":232,"address":[735073,735308],"length":1,"stats":{"Line":0}},{"line":233,"address":[735402,735339],"length":1,"stats":{"Line":0}},{"line":235,"address":[735464],"length":1,"stats":{"Line":0}},{"line":236,"address":[735512],"length":1,"stats":{"Line":0}},{"line":239,"address":[733185],"length":1,"stats":{"Line":0}},{"line":240,"address":[733217,736065,736269],"length":1,"stats":{"Line":0}},{"line":241,"address":[736284,736519],"length":1,"stats":{"Line":0}},{"line":242,"address":[736550,736613],"length":1,"stats":{"Line":0}},{"line":244,"address":[736675],"length":1,"stats":{"Line":0}},{"line":245,"address":[736723],"length":1,"stats":{"Line":0}},{"line":248,"address":[733260],"length":1,"stats":{"Line":0}},{"line":249,"address":[737276,733292,737480],"length":1,"stats":{"Line":0}},{"line":250,"address":[737495,737730],"length":1,"stats":{"Line":0}},{"line":251,"address":[737761,737824],"length":1,"stats":{"Line":0}},{"line":253,"address":[737886],"length":1,"stats":{"Line":0}},{"line":254,"address":[737934],"length":1,"stats":{"Line":0}},{"line":257,"address":[733335],"length":1,"stats":{"Line":0}},{"line":258,"address":[733367,738487,738691],"length":1,"stats":{"Line":0}},{"line":259,"address":[738706,738941],"length":1,"stats":{"Line":0}},{"line":260,"address":[739035,738972],"length":1,"stats":{"Line":0}},{"line":262,"address":[739097],"length":1,"stats":{"Line":0}},{"line":263,"address":[739145],"length":1,"stats":{"Line":0}},{"line":266,"address":[733410],"length":1,"stats":{"Line":0}},{"line":267,"address":[733442,739698,739902],"length":1,"stats":{"Line":0}},{"line":268,"address":[740152,739917],"length":1,"stats":{"Line":0}},{"line":269,"address":[740183,740246],"length":1,"stats":{"Line":0}},{"line":271,"address":[740308],"length":1,"stats":{"Line":0}},{"line":272,"address":[740356],"length":1,"stats":{"Line":0}},{"line":278,"address":[740831,734684],"length":1,"stats":{"Line":0}},{"line":279,"address":[740926],"length":1,"stats":{"Line":0}},{"line":280,"address":[740949],"length":1,"stats":{"Line":0}},{"line":285,"address":[741216,742098,742087],"length":1,"stats":{"Line":1}},{"line":286,"address":[741251],"length":1,"stats":{"Line":1}},{"line":287,"address":[741343],"length":1,"stats":{"Line":0}},{"line":288,"address":[741379],"length":1,"stats":{"Line":0}},{"line":291,"address":[741445],"length":1,"stats":{"Line":1}},{"line":294,"address":[741501],"length":1,"stats":{"Line":0}},{"line":295,"address":[741570],"length":1,"stats":{"Line":0}},{"line":296,"address":[741639],"length":1,"stats":{"Line":0}},{"line":297,"address":[742096,741919,741710],"length":1,"stats":{"Line":0}},{"line":298,"address":[742116,741759],"length":1,"stats":{"Line":0}},{"line":299,"address":[741808],"length":1,"stats":{"Line":0}},{"line":300,"address":[741820,742567,742356],"length":1,"stats":{"Line":0}},{"line":301,"address":[742860,742751],"length":1,"stats":{"Line":0}},{"line":303,"address":[742868],"length":1,"stats":{"Line":0}},{"line":304,"address":[743038,742886],"length":1,"stats":{"Line":0}},{"line":305,"address":[743046,743238,743180],"length":1,"stats":{"Line":0}},{"line":306,"address":[743309],"length":1,"stats":{"Line":0}},{"line":308,"address":[743502],"length":1,"stats":{"Line":0}},{"line":309,"address":[743572],"length":1,"stats":{"Line":0}},{"line":311,"address":[743877,741857],"length":1,"stats":{"Line":0}},{"line":317,"address":[745648,744048,746435],"length":1,"stats":{"Line":0}},{"line":318,"address":[744092],"length":1,"stats":{"Line":0}},{"line":319,"address":[744267,744181,744352],"length":1,"stats":{"Line":0}},{"line":320,"address":[744579,744327,744373],"length":1,"stats":{"Line":0}},{"line":322,"address":[744659,744886],"length":1,"stats":{"Line":0}},{"line":323,"address":[744909],"length":1,"stats":{"Line":0}},{"line":324,"address":[744927,745078],"length":1,"stats":{"Line":0}},{"line":325,"address":[745086,745220,745278],"length":1,"stats":{"Line":0}},{"line":329,"address":[744209],"length":1,"stats":{"Line":0}},{"line":330,"address":[745758,744227],"length":1,"stats":{"Line":0}},{"line":331,"address":[745936,746164],"length":1,"stats":{"Line":0}},{"line":335,"address":[745599],"length":1,"stats":{"Line":0}},{"line":337,"address":[746241],"length":1,"stats":{"Line":0}},{"line":342,"address":[749187,749611,746576],"length":1,"stats":{"Line":0}},{"line":344,"address":[746811,746619],"length":1,"stats":{"Line":0}},{"line":345,"address":[746843],"length":1,"stats":{"Line":0}},{"line":346,"address":[747060,747122],"length":1,"stats":{"Line":0}},{"line":347,"address":[746944],"length":1,"stats":{"Line":0}},{"line":348,"address":[747012],"length":1,"stats":{"Line":0}},{"line":351,"address":[747246],"length":1,"stats":{"Line":0}},{"line":353,"address":[747305],"length":1,"stats":{"Line":0}},{"line":356,"address":[747388],"length":1,"stats":{"Line":0}},{"line":359,"address":[747525,748107,747496,747440],"length":1,"stats":{"Line":0}},{"line":361,"address":[747546],"length":1,"stats":{"Line":0}},{"line":362,"address":[747690,747621],"length":1,"stats":{"Line":0}},{"line":363,"address":[747847,749513],"length":1,"stats":{"Line":0}},{"line":365,"address":[748092],"length":1,"stats":{"Line":0}},{"line":367,"address":[747507],"length":1,"stats":{"Line":0}},{"line":369,"address":[748117],"length":1,"stats":{"Line":0}},{"line":370,"address":[748425],"length":1,"stats":{"Line":0}},{"line":371,"address":[748505],"length":1,"stats":{"Line":0}},{"line":372,"address":[748558],"length":1,"stats":{"Line":0}},{"line":375,"address":[748645,748717],"length":1,"stats":{"Line":0}},{"line":376,"address":[749196,748742],"length":1,"stats":{"Line":0}},{"line":383,"address":[748772,748731],"length":1,"stats":{"Line":0}},{"line":386,"address":[748798],"length":1,"stats":{"Line":0}},{"line":387,"address":[748838],"length":1,"stats":{"Line":0}},{"line":388,"address":[748876],"length":1,"stats":{"Line":0}},{"line":390,"address":[749098],"length":1,"stats":{"Line":0}},{"line":393,"address":[748783],"length":1,"stats":{"Line":0}},{"line":397,"address":[748305,749447],"length":1,"stats":{"Line":0}},{"line":403,"address":[748343],"length":1,"stats":{"Line":0}},{"line":408,"address":[749648,749964,749993],"length":1,"stats":{"Line":0}},{"line":409,"address":[749694,749826],"length":1,"stats":{"Line":0}},{"line":411,"address":[749834],"length":1,"stats":{"Line":0}},{"line":412,"address":[749915],"length":1,"stats":{"Line":0}},{"line":413,"address":[749932],"length":1,"stats":{"Line":0}},{"line":415,"address":[749944],"length":1,"stats":{"Line":0}},{"line":423,"address":[751402,751263,750016],"length":1,"stats":{"Line":0}},{"line":424,"address":[750051,750199],"length":1,"stats":{"Line":0}},{"line":426,"address":[750207],"length":1,"stats":{"Line":0}},{"line":427,"address":[750266],"length":1,"stats":{"Line":0}},{"line":428,"address":[751309,750291],"length":1,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[750461,750381,750668,750274],"length":1,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[750753],"length":1,"stats":{"Line":0}},{"line":441,"address":[750806],"length":1,"stats":{"Line":0}},{"line":442,"address":[751127],"length":1,"stats":{"Line":0}},{"line":443,"address":[750951,750888],"length":1,"stats":{"Line":0}},{"line":444,"address":[751067,750971],"length":1,"stats":{"Line":0}},{"line":451,"address":[751936,751440],"length":1,"stats":{"Line":0}},{"line":452,"address":[751475],"length":1,"stats":{"Line":0}},{"line":454,"address":[751549,751625,751728],"length":1,"stats":{"Line":0}},{"line":455,"address":[751841,751904],"length":1,"stats":{"Line":0}},{"line":458,"address":[751870],"length":1,"stats":{"Line":0}},{"line":463,"address":[753710,753898,751984],"length":1,"stats":{"Line":0}},{"line":464,"address":[752028,752215],"length":1,"stats":{"Line":0}},{"line":466,"address":[752284,752223],"length":1,"stats":{"Line":0}},{"line":467,"address":[752376],"length":1,"stats":{"Line":0}},{"line":468,"address":[752332],"length":1,"stats":{"Line":0}},{"line":473,"address":[752529,752739,752555,752455],"length":1,"stats":{"Line":0}},{"line":474,"address":[752705,752562],"length":1,"stats":{"Line":0}},{"line":476,"address":[752535],"length":1,"stats":{"Line":0}},{"line":481,"address":[752638,752814],"length":1,"stats":{"Line":0}},{"line":485,"address":[682000,682028],"length":1,"stats":{"Line":0}},{"line":489,"address":[752883],"length":1,"stats":{"Line":0}},{"line":490,"address":[752904,753056],"length":1,"stats":{"Line":0}},{"line":491,"address":[753072],"length":1,"stats":{"Line":0}},{"line":492,"address":[753147],"length":1,"stats":{"Line":0}},{"line":493,"address":[753211],"length":1,"stats":{"Line":0}},{"line":496,"address":[753373],"length":1,"stats":{"Line":0}},{"line":498,"address":[753380],"length":1,"stats":{"Line":0}},{"line":499,"address":[753421,753544],"length":1,"stats":{"Line":0}},{"line":500,"address":[753500],"length":1,"stats":{"Line":0}},{"line":506,"address":[754345,753936,754373],"length":1,"stats":{"Line":0}},{"line":507,"address":[753971],"length":1,"stats":{"Line":0}},{"line":508,"address":[754076],"length":1,"stats":{"Line":0}},{"line":509,"address":[754133],"length":1,"stats":{"Line":0}},{"line":510,"address":[754151,754209],"length":1,"stats":{"Line":0}},{"line":511,"address":[754317],"length":1,"stats":{"Line":0}},{"line":513,"address":[754016],"length":1,"stats":{"Line":0}},{"line":519,"address":[755435,755494,754384],"length":1,"stats":{"Line":0}},{"line":520,"address":[754418,754504],"length":1,"stats":{"Line":0}},{"line":521,"address":[754524],"length":1,"stats":{"Line":0}},{"line":522,"address":[754664,754791,754544],"length":1,"stats":{"Line":0}},{"line":523,"address":[754944,755452],"length":1,"stats":{"Line":0}},{"line":526,"address":[754969],"length":1,"stats":{"Line":0}},{"line":527,"address":[755006],"length":1,"stats":{"Line":0}},{"line":528,"address":[755208],"length":1,"stats":{"Line":0}},{"line":529,"address":[755304],"length":1,"stats":{"Line":0}},{"line":530,"address":[755334],"length":1,"stats":{"Line":0}},{"line":532,"address":[755114,755346],"length":1,"stats":{"Line":0}},{"line":534,"address":[755087],"length":1,"stats":{"Line":0}},{"line":537,"address":[755100],"length":1,"stats":{"Line":0}},{"line":539,"address":[755396],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":255},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","linearizer","walkcontext.rs"],"content":"use std::collections::{HashMap, HashSet};\n\nuse crate::{\n    frontend::{ast, sourceloc::SourceLoc},\n    midend::{ir, symtab, symtab::*, types::Type},\n};\n\nuse super::treewalk::*;\n\npub struct WalkContext\u003c'a\u003e {\n    control_flow: ir::ControlFlow,\n    branch_points: HashMap\u003cusize, HashSet\u003cusize\u003e\u003e, // map from branch origin to set of target blocks\n    convergence_points: HashMap\u003cusize, usize\u003e, // map of label -\u003e label that block should jump to when done\n    global_scope: \u0026'a symtab::Scope,\n    scopes: Vec\u003csymtab::Scope\u003e,\n    // index of number of temporary variables used in this control flow (across all blocks)\n    temp_num: usize,\n    current_block: usize,\n}\n\nimpl\u003c'a\u003e WalkContext\u003c'a\u003e {\n    pub fn new(global_scope: \u0026'a Scope) -\u003e WalkContext\u003c'a\u003e {\n        let starter_flow = ir::ControlFlow::new();\n\n        let mut convergence_points = HashMap::\u003cusize, usize\u003e::new();\n        convergence_points.insert(0, 1);\n\n        WalkContext {\n            control_flow: starter_flow,\n            branch_points: HashMap::\u003cusize, HashSet\u003cusize\u003e\u003e::new(),\n            convergence_points,\n            global_scope,\n            scopes: Vec::new(),\n            temp_num: 0,\n            current_block: 0,\n        }\n    }\n\n    pub fn take_control_flow(mut self) -\u003e ir::ControlFlow {\n        for (from, to) in self.convergence_points.clone() {\n            assert_eq!(self.converge_block(from), to); // TODO: need assert?\n        }\n        self.control_flow\n    }\n\n    fn replace_branch_and_convergence_points(\u0026mut self, old_block: usize, new_block: usize) {\n        // replace all instances of old_block with new_block in both branch and convergence point tracking\n        // self.branch_points = self\n        //     .branch_points\n        //     .iter()\n        //     .map(|(source, dest_set)| {\n        //         (\n        //             if *source == old_block {\n        //                 new_block\n        //             } else {\n        //                 *source\n        //             },\n        //             dest_set\n        //                 .into_iter()\n        //                 .map(|target| {\n        //                     if *target == old_block {\n        //                         new_block\n        //                     } else {\n        //                         *target\n        //                     }\n        //                 })\n        //                 .collect(),\n        //         )\n        //     })\n        //     .collect();\n\n        self.convergence_points = self\n            .convergence_points\n            .iter()\n            .map(|(from, to)| {\n                (\n                    if *from == old_block { new_block } else { *from },\n                    if *to == old_block { new_block } else { *to },\n                )\n            })\n            .collect();\n    }\n\n    pub fn append_statement_to_current_block(\u0026mut self, statement: ir::IrLine) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(_) =\u003e {\n                panic!(\"WalkContext::append_statement_to_current_block does NOT support jumps!\")\n            }\n            _ =\u003e {}\n        }\n        self.append_to_current_block(statement);\n    }\n\n    ///appends the given statement to the current basic block\n    ///if the statement is any sort of branch, the current block will be updated to be the target of the branch\n    ///if the branch is conditional, the function returns Some(false_label) where false_label is the target of the\n    ///block control flows to when the condition is not met\n    ///for unconditional branches and other statements, returns None\n    fn append_to_current_block(\u0026mut self, statement: ir::IrLine) -\u003e Option\u003cusize\u003e {\n        match self\n            .control_flow\n            .append_statement_to_block(statement, self.current_block)\n        {\n            (Some(new_current), false_label) =\u003e {\n                self.replace_branch_and_convergence_points(self.current_block, new_current);\n                self.set_current_block(new_current);\n                false_label\n            }\n            (None, _) =\u003e None,\n        }\n    }\n\n    /// creates a branch from the current block based on a condition\n    /// returns the target of the branch\n    fn create_branch_from_current(\u0026mut self) -\u003e usize {\n        let branch_target = self.control_flow.next_block();\n\n        match self.branch_points.get(\u0026self.current_block) {\n            Some(_) =\u003e panic!(\n                \"create_branch_from_current called with existing branch (from block {})\",\n                self.current_block\n            ),\n            None =\u003e {\n                self.branch_points\n                    .insert(self.current_block, HashSet::new());\n            }\n        };\n\n        self.branch_points\n            .get_mut(\u0026self.current_block)\n            .unwrap()\n            .insert(branch_target);\n        branch_target\n    }\n\n    fn add_branch(\u0026mut self, from: usize, to: usize) {\n        self.branch_points\n            .get_mut(\u0026from)\n            .expect(\"add_branch expects existing branch\")\n            .insert(to);\n    }\n\n    fn add_convergence_point_for_branch(\u0026mut self, from: usize, to: usize) {\n        match self.convergence_points.insert(from, to) {\n            Some(existing_convergence) =\u003e {\n                if existing_convergence != to {\n                    self.add_convergence_point_for_branch(to, existing_convergence);\n                }\n            }\n            None =\u003e {}\n        }\n    }\n\n    fn create_convergence_points_for_branch(\u0026mut self, branch_from: usize) -\u003e usize {\n        let convergence_point = match self.convergence_points.get(\u0026branch_from) {\n            Some(existing_convergence) =\u003e *existing_convergence,\n            None =\u003e self.control_flow.next_block(),\n        };\n\n        for branch_target in self\n            .branch_points\n            .get(\u0026branch_from)\n            .expect(\"Creation of convergence points requires existence of branch(es)\")\n            .clone()\n        {\n            self.add_convergence_point_for_branch(branch_target, convergence_point);\n        }\n        convergence_point\n    }\n\n    ///append an unconditional jump from the end of block_label to its convergence point\n    ///return the block to which control has converged\n    fn converge_block(\u0026mut self, block_label: usize) -\u003e usize {\n        let converge_to = self\n            .convergence_points\n            .remove(\u0026block_label)\n            .expect(\u0026format!(\"Block {} has no convergence point\", block_label));\n\n        let convergence_jump = ir::IrLine::new_jump(\n            SourceLoc::none(),\n            converge_to,\n            ir::JumpCondition::Unconditional,\n        );\n        // ignore return value - appending an unconditional jump\n        self.control_flow\n            .append_statement_to_block(convergence_jump, block_label);\n        converge_to\n    }\n\n    pub fn converge_current_block(\u0026mut self) {\n        let converged_to = self.converge_block(self.current_block);\n        self.set_current_block(converged_to);\n    }\n\n    pub fn set_current_block(\u0026mut self, label: usize) {\n        self.current_block = label;\n    }\n\n    pub fn create_conditional_branch_from_current(\n        \u0026mut self,\n        loc: SourceLoc,\n        condition: ir::JumpCondition,\n    ) -\u003e (usize, Option\u003cusize\u003e) {\n        let branch_origin = self.current_block;\n        let true_label = self.create_branch_from_current();\n\n        let true_condition_jump = ir::IrLine::new_jump(loc, true_label, condition);\n        let maybe_false_label = self.append_to_current_block(true_condition_jump);\n        match maybe_false_label {\n            Some(false_label) =\u003e self.add_branch(branch_origin, false_label),\n            None =\u003e {}\n        }\n\n        self.create_convergence_points_for_branch(branch_origin);\n\n        (true_label, maybe_false_label)\n    }\n\n    ///returns the label which control jumps to after the loop\n    pub fn create_loop(\u0026mut self, loc: SourceLoc, condition: ast::ExpressionTree) -\u003e usize {\n        // first, jump to a fresh block which will be the top of the loop\n        let loop_top = self.control_flow.next_block();\n        let loop_entry = ir::IrLine::new_jump(loc, loop_top, ir::JumpCondition::Unconditional);\n        // ignore return value - appending an unconditional jump\n        self.append_to_current_block(loop_entry);\n\n        // FUTURE: optimize condition walk to use different jumps\n        // check the condition of the loop, giving us the loop body and loop done labels\n        let condition_loc = condition.loc.clone();\n        let condition_result: ir::Operand = condition.walk(self).into();\n        let loop_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n        let (_, loop_done_label) =\n            self.create_conditional_branch_from_current(condition_loc, loop_condition);\n        let loop_done_label = loop_done_label.unwrap();\n\n        self.convergence_points.insert(self.current_block, loop_top);\n        self.converge_block(loop_done_label);\n\n        loop_done_label\n    }\n\n    pub fn next_temp(\u0026mut self, type_: Type) -\u003e ir::Operand {\n        let temp_name = String::from(\".T\") + \u0026self.temp_num.to_string();\n        self.temp_num += 1;\n        self.scope()\n            .insert_variable(symtab::Variable::new(temp_name.clone(), type_));\n        ir::Operand::new_as_temporary(temp_name)\n    }\n\n    pub fn push_scope(\u0026mut self, scope: symtab::Scope) {\n        self.scopes.push(scope)\n    }\n\n    pub fn pop_scope_to_subscope_of_next(\u0026mut self) {\n        let popped = self\n            .scopes\n            .pop()\n            .expect(\"WalkContext::pop_scope_to_subscope_of_next expects valid scope\");\n        self.scope().insert_subscope(popped);\n    }\n\n    pub fn pop_last_scope(\u0026mut self) -\u003e symtab::Scope {\n        if self.scopes.len() \u003e 1 {\n            panic!(\n                \"WalkContext::pop_last_scope() called with {} parent scopes\",\n                self.scopes.len()\n            );\n        }\n\n        self.scopes\n            .pop()\n            .expect(\"WalkContext::pop_last_scope() called with no scopese\")\n    }\n\n    pub fn scope(\u0026mut self) -\u003e \u0026mut symtab::Scope {\n        self.scopes\n            .last_mut()\n            .expect(\"WalkContext::scope() expects valid scope\")\n    }\n\n    // TODO: check ordering\n    fn all_scopes(\u0026self) -\u003e std::vec::IntoIter\u003c\u0026Scope\u003e {\n        let mut scopes_ref: Vec\u003c\u0026Scope\u003e = self.scopes.iter().rev().collect();\n        scopes_ref.push(\u0026self.global_scope);\n        scopes_ref.into_iter()\n    }\n\n    pub fn lookup_variable_by_name(\n        \u0026self,\n        name: \u0026ir::OperandName,\n    ) -\u003e Result\u003c\u0026symtab::Variable, UndefinedSymbolError\u003e {\n        for scope in self.all_scopes() {\n            match scope.lookup_variable_by_name(\u0026name.base_name) {\n                Ok(variable) =\u003e return Ok(variable),\n                _ =\u003e {}\n            }\n        }\n\n        Err(UndefinedSymbolError::variable(\u0026name.base_name))\n    }\n\n    pub fn lookup_type(\u0026self, type_: \u0026Type) -\u003e Result\u003c\u0026TypeDefinition, UndefinedSymbolError\u003e {\n        for scope in self.all_scopes() {\n            match scope.lookup_type(type_) {\n                Ok(variable) =\u003e return Ok(variable),\n                _ =\u003e {}\n            }\n        }\n\n        Err(UndefinedSymbolError::type_(\u0026type_))\n    }\n\n    pub fn lookup_struct(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026StructRepr, UndefinedSymbolError\u003e {\n        for scope in self.all_scopes() {\n            match scope.lookup_struct(name) {\n                Ok(variable) =\u003e return Ok(variable),\n                _ =\u003e {}\n            }\n        }\n\n        Err(UndefinedSymbolError::struct_(\u0026name))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        frontend::{ast, sourceloc::SourceLoc},\n        midend::{ir, linearizer::walkcontext::WalkContext, symtab},\n    };\n\n    fn assert_no_remaining_convergences(context: WalkContext) {\n        // allow convergence to block 1 as that should be the final block in the control flow\n        for (from, to) in context.convergence_points {\n            assert_eq!(to, 1);\n        }\n    }\n\n    fn assert_branch(context: \u0026WalkContext, from: usize, to: usize) {\n        let branches = context.branch_points.get(\u0026from);\n        assert!(branches.is_some());\n        let branches = branches.unwrap();\n        assert!(branches.contains(\u0026to));\n    }\n\n    fn assert_convergence(context: \u0026WalkContext, from: usize, to: usize) {\n        let convergence = context.convergence_points.get(\u0026from);\n        assert_eq!(convergence, Some(\u0026to));\n    }\n\n    #[test]\n    fn walk_context_initial_state() {\n        let global_scope = symtab::Scope::new();\n        let context = WalkContext::new(\u0026global_scope);\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn append_statement() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n        let assignment = ir::IrLine::new_assignment(\n            SourceLoc::none(),\n            ir::Operand::new_as_variable(\"dest\".into()),\n            ir::Operand::new_as_variable(\"source\".into()),\n        );\n        context.append_statement_to_current_block(assignment);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_branch() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n    }\n\n    #[test]\n    fn add_branch() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n        assert_eq!(branch_to, 2);\n        assert_eq!(second_branch_to, 3);\n    }\n\n    #[test]\n    fn simple_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n    }\n\n    #[test]\n    fn complex_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        // create the convergence point and assert that both branch targets converge to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn simple_multiple_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 2 targets, nested in a branch with one target\n    #[test]\n    fn complex_multiple_branch_convergence_points() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // and add to that second branch a second target\n        let second_nested_branch_to = context.control_flow.next_block();\n        context.add_branch(nested_branch_from, second_nested_branch_to);\n        assert_branch(\u0026context, nested_branch_from, second_nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 1 target, nested within a branch with 2 targets\n    #[test]\n    fn complex_multiple_branch_convergence_points_2() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_to, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(branch_to);\n        assert_convergence(\u0026context, branch_to, nested_converge_to);\n\n        // and re-assert our original convergence\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn converge_block() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        assert_eq!(context.converge_block(branch_to), converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn converge_current_block() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        context.set_current_block(branch_to);\n        context.converge_current_block();\n\n        assert_eq!(context.current_block, converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_loop() {\n        let global_scope = symtab::Scope::new();\n        let mut context = WalkContext::new(\u0026global_scope);\n        context.push_scope(symtab::Scope::new());\n\n        let before_loop = context.current_block;\n\n        let loop_done = context.create_loop(\n            SourceLoc::none(),\n            ast::ExpressionTree {\n                loc: SourceLoc::none(),\n                expression: { ast::Expression::UnsignedDecimalConstant(123) },\n            },\n        );\n\n        assert_ne!(before_loop, context.current_block);\n        assert_ne!(loop_done, context.current_block);\n\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n\n        assert_no_remaining_convergences(context);\n    }\n}\n","traces":[{"line":22,"address":[893185,892560,893143],"length":1,"stats":{"Line":1}},{"line":23,"address":[892589],"length":1,"stats":{"Line":11}},{"line":25,"address":[892628],"length":1,"stats":{"Line":1}},{"line":26,"address":[892676],"length":1,"stats":{"Line":11}},{"line":30,"address":[892811],"length":1,"stats":{"Line":1}},{"line":33,"address":[892910],"length":1,"stats":{"Line":11}},{"line":39,"address":[893634,893216],"length":1,"stats":{"Line":0}},{"line":40,"address":[893391,893301,893238],"length":1,"stats":{"Line":0}},{"line":41,"address":[893660,893442],"length":1,"stats":{"Line":0}},{"line":43,"address":[893481],"length":1,"stats":{"Line":0}},{"line":46,"address":[893808,893967],"length":1,"stats":{"Line":1}},{"line":72,"address":[894006,893843],"length":1,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[383008,383038],"length":1,"stats":{"Line":2}},{"line":77,"address":[383048],"length":1,"stats":{"Line":1}},{"line":78,"address":[383101],"length":1,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[894278,894048,894253],"length":1,"stats":{"Line":1}},{"line":85,"address":[894073],"length":1,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[894115,894220],"length":1,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[894139],"length":1,"stats":{"Line":1}},{"line":99,"address":[894288],"length":1,"stats":{"Line":1}},{"line":100,"address":[894305,894319],"length":1,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[894312],"length":1,"stats":{"Line":1}},{"line":104,"address":[894345],"length":1,"stats":{"Line":1}},{"line":105,"address":[894390],"length":1,"stats":{"Line":1}},{"line":106,"address":[894412],"length":1,"stats":{"Line":1}},{"line":107,"address":[894427],"length":1,"stats":{"Line":1}},{"line":109,"address":[894439],"length":1,"stats":{"Line":1}},{"line":115,"address":[894464],"length":1,"stats":{"Line":1}},{"line":116,"address":[894484],"length":1,"stats":{"Line":8}},{"line":118,"address":[894511],"length":1,"stats":{"Line":1}},{"line":119,"address":[894561],"length":1,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[894649,894696],"length":1,"stats":{"Line":16}},{"line":125,"address":[894717,894661],"length":1,"stats":{"Line":2}},{"line":129,"address":[894735,894749],"length":1,"stats":{"Line":16}},{"line":130,"address":[894742],"length":1,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[894800],"length":1,"stats":{"Line":3}},{"line":137,"address":[894824],"length":1,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[894896],"length":1,"stats":{"Line":6}},{"line":144,"address":[894925],"length":1,"stats":{"Line":1}},{"line":145,"address":[894963],"length":1,"stats":{"Line":1}},{"line":146,"address":[894977],"length":1,"stats":{"Line":1}},{"line":147,"address":[895001],"length":1,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[895008,895389],"length":1,"stats":{"Line":1}},{"line":155,"address":[895033],"length":1,"stats":{"Line":4}},{"line":156,"address":[895083],"length":1,"stats":{"Line":2}},{"line":157,"address":[895111],"length":1,"stats":{"Line":1}},{"line":160,"address":[895130,895295],"length":1,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[895384,895346],"length":1,"stats":{"Line":7}},{"line":168,"address":[895371],"length":1,"stats":{"Line":1}},{"line":173,"address":[895424,895813],"length":1,"stats":{"Line":1}},{"line":174,"address":[895449,895676],"length":1,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[895708,895483],"length":1,"stats":{"Line":2}},{"line":180,"address":[895719],"length":1,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[895732],"length":1,"stats":{"Line":1}},{"line":185,"address":[895770],"length":1,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[895840],"length":1,"stats":{"Line":1}},{"line":191,"address":[895853],"length":1,"stats":{"Line":1}},{"line":192,"address":[895877],"length":1,"stats":{"Line":1}},{"line":195,"address":[895888],"length":1,"stats":{"Line":3}},{"line":196,"address":[895898],"length":1,"stats":{"Line":1}},{"line":199,"address":[896384,895920,896409],"length":1,"stats":{"Line":1}},{"line":204,"address":[895989],"length":1,"stats":{"Line":1}},{"line":205,"address":[896098,896025],"length":1,"stats":{"Line":2}},{"line":207,"address":[896106],"length":1,"stats":{"Line":1}},{"line":208,"address":[896227],"length":1,"stats":{"Line":1}},{"line":209,"address":[896268],"length":1,"stats":{"Line":1}},{"line":210,"address":[896332,896292],"length":1,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[896325],"length":1,"stats":{"Line":1}},{"line":216,"address":[896349],"length":1,"stats":{"Line":1}},{"line":220,"address":[896432,897263],"length":1,"stats":{"Line":1}},{"line":222,"address":[896483,896579],"length":1,"stats":{"Line":2}},{"line":223,"address":[896587],"length":1,"stats":{"Line":1}},{"line":225,"address":[896629],"length":1,"stats":{"Line":1}},{"line":229,"address":[896641],"length":1,"stats":{"Line":1}},{"line":230,"address":[896714],"length":1,"stats":{"Line":1}},{"line":231,"address":[896931,896993],"length":1,"stats":{"Line":2}},{"line":232,"address":[896815],"length":1,"stats":{"Line":1}},{"line":233,"address":[896883],"length":1,"stats":{"Line":1}},{"line":235,"address":[897124],"length":1,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[897156],"length":1,"stats":{"Line":1}},{"line":239,"address":[897196],"length":1,"stats":{"Line":1}},{"line":240,"address":[897226],"length":1,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[897312,898009,897965],"length":1,"stats":{"Line":0}},{"line":246,"address":[897974,897347,897449],"length":1,"stats":{"Line":0}},{"line":247,"address":[897740,897690],"length":1,"stats":{"Line":0}},{"line":248,"address":[897728,897864],"length":1,"stats":{"Line":0}},{"line":249,"address":[897760],"length":1,"stats":{"Line":0}},{"line":250,"address":[897876],"length":1,"stats":{"Line":0}},{"line":253,"address":[898048],"length":1,"stats":{"Line":1}},{"line":254,"address":[898053],"length":1,"stats":{"Line":1}},{"line":257,"address":[898295,898320,898080],"length":1,"stats":{"Line":0}},{"line":258,"address":[898103],"length":1,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[898222,898176],"length":1,"stats":{"Line":0}},{"line":265,"address":[898336],"length":1,"stats":{"Line":0}},{"line":266,"address":[898374],"length":1,"stats":{"Line":0}},{"line":267,"address":[898468],"length":1,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[898390],"length":1,"stats":{"Line":0}},{"line":278,"address":[898560],"length":1,"stats":{"Line":0}},{"line":279,"address":[898565],"length":1,"stats":{"Line":0}},{"line":285,"address":[898624,898846,898824],"length":1,"stats":{"Line":0}},{"line":286,"address":[898656],"length":1,"stats":{"Line":0}},{"line":287,"address":[898721],"length":1,"stats":{"Line":0}},{"line":288,"address":[898772],"length":1,"stats":{"Line":0}},{"line":291,"address":[898864,899365],"length":1,"stats":{"Line":0}},{"line":295,"address":[898902,899044],"length":1,"stats":{"Line":0}},{"line":296,"address":[899232,899109],"length":1,"stats":{"Line":0}},{"line":297,"address":[899299],"length":1,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[899148],"length":1,"stats":{"Line":0}},{"line":305,"address":[899811,899392],"length":1,"stats":{"Line":0}},{"line":306,"address":[899422,899549],"length":1,"stats":{"Line":0}},{"line":307,"address":[899688,899604],"length":1,"stats":{"Line":0}},{"line":308,"address":[899748],"length":1,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[899634],"length":1,"stats":{"Line":0}},{"line":316,"address":[899840,900272],"length":1,"stats":{"Line":0}},{"line":317,"address":[899875,900000],"length":1,"stats":{"Line":0}},{"line":318,"address":[900055,900149],"length":1,"stats":{"Line":0}},{"line":319,"address":[900209],"length":1,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[900090],"length":1,"stats":{"Line":0}}],"covered":78,"coverable":149},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","linearizer.rs"],"content":"use treewalk::TableWalk;\n\nuse crate::frontend::ast::TranslationUnitTree;\n\nuse super::symtab::SymbolTable;\n\nmod treewalk;\npub mod walkcontext;\n\npub fn linearize(symtab: \u0026mut SymbolTable, program: Vec\u003cTranslationUnitTree\u003e) {\n    for translation_unit in program {\n        translation_unit.walk(symtab);\n    }\n}\n","traces":[{"line":10,"address":[699476,699248],"length":1,"stats":{"Line":0}},{"line":11,"address":[699268,699372],"length":1,"stats":{"Line":0}},{"line":12,"address":[699471,699446],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","optimization","unused_blocks.rs"],"content":"// use std::collections::{BTreeSet, HashMap, HashSet};\n\n// use crate::midend::{\n//     ir::{self, ControlFlow},\n//     symtab::Function,\n// };\n\n// pub fn remove_unused_blocks(function: \u0026mut Function) {\n//     let mut block_references = HashMap::\u003cusize, usize\u003e::new();\n\n//     for label_num in 0..function.control_flow.blocks.len() {\n//         block_references.entry(label_num).or_insert(0);\n//         for target in \u0026function.control_flow.successors[label_num] {\n//             *block_references.entry(*target).or_insert(0) += 1;\n//         }\n//     }\n\n//     let mut block_labels_to_remove = BTreeSet::\u003cusize\u003e::new();\n\n//     for (block, rc) in block_references {\n//         println!(\"{}:{}\", block, rc);\n//         if rc == 0 {\n//             block_labels_to_remove.insert(block);\n//         }\n//     }\n\n//     let mut block_labels_to_rename = HashMap::\u003cusize, usize\u003e::new();\n//     for label_num in \u0026block_labels_to_remove {\n//         for affected in *label_num..function.control_flow.blocks.len() {\n//             if !block_labels_to_remove.contains(\u0026affected) {\n//                 *block_labels_to_rename.entry(affected).or_insert(affected) -= 1;\n//             }\n//         }\n//     }\n\n//     for (orig, renamed) in \u0026block_labels_to_rename {\n//         println!(\"{}-\u003e{}\", orig, renamed);\n//     }\n\n//     for block in \u0026mut function.control_flow.blocks {\n//         for statement in block.statements_mut() {\n//             match \u0026mut statement.operation {\n//                 ir::Operations::Jump(jump) =\u003e {\n//                     let original_destination = jump.destination_block;\n//                     jump.destination_block = match block_labels_to_rename.get(\u0026original_destination)\n//                     {\n//                         Some(new_label) =\u003e *new_label,\n//                         None =\u003e original_destination,\n//                     };\n//                 }\n//                 _ =\u003e {}\n//             }\n//         }\n//     }\n\n//     for (old_label, new_label) in \u0026block_labels_to_rename {\n//         function.control_flow.blocks[*old_label].label = *new_label;\n//         println!(\"Rename {}-\u003e{}\", old_label, new_label);\n//     }\n\n//     for remove in block_labels_to_remove.iter().rev() {\n//         println!(\"Remove unused block {}\", remove);\n//         function.control_flow.blocks.remove(*remove);\n//         function.control_flow.successors.remove(*remove);\n//         function.control_flow.predecessors.remove(*remove);\n//     }\n\n//     for predecessor_set in \u0026mut function.control_flow.predecessors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for predecessor in predecessor_set.iter() {\n//             let original_predecessor = predecessor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *predecessor,\n//             });\n//         }\n\n//         *predecessor_set = new_set;\n//     }\n\n//     for successor_set in \u0026mut function.control_flow.successors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for successor in successor_set.iter() {\n//             let original_predecessor = successor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *successor,\n//             });\n//         }\n\n//         *successor_set = new_set;\n//     }\n\n//     function.control_flow.to_graphviz();\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","optimization.rs"],"content":"use std::collections::HashMap;\n\nuse super::symtab::{Function, FunctionOrPrototype};\n\nmod unused_blocks;\n\nfn do_optimizations_on_function(_function: \u0026mut Function) {\n    // unused_blocks::remove_unused_blocks(function);\n}\n\npub fn optimize_functions(functions: \u0026mut HashMap\u003cString, FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            FunctionOrPrototype::Prototype(_) =\u003e {}\n            FunctionOrPrototype::Function(function) =\u003e do_optimizations_on_function(function),\n        };\n    }\n}\n","traces":[{"line":7,"address":[554448],"length":1,"stats":{"Line":0}},{"line":11,"address":[554464],"length":1,"stats":{"Line":0}},{"line":12,"address":[554479],"length":1,"stats":{"Line":0}},{"line":13,"address":[554572],"length":1,"stats":{"Line":0}},{"line":15,"address":[554619],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa.rs"],"content":"struct SsaBlock {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen","add_block_args.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse crate::midend::idfa::block_args::IdfaImplementor;\nuse crate::midend::{\n    idfa::{self},\n    ir, symtab,\n};\n\npub fn add_block_arguments(function: \u0026mut symtab::Function) {\n    let mut block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n\n    loop {\n        let mut args_by_block = HashMap::\u003cusize, BTreeSet\u003cir::OperandName\u003e\u003e::new();\n        for (label, block) in \u0026mut function.control_flow.blocks {\n            block.arguments = block_args.for_label(*label).out_facts.clone();\n            args_by_block.insert(*label, block.arguments.clone());\n        }\n\n        for block in function.control_flow.blocks.values_mut() {\n            for statement in \u0026mut block.statements {\n                match \u0026mut statement.operation {\n                    ir::Operations::Jump(jump) =\u003e {\n                        for target_arg in args_by_block.get(\u0026jump.destination_block).unwrap() {\n                            jump.block_args\n                                .insert(target_arg.clone(), target_arg.clone());\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        let new_block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n        if new_block_args != block_args {\n            block_args = new_block_args;\n        } else {\n            break;\n        }\n    }\n}\n","traces":[{"line":9,"address":[295815,295060,294080],"length":1,"stats":{"Line":0}},{"line":10,"address":[294106],"length":1,"stats":{"Line":0}},{"line":13,"address":[294171],"length":1,"stats":{"Line":0}},{"line":14,"address":[294226,294285],"length":1,"stats":{"Line":0}},{"line":15,"address":[295596,294441],"length":1,"stats":{"Line":0}},{"line":16,"address":[295740],"length":1,"stats":{"Line":0}},{"line":19,"address":[294475],"length":1,"stats":{"Line":0}},{"line":20,"address":[295079,294626],"length":1,"stats":{"Line":0}},{"line":21,"address":[295184],"length":1,"stats":{"Line":0}},{"line":22,"address":[295215],"length":1,"stats":{"Line":0}},{"line":23,"address":[295223],"length":1,"stats":{"Line":0}},{"line":24,"address":[295508,295414],"length":1,"stats":{"Line":0}},{"line":25,"address":[295431,295547],"length":1,"stats":{"Line":0}},{"line":33,"address":[294654],"length":1,"stats":{"Line":0}},{"line":34,"address":[294779,294723],"length":1,"stats":{"Line":0}},{"line":35,"address":[294800,294915],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen","convert_reads.rs"],"content":"use std::collections::BTreeMap;\n\nuse crate::midend::{ir, symtab};\n\npub fn convert_reads_to_ssa(function: \u0026mut symtab::Function) {\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        let mut highest_ssa_numbers = BTreeMap::\u003cir::OperandName, ir::OperandName\u003e::new();\n\n        for arg in \u0026block.arguments {\n            highest_ssa_numbers.insert(arg.clone().into_non_ssa(), arg.clone());\n        }\n\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = match highest_ssa_numbers.get(read) {\n                    Some(operand) =\u003e operand.ssa_number,\n                    None =\u003e {\n                        println!(\"{} has no ssa number (yet)\", read);\n                        None\n                    }\n                };\n            }\n\n            for write in statement.write_operand_names() {\n                match highest_ssa_numbers.get(\u0026write.clone().into_non_ssa()) {\n                    Some(existing_number) =\u003e {\n                        assert!(existing_number.ssa_number.unwrap() \u003c write.ssa_number.unwrap());\n                    }\n                    None =\u003e {}\n                }\n                highest_ssa_numbers.insert(write.clone().into_non_ssa(), write.clone());\n            }\n        }\n    }\n}\n","traces":[{"line":5,"address":[547358,545712,547771],"length":1,"stats":{"Line":0}},{"line":6,"address":[545910,545730],"length":1,"stats":{"Line":0}},{"line":7,"address":[545986],"length":1,"stats":{"Line":0}},{"line":9,"address":[546078,546019],"length":1,"stats":{"Line":0}},{"line":10,"address":[547608,546197],"length":1,"stats":{"Line":0}},{"line":13,"address":[546212],"length":1,"stats":{"Line":0}},{"line":14,"address":[547587,546525,546389,546348],"length":1,"stats":{"Line":0}},{"line":15,"address":[547372,546580,547556],"length":1,"stats":{"Line":0}},{"line":16,"address":[547411],"length":1,"stats":{"Line":0}},{"line":18,"address":[547468],"length":1,"stats":{"Line":0}},{"line":19,"address":[547544],"length":1,"stats":{"Line":0}},{"line":24,"address":[546798,546639],"length":1,"stats":{"Line":0}},{"line":25,"address":[546866,546907,546987],"length":1,"stats":{"Line":0}},{"line":26,"address":[547026],"length":1,"stats":{"Line":0}},{"line":27,"address":[547042,547088],"length":1,"stats":{"Line":0}},{"line":31,"address":[547172],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen","convert_writes.rs"],"content":"use std::{collections::HashMap, fmt::Display};\n\nuse crate::midend::{ir, symtab};\n\n#[derive(Debug)]\nstruct SsaWriteConversionMetadata {\n    variables: HashMap\u003cString, usize\u003e,\n}\n\nimpl Display for SsaWriteConversionMetadata {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut result: std::fmt::Result = write!(f, \"Variables: {{\");\n\n        for (variable, ssa_number) in \u0026self.variables {\n            result = result.and(writeln!(f, \"{}:{}\", variable, ssa_number));\n        }\n\n        result\n    }\n}\n\nimpl SsaWriteConversionMetadata {\n    pub fn new() -\u003e Self {\n        Self {\n            variables: HashMap::new(),\n        }\n    }\n\n    pub fn next_number_for_variable(\u0026mut self, operand_name: \u0026ir::OperandName) -\u003e usize {\n        let entry = self\n            .variables\n            .entry(operand_name.base_name.clone())\n            .or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n\n    pub fn next_number_for_string(\u0026mut self, string: String) -\u003e usize {\n        let entry = self.variables.entry(string).or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n}\n\nfn convert_block_writes_to_ssa(\n    block: \u0026mut ir::BasicBlock,\n    metadata: \u0026mut SsaWriteConversionMetadata,\n) {\n    let old_args = block.arguments.clone();\n    block.arguments.clear();\n\n    for argument in old_args.iter() {\n        let mut new_argument = argument.clone();\n        new_argument.ssa_number = Some(metadata.next_number_for_variable(argument));\n        block.arguments.insert(new_argument);\n    }\n\n    for statement in \u0026mut block.statements {\n        for write in statement.write_operand_names_mut() {\n            write.ssa_number = Some(metadata.next_number_for_variable(write));\n        }\n    }\n}\n\npub fn convert_writes_to_ssa(function: \u0026mut symtab::Function) {\n    let mut write_conversion_metadata = SsaWriteConversionMetadata::new();\n    for argument in \u0026function.prototype.arguments {\n        write_conversion_metadata.next_number_for_string(argument.name());\n    }\n\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        convert_block_writes_to_ssa(block, \u0026mut write_conversion_metadata)\n    }\n}\n","traces":[{"line":11,"address":[413696],"length":1,"stats":{"Line":0}},{"line":12,"address":[413729],"length":1,"stats":{"Line":0}},{"line":14,"address":[414089,413772],"length":1,"stats":{"Line":0}},{"line":15,"address":[413901],"length":1,"stats":{"Line":0}},{"line":18,"address":[414094],"length":1,"stats":{"Line":0}},{"line":23,"address":[414112],"length":1,"stats":{"Line":0}},{"line":25,"address":[414126],"length":1,"stats":{"Line":0}},{"line":29,"address":[414176],"length":1,"stats":{"Line":0}},{"line":30,"address":[414218],"length":1,"stats":{"Line":0}},{"line":32,"address":[414198],"length":1,"stats":{"Line":0}},{"line":34,"address":[414257],"length":1,"stats":{"Line":0}},{"line":35,"address":[414316,414273],"length":1,"stats":{"Line":0}},{"line":40,"address":[414336],"length":1,"stats":{"Line":0}},{"line":41,"address":[414351],"length":1,"stats":{"Line":0}},{"line":42,"address":[414384],"length":1,"stats":{"Line":0}},{"line":43,"address":[414436,414397],"length":1,"stats":{"Line":0}},{"line":49,"address":[415457,414464,415211],"length":1,"stats":{"Line":0}},{"line":53,"address":[414503],"length":1,"stats":{"Line":0}},{"line":54,"address":[414535],"length":1,"stats":{"Line":0}},{"line":56,"address":[415434,414592],"length":1,"stats":{"Line":0}},{"line":57,"address":[415230,414735],"length":1,"stats":{"Line":0}},{"line":58,"address":[415238,415299],"length":1,"stats":{"Line":0}},{"line":59,"address":[415351],"length":1,"stats":{"Line":0}},{"line":62,"address":[414750],"length":1,"stats":{"Line":0}},{"line":63,"address":[414922,414881,415058,415206],"length":1,"stats":{"Line":0}},{"line":64,"address":[415163,415123],"length":1,"stats":{"Line":0}},{"line":69,"address":[415991,415957,415472],"length":1,"stats":{"Line":0}},{"line":70,"address":[415497],"length":1,"stats":{"Line":0}},{"line":71,"address":[415507,415575],"length":1,"stats":{"Line":0}},{"line":72,"address":[415661,415979],"length":1,"stats":{"Line":0}},{"line":75,"address":[415676,415844],"length":1,"stats":{"Line":0}},{"line":76,"address":[415952,415912],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","ssa_gen.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse add_block_args::add_block_arguments;\nuse convert_reads::convert_reads_to_ssa;\nuse convert_writes::convert_writes_to_ssa;\n\nmod add_block_args;\nmod convert_reads;\nmod convert_writes;\n\nuse super::{ir, symtab};\n\nfn convert_function_to_ssa(function: \u0026mut symtab::Function) {\n    add_block_arguments(function);\n    convert_writes_to_ssa(function);\n    convert_reads_to_ssa(function);\n\n    function.control_flow.to_graphviz();\n}\n\npub fn convert_functions_to_ssa(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function_or_prototype) in functions {\n        match function_or_prototype {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e convert_function_to_ssa(function),\n        };\n    }\n}\n\nfn remove_ssa_from_function(function: \u0026mut symtab::Function) {\n    for block in \u0026mut function.control_flow.blocks.values_mut() {\n        let old_arguments = block.arguments.clone();\n        block.arguments.clear();\n        block.arguments = BTreeSet::\u003cir::OperandName\u003e::new();\n        for arg in old_arguments {\n            block.arguments.insert(arg.into_non_ssa());\n        }\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = None;\n            }\n\n            for write in statement.write_operand_names_mut() {\n                write.ssa_number = None;\n            }\n        }\n    }\n    function.control_flow.to_graphviz();\n}\n\npub fn remove_ssa_from_functions(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e remove_ssa_from_function(function),\n        };\n    }\n}\n","traces":[{"line":13,"address":[354240],"length":1,"stats":{"Line":0}},{"line":14,"address":[354254],"length":1,"stats":{"Line":0}},{"line":15,"address":[354264],"length":1,"stats":{"Line":0}},{"line":16,"address":[354274],"length":1,"stats":{"Line":0}},{"line":18,"address":[354284],"length":1,"stats":{"Line":0}},{"line":21,"address":[354304],"length":1,"stats":{"Line":0}},{"line":22,"address":[354319],"length":1,"stats":{"Line":0}},{"line":23,"address":[354412],"length":1,"stats":{"Line":0}},{"line":25,"address":[354459],"length":1,"stats":{"Line":0}},{"line":30,"address":[354480,355869,355835],"length":1,"stats":{"Line":0}},{"line":31,"address":[354503,355285],"length":1,"stats":{"Line":0}},{"line":32,"address":[354613],"length":1,"stats":{"Line":0}},{"line":33,"address":[354648],"length":1,"stats":{"Line":0}},{"line":34,"address":[354729],"length":1,"stats":{"Line":0}},{"line":35,"address":[354998,354846],"length":1,"stats":{"Line":0}},{"line":36,"address":[355079,355857],"length":1,"stats":{"Line":0}},{"line":38,"address":[355134],"length":1,"stats":{"Line":0}},{"line":39,"address":[355306,355442,355270,355532],"length":1,"stats":{"Line":0}},{"line":40,"address":[355497],"length":1,"stats":{"Line":0}},{"line":43,"address":[355812,355722,355565],"length":1,"stats":{"Line":0}},{"line":44,"address":[355777],"length":1,"stats":{"Line":0}},{"line":48,"address":[354660],"length":1,"stats":{"Line":0}},{"line":51,"address":[355904],"length":1,"stats":{"Line":0}},{"line":52,"address":[355919],"length":1,"stats":{"Line":0}},{"line":53,"address":[356012],"length":1,"stats":{"Line":0}},{"line":55,"address":[356059],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","errors.rs"],"content":"use crate::midend::types::Type;\n\npub enum UndefinedSymbolError {\n    Function(String),\n    Method(Type, String),\n    Variable(String),\n    Type(Type),\n    Struct(String),\n}\n\nimpl std::fmt::Display for UndefinedSymbolError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            UndefinedSymbolError::Function(function) =\u003e {\n                write!(f, \"Undefined function {}\", function)\n            }\n            UndefinedSymbolError::Method(receiver, method_name) =\u003e {\n                write!(f, \"{} has no method {}\", receiver, method_name)\n            }\n            UndefinedSymbolError::Variable(variable) =\u003e {\n                write!(f, \"Undeclared variable {}\", variable)\n            }\n            UndefinedSymbolError::Type(type_) =\u003e write!(f, \"Undeclared type {}\", type_),\n            UndefinedSymbolError::Struct(struct_) =\u003e write!(f, \"Undeclared struct {}\", struct_),\n        }\n    }\n}\n\nimpl std::fmt::Debug for UndefinedSymbolError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self)\n    }\n}\n\nimpl UndefinedSymbolError {\n    pub fn function(name: \u0026str) -\u003e Self {\n        Self::Function(name.into())\n    }\n\n    pub fn method(receiver: \u0026Type, method_name: \u0026str) -\u003e Self {\n        Self::Method(receiver.clone(), method_name.into())\n    }\n\n    pub fn variable(name: \u0026str) -\u003e Self {\n        Self::Variable(name.into())\n    }\n\n    pub fn type_(type_: \u0026Type) -\u003e Self {\n        Self::Type(type_.clone())\n    }\n\n    pub fn struct_(name: \u0026str) -\u003e Self {\n        Self::Struct(name.into())\n    }\n}\n","traces":[{"line":12,"address":[325200],"length":1,"stats":{"Line":0}},{"line":13,"address":[325233],"length":1,"stats":{"Line":0}},{"line":14,"address":[325298],"length":1,"stats":{"Line":0}},{"line":15,"address":[325307],"length":1,"stats":{"Line":0}},{"line":17,"address":[325396],"length":1,"stats":{"Line":0}},{"line":18,"address":[325419],"length":1,"stats":{"Line":0}},{"line":20,"address":[325588],"length":1,"stats":{"Line":0}},{"line":21,"address":[325600],"length":1,"stats":{"Line":0}},{"line":23,"address":[325716],"length":1,"stats":{"Line":0}},{"line":24,"address":[325841],"length":1,"stats":{"Line":0}},{"line":30,"address":[325984],"length":1,"stats":{"Line":0}},{"line":31,"address":[326002],"length":1,"stats":{"Line":0}},{"line":36,"address":[326096],"length":1,"stats":{"Line":0}},{"line":37,"address":[326119],"length":1,"stats":{"Line":0}},{"line":40,"address":[326192,326364],"length":1,"stats":{"Line":0}},{"line":41,"address":[326235],"length":1,"stats":{"Line":0}},{"line":44,"address":[326384],"length":1,"stats":{"Line":0}},{"line":45,"address":[326407],"length":1,"stats":{"Line":0}},{"line":48,"address":[326480],"length":1,"stats":{"Line":0}},{"line":49,"address":[326499],"length":1,"stats":{"Line":0}},{"line":52,"address":[326576],"length":1,"stats":{"Line":0}},{"line":53,"address":[326599],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","function.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::{ir, types::Type};\n\nuse super::{scope::Scope, variable::Variable};\n\n#[derive(Debug, Serialize)]\npub enum FunctionOrPrototype {\n    Function(Function),\n    Prototype(FunctionPrototype),\n}\n\nimpl FunctionOrPrototype {\n    pub fn prototype(\u0026self) -\u003e \u0026FunctionPrototype {\n        match self {\n            FunctionOrPrototype::Function(function) =\u003e \u0026function.prototype,\n            FunctionOrPrototype::Prototype(function_prototype) =\u003e function_prototype,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Function {\n    pub prototype: FunctionPrototype,\n    pub scope: Scope,\n    pub control_flow: ir::ControlFlow,\n}\n\nimpl Function {\n    pub fn new(prototype: FunctionPrototype, scope: Scope, control_flow: ir::ControlFlow) -\u003e Self {\n        Function {\n            prototype,\n            scope,\n            control_flow,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        self.prototype.name.clone()\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct FunctionPrototype {\n    pub name: String,\n    pub arguments: Vec\u003cVariable\u003e,\n    pub return_type: Type,\n}\n\nimpl Display for FunctionPrototype {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arguments_string = String::new();\n        for argument in \u0026self.arguments {\n            if arguments_string.len() \u003e 0 {\n                arguments_string = format!(\"{}, {}\", arguments_string, argument);\n            } else {\n                arguments_string = format!(\"{}\", argument);\n            }\n        }\n        match \u0026self.return_type {\n            Type::Unit =\u003e write!(f, \"fun {}({})\", self.name, arguments_string),\n            _ =\u003e write!(\n                f,\n                \"fun {}({}) -\u003e {}\",\n                self.name, arguments_string, self.return_type\n            ),\n        }\n    }\n}\n\nimpl FunctionPrototype {\n    pub fn new(name: String, arguments: Vec\u003cVariable\u003e, return_type: Type) -\u003e Self {\n        FunctionPrototype {\n            name,\n            arguments,\n            return_type,\n        }\n    }\n\n    pub fn create_argument_scope(\u0026mut self) -\u003e Scope {\n        let mut arg_names: Vec\u003cString\u003e = Vec::new();\n        let mut argument_scope = Scope::new();\n        for arg in \u0026self.arguments {\n            arg_names.push(arg.name().clone());\n            argument_scope.insert_variable(arg.clone())\n        }\n\n        argument_scope\n    }\n}\n","traces":[{"line":16,"address":[198032],"length":1,"stats":{"Line":0}},{"line":17,"address":[198042,198110],"length":1,"stats":{"Line":0}},{"line":18,"address":[198100],"length":1,"stats":{"Line":0}},{"line":19,"address":[198079],"length":1,"stats":{"Line":0}},{"line":32,"address":[198128],"length":1,"stats":{"Line":0}},{"line":40,"address":[198240],"length":1,"stats":{"Line":0}},{"line":41,"address":[198257],"length":1,"stats":{"Line":0}},{"line":53,"address":[199427,198288],"length":1,"stats":{"Line":0}},{"line":54,"address":[198326],"length":1,"stats":{"Line":0}},{"line":55,"address":[198336,198408],"length":1,"stats":{"Line":0}},{"line":56,"address":[199422,199164,198488,198898],"length":1,"stats":{"Line":0}},{"line":57,"address":[199182,198937],"length":1,"stats":{"Line":0}},{"line":59,"address":[198947,198917],"length":1,"stats":{"Line":0}},{"line":62,"address":[198508],"length":1,"stats":{"Line":0}},{"line":63,"address":[198600,198557],"length":1,"stats":{"Line":0}},{"line":64,"address":[198745,198577],"length":1,"stats":{"Line":0}},{"line":74,"address":[199456],"length":1,"stats":{"Line":0}},{"line":82,"address":[200016,199536],"length":1,"stats":{"Line":0}},{"line":83,"address":[199571],"length":1,"stats":{"Line":0}},{"line":84,"address":[199581],"length":1,"stats":{"Line":0}},{"line":85,"address":[199695,199630],"length":1,"stats":{"Line":0}},{"line":86,"address":[199854,199804],"length":1,"stats":{"Line":0}},{"line":87,"address":[199984],"length":1,"stats":{"Line":0}},{"line":90,"address":[199816],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","scope.rs"],"content":"use std::collections::HashMap;\n\nuse serde::Serialize;\n\nuse crate::midend::types::Type;\n\nuse super::{\n    errors::UndefinedSymbolError,\n    type_definitions::{StructRepr, TypeDefinition, TypeRepr},\n    variable::Variable,\n};\n\n#[derive(Debug, Serialize)]\npub struct Scope {\n    subscope_indices: Vec\u003cusize\u003e,\n    variables: HashMap\u003cString, Variable\u003e,\n    subscopes: Vec\u003cScope\u003e,\n    type_definitions: HashMap\u003cType, TypeDefinition\u003e,\n}\n\nimpl Scope {\n    pub fn new() -\u003e Self {\n        Scope {\n            subscope_indices: Vec::new(),\n            variables: HashMap::new(),\n            subscopes: Vec::new(),\n            type_definitions: HashMap::new(),\n        }\n    }\n\n    pub fn insert_variable(\u0026mut self, mut variable: Variable) {\n        variable.add_mangled_name(\u0026self.subscope_indices);\n        self.variables.insert(variable.name().clone(), variable);\n    }\n\n    pub fn lookup_declared_variable_by_name\u003c'a\u003e(\u0026'a self, name: \u0026str) -\u003e \u0026'a Variable {\n        self.variables\n            .get(name)\n            .expect(\u0026format!(\"Use of undeclared variable {}\", name))\n    }\n\n    pub fn lookup_variable_by_name(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026Variable, UndefinedSymbolError\u003e {\n        self.variables\n            .get(name)\n            .ok_or(UndefinedSymbolError::variable(name))\n    }\n\n    pub fn lookup_type\u003c'a\u003e(\n        \u0026'a self,\n        type_: \u0026Type,\n    ) -\u003e Result\u003c\u0026'a TypeDefinition, UndefinedSymbolError\u003e {\n        self.type_definitions\n            .get(type_)\n            .ok_or(UndefinedSymbolError::type_(type_))\n    }\n\n    pub fn lookup_type_mut\u003c'a\u003e(\n        \u0026'a mut self,\n        type_: \u0026Type,\n    ) -\u003e Result\u003c\u0026'a mut TypeDefinition, UndefinedSymbolError\u003e {\n        self.type_definitions\n            .get_mut(type_)\n            .ok_or(UndefinedSymbolError::type_(type_))\n    }\n\n    pub fn lookup_struct\u003c'a\u003e(\u0026'a self, name: \u0026str) -\u003e Result\u003c\u0026'a StructRepr, UndefinedSymbolError\u003e {\n        let struct_type = Type::UDT(name.into());\n\n        match self.type_definitions.get(\u0026struct_type) {\n            Some(definition) =\u003e match \u0026definition.repr {\n                TypeRepr::Struct(struct_definition) =\u003e return Ok(struct_definition),\n            },\n            None =\u003e {}\n        }\n\n        Err(UndefinedSymbolError::struct_(name))\n    }\n\n    pub fn insert_subscope(\u0026mut self, subscope: Scope) {\n        self.subscopes.push(subscope);\n    }\n\n    pub fn insert_struct_definition(\u0026mut self, defined_struct: StructRepr) {\n        let struct_type = Type::UDT(defined_struct.name.clone());\n        let def = TypeDefinition::new(struct_type.clone(), TypeRepr::Struct(defined_struct));\n        self.type_definitions.insert(struct_type, def);\n    }\n}\n","traces":[{"line":22,"address":[547792,548074],"length":1,"stats":{"Line":6}},{"line":24,"address":[547814],"length":1,"stats":{"Line":1}},{"line":25,"address":[547824],"length":1,"stats":{"Line":11}},{"line":26,"address":[547873],"length":1,"stats":{"Line":1}},{"line":27,"address":[547919],"length":1,"stats":{"Line":11}},{"line":31,"address":[548096,548438],"length":1,"stats":{"Line":0}},{"line":32,"address":[548134],"length":1,"stats":{"Line":0}},{"line":33,"address":[548208],"length":1,"stats":{"Line":0}},{"line":36,"address":[548480,548762],"length":1,"stats":{"Line":0}},{"line":37,"address":[548505,548719],"length":1,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[548529],"length":1,"stats":{"Line":0}},{"line":42,"address":[548784],"length":1,"stats":{"Line":0}},{"line":43,"address":[548850,548894],"length":1,"stats":{"Line":0}},{"line":45,"address":[548874],"length":1,"stats":{"Line":0}},{"line":48,"address":[548928],"length":1,"stats":{"Line":0}},{"line":52,"address":[548976,549015],"length":1,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[548995],"length":1,"stats":{"Line":0}},{"line":57,"address":[549040],"length":1,"stats":{"Line":0}},{"line":61,"address":[549127,549088],"length":1,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[549107],"length":1,"stats":{"Line":0}},{"line":66,"address":[549152,549479],"length":1,"stats":{"Line":0}},{"line":67,"address":[549222],"length":1,"stats":{"Line":0}},{"line":69,"address":[549327,549264],"length":1,"stats":{"Line":0}},{"line":70,"address":[549365],"length":1,"stats":{"Line":0}},{"line":71,"address":[549378],"length":1,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[549429],"length":1,"stats":{"Line":0}},{"line":79,"address":[549504],"length":1,"stats":{"Line":0}},{"line":80,"address":[549509],"length":1,"stats":{"Line":0}},{"line":83,"address":[549536,550051],"length":1,"stats":{"Line":0}},{"line":84,"address":[549641,549560],"length":1,"stats":{"Line":0}},{"line":85,"address":[549682,549732],"length":1,"stats":{"Line":0}},{"line":86,"address":[549939],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":36},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","type_definitions.rs"],"content":"use std::collections::HashMap;\n\nuse serde::Serialize;\n\nuse crate::midend::types::Type;\n\nuse super::{function::FunctionOrPrototype, variable::Variable, Function, UndefinedSymbolError};\n\n#[derive(Debug, Serialize)]\npub struct TypeDefinition {\n    type_: Type,\n    pub repr: TypeRepr,\n    methods: HashMap\u003cString, FunctionOrPrototype\u003e,\n    associated_functions: HashMap\u003cString, FunctionOrPrototype\u003e,\n}\n\nimpl TypeDefinition {\n    pub fn new(type_: Type, repr: TypeRepr) -\u003e Self {\n        TypeDefinition {\n            type_,\n            repr,\n            methods: HashMap::new(),\n            associated_functions: HashMap::new(),\n        }\n    }\n\n    pub fn lookup_method(\u0026self, name: \u0026str) -\u003e Result\u003c\u0026FunctionOrPrototype, UndefinedSymbolError\u003e {\n        self.methods\n            .get(name)\n            .ok_or(UndefinedSymbolError::method(\u0026self.type_, name))\n    }\n\n    pub fn add_method(\u0026mut self, method: Function) {\n        self.methods\n            .insert(method.name(), FunctionOrPrototype::Function(method));\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub enum TypeRepr {\n    Struct(StructRepr),\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct StructRepr {\n    pub name: String,\n    fields: HashMap\u003cString, Variable\u003e,\n    field_order: Vec\u003cString\u003e,\n}\n\nimpl StructRepr {\n    pub fn new(name: String) -\u003e Self {\n        Self {\n            name,\n            fields: HashMap::new(),\n            field_order: Vec::new(),\n        }\n    }\n\n    pub fn add_field(\u0026mut self, name: String, type_: Type) {\n        self.fields\n            .insert(name.clone(), Variable::new(name.clone(), type_));\n        self.field_order.push(name);\n    }\n\n    pub fn get_field(\u0026self, name: \u0026String) -\u003e Option\u003c\u0026Variable\u003e {\n        self.fields.get(name)\n    }\n}\n","traces":[{"line":18,"address":[297920,298227,298248],"length":1,"stats":{"Line":0}},{"line":22,"address":[298017],"length":1,"stats":{"Line":0}},{"line":23,"address":[298069],"length":1,"stats":{"Line":0}},{"line":27,"address":[298272],"length":1,"stats":{"Line":0}},{"line":28,"address":[298390,298338],"length":1,"stats":{"Line":0}},{"line":30,"address":[298366],"length":1,"stats":{"Line":0}},{"line":33,"address":[298670,298645,298416],"length":1,"stats":{"Line":0}},{"line":34,"address":[298436,298618],"length":1,"stats":{"Line":0}},{"line":35,"address":[298522,298630,298469],"length":1,"stats":{"Line":0}},{"line":52,"address":[298907,298688],"length":1,"stats":{"Line":0}},{"line":55,"address":[298726],"length":1,"stats":{"Line":0}},{"line":56,"address":[298776],"length":1,"stats":{"Line":0}},{"line":60,"address":[299351,298928,299384],"length":1,"stats":{"Line":0}},{"line":61,"address":[299205,298957],"length":1,"stats":{"Line":0}},{"line":62,"address":[299006,299068,299238,299332],"length":1,"stats":{"Line":0}},{"line":63,"address":[299267],"length":1,"stats":{"Line":0}},{"line":66,"address":[299424],"length":1,"stats":{"Line":0}},{"line":67,"address":[299438],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab","variable.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::types::Type;\n\n#[derive(Clone, Debug, Serialize)]\npub struct Variable {\n    name: String,\n    mangled_name: Option\u003cString\u003e,\n    type_: Type,\n}\n\nimpl Display for Variable {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}\", self.type_, self.name)\n    }\n}\n\nimpl Variable {\n    pub fn new(name: String, type_: Type) -\u003e Self {\n        Variable {\n            name,\n            mangled_name: None,\n            type_,\n        }\n    }\n\n    pub fn add_mangled_name(\u0026mut self, scope_indices: \u0026Vec\u003cusize\u003e) {\n        let mut mangled_name = String::new();\n        for scope in scope_indices {\n            mangled_name.push_str(\u0026(scope.to_string() + \u0026String::from(\"_\")));\n        }\n        mangled_name.push_str(\u0026self.name.clone());\n\n        match \u0026self.mangled_name {\n            Some(current_name) =\u003e {\n                panic!(\n                \"Variable {} already has mangled name {}, can't add_mangled_name with new name {}\",\n                self.name,\n                current_name,\n                mangled_name)\n            }\n            None =\u003e self.mangled_name.replace(mangled_name),\n        };\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        match \u0026self.mangled_name {\n            Some(mangled_name) =\u003e mangled_name.clone(),\n            None =\u003e self.name.clone(),\n        }\n    }\n\n    pub fn type_(\u0026self) -\u003e \u0026Type {\n        \u0026self.type_\n    }\n}\n","traces":[{"line":15,"address":[181888],"length":1,"stats":{"Line":0}},{"line":16,"address":[181927],"length":1,"stats":{"Line":0}},{"line":21,"address":[182048],"length":1,"stats":{"Line":0}},{"line":29,"address":[182855,182144,183248],"length":1,"stats":{"Line":0}},{"line":30,"address":[182177],"length":1,"stats":{"Line":0}},{"line":31,"address":[182216,182284],"length":1,"stats":{"Line":0}},{"line":32,"address":[182864,182382],"length":1,"stats":{"Line":0}},{"line":34,"address":[182397],"length":1,"stats":{"Line":0}},{"line":36,"address":[182531],"length":1,"stats":{"Line":0}},{"line":37,"address":[182586],"length":1,"stats":{"Line":0}},{"line":38,"address":[182602,182722],"length":1,"stats":{"Line":0}},{"line":44,"address":[182614],"length":1,"stats":{"Line":0}},{"line":48,"address":[183280],"length":1,"stats":{"Line":0}},{"line":49,"address":[183304],"length":1,"stats":{"Line":0}},{"line":50,"address":[183359],"length":1,"stats":{"Line":0}},{"line":51,"address":[183382],"length":1,"stats":{"Line":0}},{"line":55,"address":[183408],"length":1,"stats":{"Line":0}},{"line":56,"address":[183416],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","symtab.rs"],"content":"use crate::midend::types::Type;\nuse std::collections::HashMap;\n\npub use errors::*;\npub use function::*;\npub use scope::Scope;\nuse serde::Serialize;\nuse std::fmt::Display;\npub use type_definitions::*;\npub use variable::*;\n\nuse super::ir;\n\nmod errors;\nmod function;\nmod scope;\nmod type_definitions;\nmod variable;\n\n#[derive(Debug, Serialize)]\npub struct SymbolTable {\n    pub global_scope: Scope,\n    pub functions: HashMap\u003cString, FunctionOrPrototype\u003e,\n}\n\nimpl SymbolTable {\n    pub fn new() -\u003e Self {\n        SymbolTable {\n            global_scope: Scope::new(),\n            functions: HashMap::new(),\n        }\n    }\n\n    pub fn assign_program_points(\u0026mut self) {\n        // TODO: re-enable this when SSA implemented\n        // for function in self.functions.values_mut() {\n        //     match function {\n        //         FunctionOrPrototype::Function(f) =\u003e {\n        //             f.control_flow_mut().assign_program_points();\n        //             let mut reaching_defs = ReachingDefs::new(f.control_flow());\n        //             reaching_defs.analyze();\n        //             reaching_defs.print();\n        //         }\n        //         FunctionOrPrototype::Prototype(_) =\u003e {}\n        //     }\n        // }\n    }\n\n    pub fn print_ir(\u0026self) {\n        for function in self.functions.values() {\n            match function {\n                FunctionOrPrototype::Function(f) =\u003e {\n                    println!(\"{}\", f.prototype);\n                    f.control_flow.to_graphviz();\n                    println!(\"\");\n                }\n                FunctionOrPrototype::Prototype(_) =\u003e {}\n            }\n        }\n    }\n\n    pub fn insert_function(\u0026mut self, function: Function) {\n        self.functions\n            .insert(function.name(), FunctionOrPrototype::Function(function));\n    }\n\n    pub fn insert_function_prototype(\u0026mut self, prototype: FunctionPrototype) {\n        self.functions.insert(\n            prototype.name.clone(),\n            FunctionOrPrototype::Prototype(prototype),\n        );\n    }\n}\n","traces":[{"line":27,"address":[172960,173099],"length":1,"stats":{"Line":0}},{"line":29,"address":[172982],"length":1,"stats":{"Line":0}},{"line":30,"address":[172995],"length":1,"stats":{"Line":0}},{"line":34,"address":[173136],"length":1,"stats":{"Line":0}},{"line":49,"address":[173152],"length":1,"stats":{"Line":0}},{"line":50,"address":[173170],"length":1,"stats":{"Line":0}},{"line":51,"address":[173292],"length":1,"stats":{"Line":0}},{"line":52,"address":[173339],"length":1,"stats":{"Line":0}},{"line":53,"address":[173347],"length":1,"stats":{"Line":0}},{"line":54,"address":[173440],"length":1,"stats":{"Line":0}},{"line":55,"address":[173452],"length":1,"stats":{"Line":0}},{"line":62,"address":[173736,173761,173504],"length":1,"stats":{"Line":0}},{"line":63,"address":[173709,173524],"length":1,"stats":{"Line":0}},{"line":64,"address":[173560,173721,173613],"length":1,"stats":{"Line":0}},{"line":67,"address":[174107,174132,173776],"length":1,"stats":{"Line":0}},{"line":68,"address":[173796,174080],"length":1,"stats":{"Line":0}},{"line":69,"address":[173824],"length":1,"stats":{"Line":0}},{"line":70,"address":[173894],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend","types.rs"],"content":"use serde::Serialize;\nuse std::fmt::Display;\n\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Serialize, serde::Deserialize, Hash)]\npub enum Mutability {\n    Mutable,\n    Immutable,\n}\n\nimpl Display for Mutability {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Mutability::Mutable =\u003e write!(f, \"mut\"),\n            Mutability::Immutable =\u003e std::fmt::Result::Ok(()),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug, Serialize, serde::Deserialize, Hash)]\npub enum Type {\n    Unit,\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    UDT(String),\n    Self_,\n    Reference(Mutability, Box\u003cType\u003e),\n    Pointer(Mutability, Box\u003cType\u003e),\n}\n\nimpl Display for Type {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Unit =\u003e write!(f, \"()\"),\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::UDT(name) =\u003e write!(f, \"user-defined type {}\", name),\n            Self::Self_ =\u003e write!(f, \"Self\"),\n            Self::Reference(mutability, to) =\u003e write!(f, \"\u0026{} {}\", mutability, to),\n            Self::Pointer(mutability, to) =\u003e write!(f, \"*{} {}\", mutability, to),\n        }\n    }\n}\n","traces":[{"line":11,"address":[184240],"length":1,"stats":{"Line":0}},{"line":12,"address":[184259],"length":1,"stats":{"Line":0}},{"line":13,"address":[184281],"length":1,"stats":{"Line":0}},{"line":14,"address":[184274],"length":1,"stats":{"Line":0}},{"line":37,"address":[184336],"length":1,"stats":{"Line":0}},{"line":38,"address":[184368],"length":1,"stats":{"Line":0}},{"line":39,"address":[184428],"length":1,"stats":{"Line":0}},{"line":40,"address":[184471],"length":1,"stats":{"Line":0}},{"line":41,"address":[184514],"length":1,"stats":{"Line":0}},{"line":42,"address":[184563],"length":1,"stats":{"Line":0}},{"line":43,"address":[184612],"length":1,"stats":{"Line":0}},{"line":44,"address":[184661],"length":1,"stats":{"Line":0}},{"line":45,"address":[184710],"length":1,"stats":{"Line":0}},{"line":46,"address":[184759],"length":1,"stats":{"Line":0}},{"line":47,"address":[184808],"length":1,"stats":{"Line":0}},{"line":48,"address":[184861],"length":1,"stats":{"Line":0}},{"line":49,"address":[184980],"length":1,"stats":{"Line":0}},{"line":50,"address":[185033],"length":1,"stats":{"Line":0}},{"line":51,"address":[185228],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","mitch","code","substratum","rust-rewrite","src","midend.rs"],"content":"use symtab::SymbolTable;\n\nuse crate::frontend;\n\nmod idfa;\npub mod ir;\npub mod linearizer;\nmod optimization;\nmod ssa_gen;\npub mod symtab;\npub mod types;\n\npub fn symbol_table_from_program(\n    program: Vec\u003cfrontend::ast::TranslationUnitTree\u003e,\n) -\u003e symtab::SymbolTable {\n    let mut symtab = SymbolTable::new();\n    linearizer::linearize(\u0026mut symtab, program);\n\n    // ssa_gen::convert_functions_to_ssa(\u0026mut symtab.functions);\n\n    // optimization::optimize_functions(\u0026mut symtab.functions);\n\n    symtab\n}\n","traces":[{"line":13,"address":[1025446,1025232],"length":1,"stats":{"Line":0}},{"line":16,"address":[1025254],"length":1,"stats":{"Line":0}},{"line":17,"address":[1025328],"length":1,"stats":{"Line":0}},{"line":23,"address":[1025418],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>